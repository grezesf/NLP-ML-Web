<!DOCTYPE html>
<html>
<head>
    
    <title>Revisions - Programming Puzzles & Code Golf Stack Exchange</title>
    <link rel="shortcut icon" href="//cdn.sstatic.net/codegolf/img/favicon.ico">
    <link rel="apple-touch-icon image_src" href="//cdn.sstatic.net/codegolf/img/apple-touch-icon.png">
    <link rel="search" type="application/opensearchdescription+xml" title="Programming Puzzles &amp; Code Golf Stack Exchange" href="/opensearch.xml">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@StackCodeGolf" />
    <meta name="twitter:domain" content="codegolf.stackexchange.com"/>
    <meta name="og:type" content="website" />
    <meta name="og:image" content="http://cdn.sstatic.net/codegolf/img/apple-touch-icon.png?v=6f55f0b2476f"/>
    <meta name="og:title" content="Revisions" />
    <meta name="og:description" content="Q&amp;A for programming puzzle enthusiasts and code golfers" />
    <meta name="og:url" content="http://codegolf.stackexchange.com/posts/1642/revisions"/>

    
    
    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="//cdn.sstatic.net/Js/stub.en.js?v=e3d47b73fa12" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="//cdn.sstatic.net/codegolf/all.css?v=a1dd281cae8a">
    

    <script type="text/javascript">
        StackExchange.ready(function () {
            StackExchange.realtime.init('wss://qa.sockets.stackexchange.com,ws://qa.sockets.stackexchange.com');
            StackExchange.realtime.subscribeToInboxNotifications();
                    StackExchange.realtime.subscribeToReputationNotifications('200');
                        });
    </script>
    <script type="text/javascript">
        StackExchange.init({"locale":"en","stackAuthUrl":"https://stackauth.com","serverTime":1385453127,"styleCode":true,"enableUserHovercards":true,"site":{"name":"Programming Puzzles & Code Golf Stack Exchange","description":"Q&A for programming puzzle enthusiasts and code golfers","isNoticesTabEnabled":true,"recaptchaPublicKey":"6LdsB7sSAAAAAAzjgEF_Hd8vXv-C42sa_KyofaGR","enableSocialMediaInSharePopup":true},"user":{"fkey":"f51c005c36aeb04be7163e16a81b52d5","isAnonymous":true}});
        StackExchange.using.setCacheBreakers({"js/prettify-full.en.js":"e0bbd4760e83","js/moderator.en.js":"1a411fd265fe","js/full-anon.en.js":"8a881a0975af","js/full.en.js":"e87912181c10","js/wmd.en.js":"bd9234d44a40","js/third-party/jquery.autocomplete.min.js":"e5f01e97f7c3","js/third-party/jquery.autocomplete.min.en.js":"","js/mobile.en.js":"d1d834ef85d2","js/help.en.js":"d3cc74d8a93a","js/tageditor.en.js":"6d51a5f8d7f3","js/tageditornew.en.js":"111b781cf314","js/inline-tag-editing.en.js":"f951bd09dc69","js/revisions.en.js":"33fd38144303","js/review.en.js":"f45b4ec094ea","js/tagsuggestions.en.js":"e4e7b952fcc7","js/post-validation.en.js":"c275fe37d674","js/explore-qlist.en.js":"73825bd006fc","js/events.en.js":"53bc48767091"});
        StackExchange.using("gps", function() {
             StackExchange.gps.init(true);
        });
        
    </script>
    
        <script type="text/javascript">
            StackExchange.ready(function () {
                $('#nav-tour').click(function () {
                    StackExchange.using("gps", function() {
                        StackExchange.gps.track("aboutpage.click", { aboutclick_location: "headermain" }, true);
                    });
                });
            });
        </script>
</head>
<body class="revision-page">
    <noscript><div id="noscript-padding"></div></noscript>
    <div id="notify-container"></div>
    <div id="overlay-header"></div>
    <div id="custom-header"></div>
    <div class="container">
        <div id="header" class=headeranon>
            <div id="portalLink">
                <a class="genu" href="http://stackexchange.com" onclick="StackExchange.ready(function(){genuwine.click();});return false;">Stack Exchange</a>
            </div>
            <div id="topbar">
                <div id="hlinks">
                    
<span id="hlinks-user"></span>
<span id="hlinks-nav">                        <a href="/users/login?returnurl=%2fposts%2f1642%2frevisions">sign up</a>

 <span class="lsep">|</span>
                    <a href="/users/login?returnurl=%2fposts%2f1642%2frevisions">log in</a>

 <span class="lsep">|</span>
</span>
<span id="hlinks-custom"></span>
                </div>
                <div id="hsearch">
                    <form id="search" action="/search" method="get" autocomplete="off">
                        <div>
                            <input autocomplete="off" name="q" class="textbox" placeholder="search" tabindex="1" type="text" maxlength="240" size="28" value="">
                        </div>
                    </form>
                </div>
            </div>
            <br class="cbt">
            <div id="hlogo">
                <a href="/">
                    Programming Puzzles &amp; Code Golf
                        <span class="beta-title">beta</span>
                </a>
            </div>
            <div id="hmenus">
                <div class="nav mainnavs mainnavsanon">
                    <ul>
                            <li><a id="nav-questions" href="/questions">Questions</a></li>
                            <li><a id="nav-tags" href="/tags">Tags</a></li>
                            <li><a id="nav-tour" href="/about">Tour</a></li>
                            <li><a id="nav-users" href="/users">Users</a></li>
                    </ul>
                </div>
                <div class="nav askquestion">
                    <ul>
                        <li>
                            <a id="nav-askquestion"  href="/questions/ask">Ask Question</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        



        <div id="content">
            


<div id="mainbar-full">

    <div class="subheader">
        <h1><a href="/questions/1595/interpret-fish/1642#1642" class="answer-hyperlink ">Return to Answer</a></h1>
    </div>

    <div id="revisions">
        <table>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('ac60dc49-06f9-4707-8c67-5b39725e16c4') ">
                        <span id="rev-arrow-ac60dc49-06f9-4707-8c67-5b39725e16c4" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('ac60dc49-06f9-4707-8c67-5b39725e16c4') ">
                        <span title="revision 3">3</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">-154</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/ac60dc49-06f9-4707-8c67-5b39725e16c4/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/1642/3" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info ">
    <div class="user-action-time">
        edited <span title="2011-03-21 11:31:51Z" class="relativetime">Mar 21 '11 at 11:31</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/907/patrickvl"><div><img src="https://www.gravatar.com/avatar/bc6453e15d0cd125744ba9a610ababe2?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/907/patrickvl">PatrickvL</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">541</span><span title="2 silver badges"><span class="badge2"></span><span class="badgecount">2</span></span><span title="6 bronze badges"><span class="badge3"></span><span class="badgecount">6</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="revac60dc49-06f9-4707-8c67-5b39725e16c4" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <h2>Delphi,<span class="diff-delete"> 1855</span><span class="diff-add"> </span><strike><span class="diff-add">1855</span></strike> <span class="diff-add">1701</span></h2><p> This version has thread-support<span class="diff-delete"> (at</span><span class="diff-add"> at</span> quite a cost<span class="diff-delete">, alas)</span> :<span class="diff-add"> The version without thread-support is 1144 characters right now, so thread-support adds 557 characters (about 50%)!</span></p><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,<span class="diff-delete">q,</span>v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.<span class="diff-delete">U(v:Int16);begin</span><span class="diff-add">U;begin</span> if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.<span class="diff-delete">O:Int16;begin</span><span class="diff-add">O;begin</span> if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1)<span class="diff-delete">;l:=l-1;end;procedure</span><span class="diff-add">;Dec(l)end;procedure</span> _.<span class="diff-delete">T(a,b:Int16);begin</span><span class="diff-add">T;begin</span> if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w])<span class="diff-delete">;end;var</span><span class="diff-add">end;var</span> j:byte;begin h:=AllocMem(<span class="diff-delete">36</span><span class="diff-add">32</span>);h.n:=h;h.x:=1;h.v:=-<span class="diff-delete">1;AssignFile</span><span class="diff-add">1;Assign</span>(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do<span class="diff-delete"> if q&lt;&gt;0then</span> <span class="diff-delete">if(q=i)then q:=0 else U(i)else </span>begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:<span class="diff-delete">=Random(4);case</span><span class="diff-add">=i;case</span> i-32of <span class="diff-delete">4</span><span class="diff-add">2,7:repeat E;U(i);Inc(l)until i=A;4</span>,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-<span class="diff-delete">b;73</span><span class="diff-add">b;88</span>:<span class="diff-add">i:=Ord('&lt;&gt;^v'[1+Random(4)]);91:l:=1;73:</span>Read(PChar(@A)^)<span class="diff-delete">;end;case</span><span class="diff-add">end;case i-32of 4:l:=l+1;80:l:=O;91:A:=O;93:l:=2;26:U(A)end;case</span> i-32of 0<span class="diff-add">,88</span>:;1:E;2,7<span class="diff-delete">:q</span><span class="diff-add">,94</span>:<span class="diff-delete">=i;3</span><span class="diff-add">O;3</span>:T(-x,-y);4<span class="diff-add">,32,93</span>:<span class="diff-delete">begin</span><span class="diff-add">if</span> <span class="diff-delete">l:=O;U</span><span class="diff-add">p&gt;0then Insert</span>(<span class="diff-add">Chr(</span>A)<span class="diff-delete">;U</span><span class="diff-add">,g,l-1)else Insert(Chr</span>(<span class="diff-add">A),s,</span>l<span class="diff-add">-1</span>)<span class="diff-delete">end;5</span><span class="diff-add">;5</span>:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26<span class="diff-add">,73,91</span>:<span class="diff-delete">begin </span>U<span class="diff-delete">(A);U</span>(A)<span class="diff-delete">end;28</span><span class="diff-add">;28,30</span>:T(<span class="diff-add">i</span>-<span class="diff-delete">1</span><span class="diff-add">61</span>,0);29:U(Ord(O=O<span class="diff-delete">)</span>)<span class="diff-delete">;30:T(1,0</span>);31:if(l=0)or(k[l]=#0)then<span class="diff-delete"> E;32:if p&gt;0then Insert(Char(A),g,l-1)else</span> <span class="diff-delete">Insert(Char(A),s,l-2);59</span><span class="diff-add">E;59</span>:<span class="diff-delete">if(d=nil)then </span>d:=AllocMem(<span class="diff-delete">36</span><span class="diff-add">32</span>);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:<span class="diff-delete">=n;FreeMem(d);end;62</span><span class="diff-add">=n;d</span>:<span class="diff-add">=nil;end;62:</span>T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]))<span class="diff-delete">;73:U(A)</span>;77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80<span class="diff-delete">:begin l</span>:<span class="diff-delete">=O;c[1+O+80*l]</span><span class="diff-add">c[1+O+80*l]</span>:=Chr(A)<span class="diff-delete">end;82</span><span class="diff-add">;82</span>:for j:<span class="diff-delete">=0to </span><span class="diff-add">=1to(</span>l<span class="diff-delete">-1do</span><span class="diff-add">)do</span> <span class="diff-delete">s[j+1]</span><span class="diff-add">s[j]</span>:=k[l-<span class="diff-delete">j];86</span><span class="diff-add">j+1];86</span>:T(0<span class="diff-delete">,1);88:T(1-2*(A and 1)</span>,1<span class="diff-delete">-(A and 2));91:begin l:=1;A:=O;U(A</span>)<span class="diff-delete">end;92</span><span class="diff-add">;92</span>:T(-x,y<span class="diff-delete">);93:if p&gt;0then Insert(Char(A</span>)<span class="diff-delete">,g,1)</span>else<span class="diff-delete"> Insert(Char(A),s,1);94:O;else</span> Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
<span class="diff-delete">  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
</span>  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.<span class="diff-delete">U(v:Int16);</span><span class="diff-add">U;</span> // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.<span class="diff-delete">O:Int16;</span><span class="diff-add">O;</span> // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  <span class="diff-add">Dec(</span>l<span class="diff-delete">:=l-1;</span><span class="diff-add">)</span>
end;

procedure _.<span class="diff-delete">T(a,b:Int16);</span><span class="diff-add">T;</span> // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w])<span class="diff-delete">;</span>
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)<span class="diff-delete">=36</span><span class="diff-add">=32</span>);
  // Initialize first thread :
  h:=AllocMem(<span class="diff-delete">36</span><span class="diff-add">32</span>);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  <span class="diff-delete">AssignFile</span><span class="diff-add">Assign</span>(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
<span class="diff-add">    // Take a step (which gives a new 'i'nstruction)
</span>    h.E;
    with h^ do
<span class="diff-delete">      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-1)else Insert(Char(A),s,l-1); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
</span><span class="diff-add">    begin
      // Make a copy of the active stack, and determine it's length :
      k:=s;
      if p&gt;0then
        k:=g;
      l:=Length(k);
      // Shorten '''' and '"' (case 2 and 7) string-collecting, by remembering the quote character in A :
      A:=i;
      // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits
        // Shorten string-collecting, by pushing the entire string here (the opening quote was remembered in A) :
        2,7:repeat E;U(i);Inc(l)until i=A; // Note :  We stop at the closing character, so the next block will still handle 'i'!
        // These instructions all need to Pop A, so write it just once here :
        4,5,8,9,12,13,26,32,71,80,93:A:=O;
        // Prevent begin+end for register access, by switching the read/write flag here :
        6:b:=1-b;
        // 'x' (case 120&gt;88): Turn random direction; Choose a random direction instruction and let the 3rd case-block handle it :
        88:i:=Ord('&lt;&gt;^v'[1+Random(4)]);
        // Shorten '{' (case 123-32=91): Share 3rd case-block with ':' (&gt;26) and 'i' (&gt;73) by setting l to 1 here :
        91:l:=1;
        // Prevent begin+end for input retrieval, by reading the input into A here :
        73:Read(PChar(@A)^) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      end;

      // Shorten a few more cases by preparing variables so they can be shared with eachother and the 3rd case-block below :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
        // Shorten '$' (case 38-32=4): Set 'l' to l+1 so that the 3rd case-block can insert just like '@' and '}' :
        4:l:=l+1;
        // Shorten 'p' (case 112-32=80): Set 'l' to O() so that the 3rd case-block doesn't need a begin+end pair :
        80:l:=O;
        // Shorten '{' (case 123-32=91): Share 3rd case-block with ':' (&gt;26) and 'i' (&gt;73) by popping A from position 1, as tricked above!:
        91:A:=O; // Note : This is NOT the same as doing this in the 1st case-block, as 'l' needs to be 1 first!
        // Shorten '}' (case 125-32=93): Prepare 'l' so that the implementation can be shared with '@' (&gt;32):
        93:l:=2;
        // Shorten ':' (case 58-32=26): Share implementation with 'i' (&gt;73) by pushing first copy of A (read above) here
        26:U(A) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      end;

      // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
        //' ': Ignore spaces
        0,88:;
        //'!': Skips the following instruction.
        1:E;
        //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
        //'~': Removes the top value from the stack.
        2,7,94:O;
        //'#': Mirror both axes
        3:T(-x,-y);
        //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
        //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
        //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
        4,
        32,
        93:if p&gt;0then Insert(Chr(A),g,l-1)else Insert(Chr(A),s,l-1); // Note : A was Popped in 1st case block
        //'%': Pops A and B off the stack, and pushes B mod A.
        5:U(O mod A);
        //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
        6:if b=0then U(m)else m:=O;
        //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
        8:U(Ord(O&gt;A));
        //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
        9:U(Ord(O&lt;A));
        //'*': Pops A and B off the stack, and pushes B * A.
        10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
        //'+': Pops A and B off the stack, and pushes B + A.
        11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
        //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
        12:U(O div A);
        //'-': Pops A and B off the stack, and pushes B - A.
        13:U(O-A);
        //'.': Switch between thread-local and global stack
        14:p:=1-p;
        //'/': Mirror
        15:T(-y,-x);
        //'0'..'9': Push value 0-9 onto the stack.
        16..25:U(i-48);
        //':': Duplicates the top value on the stack.
        //'i': Takes one character as user input and pushes it's ASCII value to the stack
        //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
        26,      // Note for ':' : First A was already pushed once above
        73,      // Note for 'i' : Read() into A was done in 1st case block
        91:U(A); // Note for '{' : l=1 was done in 1st case block, A:=O was done in 2nd block
        //'&lt;': Turn west
        //'&gt;': Turn east
        28,30:T(i-61,0);
        //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
        29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
        //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
        31:if(l=0)or(k[l]=#0)then E;
        //'[': Creates a new thread at the next direction-changing instruction.
        59:d:=AllocMem(32); // Note : Double execution gives memleaks, could be fixed with prefix 'if(d=nil)then '
        //'\': Mirror
        60:T(y,x);
        //']': Ends the current thread.
        61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;d:=nil;end; // Note : Memleak on d could be fixed with FreeMem(d)
        //'^': Turn north
        62:T(0,-1);
        //'_': Mirror y
        63:T(x,-y);
        //'a'..'f': Push value 10-15 onto the stack.
        65..70:U(i-87);
        //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
        71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
        //'m': Takes all data from the current stack and moves it to the end of the other stack.
        77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
        //'n': Pops and outputs the value
        78:Write(O);
        //'o': Pops and outputs as a character
        79:Write(Chr(O));
        //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
        80:c[1+O+80*l]:=Chr(A); // Note : A was Popped in 1st case block, l was set to 1 in 2nd case block
        //'r': Reverses the stack.
        82:for j:=1to(l)do s[j]:=k[l-j+1]; // Note: This reads from the stack-copy
        //'v': Turn south
        86:T(0,1);
        //'|': Mirror x
        92:T(-x,y) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      else // ';' (27) and unrecognized instructions end execution.
        Exit;
</span>      end;
<span class="diff-add">    end;
</span>  until 0=1;
end.
</code></pre><p><span class="diff-add"> Edit history :</span></p><p><span class="diff-add">(1855-154=1701) : Applied all ideas from the non-threaded version</span></p>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <h2>Delphi,<span class="diff-delete"> 1855</span></h2><p> This version has thread-support<span class="diff-delete"> (at</span> quite a cost<span class="diff-delete">, alas)</span> :</p><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,<span class="diff-delete">q,</span>v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.<span class="diff-delete">U(v:Int16);begin</span> if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.<span class="diff-delete">O:Int16;begin</span> if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1)<span class="diff-delete">;l:=l-1;end;procedure</span> _.<span class="diff-delete">T(a,b:Int16);begin</span> if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w])<span class="diff-delete">;end;var</span> j:byte;begin h:=AllocMem(<span class="diff-delete">36</span>);h.n:=h;h.x:=1;h.v:=-<span class="diff-delete">1;AssignFile</span>(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do<span class="diff-delete"> if q&lt;&gt;0then</span> <span class="diff-delete">if(q=i)then q:=0 else U(i)else </span>begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:<span class="diff-delete">=Random(4);case</span> i-32of <span class="diff-delete">4</span>,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-<span class="diff-delete">b;73</span>:Read(PChar(@A)^)<span class="diff-delete">;end;case</span> i-32of 0:;1:E;2,7<span class="diff-delete">:q</span>:<span class="diff-delete">=i;3</span>:T(-x,-y);4:<span class="diff-delete">begin</span> <span class="diff-delete">l:=O;U</span>(A)<span class="diff-delete">;U</span>(l)<span class="diff-delete">end;5</span>:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26:<span class="diff-delete">begin </span>U<span class="diff-delete">(A);U</span>(A)<span class="diff-delete">end;28</span>:T(-<span class="diff-delete">1</span>,0);29:U(Ord(O=O<span class="diff-delete">)</span>)<span class="diff-delete">;30:T(1,0</span>);31:if(l=0)or(k[l]=#0)then<span class="diff-delete"> E;32:if p&gt;0then Insert(Char(A),g,l-1)else</span> <span class="diff-delete">Insert(Char(A),s,l-2);59</span>:<span class="diff-delete">if(d=nil)then </span>d:=AllocMem(<span class="diff-delete">36</span>);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:<span class="diff-delete">=n;FreeMem(d);end;62</span>:T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]))<span class="diff-delete">;73:U(A)</span>;77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80<span class="diff-delete">:begin l</span>:<span class="diff-delete">=O;c[1+O+80*l]</span>:=Chr(A)<span class="diff-delete">end;82</span>:for j:<span class="diff-delete">=0to </span>l<span class="diff-delete">-1do</span> <span class="diff-delete">s[j+1]</span>:=k[l-<span class="diff-delete">j];86</span>:T(0<span class="diff-delete">,1);88:T(1-2*(A and 1)</span>,1<span class="diff-delete">-(A and 2));91:begin l:=1;A:=O;U(A</span>)<span class="diff-delete">end;92</span>:T(-x,y<span class="diff-delete">);93:if p&gt;0then Insert(Char(A</span>)<span class="diff-delete">,g,1)</span>else<span class="diff-delete"> Insert(Char(A),s,1);94:O;else</span> Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
<span class="diff-delete">  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
</span>  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.<span class="diff-delete">U(v:Int16);</span> // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.<span class="diff-delete">O:Int16;</span> // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  l<span class="diff-delete">:=l-1;</span>
end;

procedure _.<span class="diff-delete">T(a,b:Int16);</span> // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w])<span class="diff-delete">;</span>
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)<span class="diff-delete">=36</span>);
  // Initialize first thread :
  h:=AllocMem(<span class="diff-delete">36</span>);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  <span class="diff-delete">AssignFile</span>(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
    h.E;
    with h^ do
<span class="diff-delete">      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-1)else Insert(Char(A),s,l-1); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
</span>      end;
  until 0=1;
end.
</code></pre>
            </div>
            <div class="post-text">
                <h2>Delphi,<span class="diff-add"> </span><strike><span class="diff-add">1855</span></strike> <span class="diff-add">1701</span></h2><p> This version has thread-support<span class="diff-add"> at</span> quite a cost :<span class="diff-add"> The version without thread-support is 1144 characters right now, so thread-support adds 557 characters (about 50%)!</span></p><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.<span class="diff-add">U;begin</span> if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.<span class="diff-add">O;begin</span> if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1)<span class="diff-add">;Dec(l)end;procedure</span> _.<span class="diff-add">T;begin</span> if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w])<span class="diff-add">end;var</span> j:byte;begin h:=AllocMem(<span class="diff-add">32</span>);h.n:=h;h.x:=1;h.v:=-<span class="diff-add">1;Assign</span>(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:<span class="diff-add">=i;case</span> i-32of <span class="diff-add">2,7:repeat E;U(i);Inc(l)until i=A;4</span>,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-<span class="diff-add">b;88</span>:<span class="diff-add">i:=Ord('&lt;&gt;^v'[1+Random(4)]);91:l:=1;73:</span>Read(PChar(@A)^)<span class="diff-add">end;case i-32of 4:l:=l+1;80:l:=O;91:A:=O;93:l:=2;26:U(A)end;case</span> i-32of 0<span class="diff-add">,88</span>:;1:E;2,7<span class="diff-add">,94</span>:<span class="diff-add">O;3</span>:T(-x,-y);4<span class="diff-add">,32,93</span>:<span class="diff-add">if</span> <span class="diff-add">p&gt;0then Insert</span>(<span class="diff-add">Chr(</span>A)<span class="diff-add">,g,l-1)else Insert(Chr</span>(<span class="diff-add">A),s,</span>l<span class="diff-add">-1</span>)<span class="diff-add">;5</span>:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26<span class="diff-add">,73,91</span>:U(A)<span class="diff-add">;28,30</span>:T(<span class="diff-add">i</span>-<span class="diff-add">61</span>,0);29:U(Ord(O=O));31:if(l=0)or(k[l]=#0)then <span class="diff-add">E;59</span>:d:=AllocMem(<span class="diff-add">32</span>);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:<span class="diff-add">=n;d</span>:<span class="diff-add">=nil;end;62:</span>T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]));77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80:<span class="diff-add">c[1+O+80*l]</span>:=Chr(A)<span class="diff-add">;82</span>:for j:<span class="diff-add">=1to(</span>l<span class="diff-add">)do</span> <span class="diff-add">s[j]</span>:=k[l-<span class="diff-add">j+1];86</span>:T(0,1)<span class="diff-add">;92</span>:T(-x,y)else Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.<span class="diff-add">U;</span> // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.<span class="diff-add">O;</span> // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  <span class="diff-add">Dec(</span>l<span class="diff-add">)</span>
end;

procedure _.<span class="diff-add">T;</span> // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w])
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)<span class="diff-add">=32</span>);
  // Initialize first thread :
  h:=AllocMem(<span class="diff-add">32</span>);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  <span class="diff-add">Assign</span>(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
<span class="diff-add">    // Take a step (which gives a new 'i'nstruction)
</span>    h.E;
    with h^ do
<span class="diff-add">    begin
      // Make a copy of the active stack, and determine it's length :
      k:=s;
      if p&gt;0then
        k:=g;
      l:=Length(k);
      // Shorten '''' and '"' (case 2 and 7) string-collecting, by remembering the quote character in A :
      A:=i;
      // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits
        // Shorten string-collecting, by pushing the entire string here (the opening quote was remembered in A) :
        2,7:repeat E;U(i);Inc(l)until i=A; // Note :  We stop at the closing character, so the next block will still handle 'i'!
        // These instructions all need to Pop A, so write it just once here :
        4,5,8,9,12,13,26,32,71,80,93:A:=O;
        // Prevent begin+end for register access, by switching the read/write flag here :
        6:b:=1-b;
        // 'x' (case 120&gt;88): Turn random direction; Choose a random direction instruction and let the 3rd case-block handle it :
        88:i:=Ord('&lt;&gt;^v'[1+Random(4)]);
        // Shorten '{' (case 123-32=91): Share 3rd case-block with ':' (&gt;26) and 'i' (&gt;73) by setting l to 1 here :
        91:l:=1;
        // Prevent begin+end for input retrieval, by reading the input into A here :
        73:Read(PChar(@A)^) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      end;

      // Shorten a few more cases by preparing variables so they can be shared with eachother and the 3rd case-block below :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
        // Shorten '$' (case 38-32=4): Set 'l' to l+1 so that the 3rd case-block can insert just like '@' and '}' :
        4:l:=l+1;
        // Shorten 'p' (case 112-32=80): Set 'l' to O() so that the 3rd case-block doesn't need a begin+end pair :
        80:l:=O;
        // Shorten '{' (case 123-32=91): Share 3rd case-block with ':' (&gt;26) and 'i' (&gt;73) by popping A from position 1, as tricked above!:
        91:A:=O; // Note : This is NOT the same as doing this in the 1st case-block, as 'l' needs to be 1 first!
        // Shorten '}' (case 125-32=93): Prepare 'l' so that the implementation can be shared with '@' (&gt;32):
        93:l:=2;
        // Shorten ':' (case 58-32=26): Share implementation with 'i' (&gt;73) by pushing first copy of A (read above) here
        26:U(A) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      end;

      // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
      case i-32of // Note : The instruction is decreased by 32, resulting in less digits in the cases below!
        //' ': Ignore spaces
        0,88:;
        //'!': Skips the following instruction.
        1:E;
        //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
        //'~': Removes the top value from the stack.
        2,7,94:O;
        //'#': Mirror both axes
        3:T(-x,-y);
        //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
        //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
        //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
        4,
        32,
        93:if p&gt;0then Insert(Chr(A),g,l-1)else Insert(Chr(A),s,l-1); // Note : A was Popped in 1st case block
        //'%': Pops A and B off the stack, and pushes B mod A.
        5:U(O mod A);
        //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
        6:if b=0then U(m)else m:=O;
        //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
        8:U(Ord(O&gt;A));
        //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
        9:U(Ord(O&lt;A));
        //'*': Pops A and B off the stack, and pushes B * A.
        10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
        //'+': Pops A and B off the stack, and pushes B + A.
        11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
        //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
        12:U(O div A);
        //'-': Pops A and B off the stack, and pushes B - A.
        13:U(O-A);
        //'.': Switch between thread-local and global stack
        14:p:=1-p;
        //'/': Mirror
        15:T(-y,-x);
        //'0'..'9': Push value 0-9 onto the stack.
        16..25:U(i-48);
        //':': Duplicates the top value on the stack.
        //'i': Takes one character as user input and pushes it's ASCII value to the stack
        //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
        26,      // Note for ':' : First A was already pushed once above
        73,      // Note for 'i' : Read() into A was done in 1st case block
        91:U(A); // Note for '{' : l=1 was done in 1st case block, A:=O was done in 2nd block
        //'&lt;': Turn west
        //'&gt;': Turn east
        28,30:T(i-61,0);
        //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
        29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
        //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
        31:if(l=0)or(k[l]=#0)then E;
        //'[': Creates a new thread at the next direction-changing instruction.
        59:d:=AllocMem(32); // Note : Double execution gives memleaks, could be fixed with prefix 'if(d=nil)then '
        //'\': Mirror
        60:T(y,x);
        //']': Ends the current thread.
        61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;d:=nil;end; // Note : Memleak on d could be fixed with FreeMem(d)
        //'^': Turn north
        62:T(0,-1);
        //'_': Mirror y
        63:T(x,-y);
        //'a'..'f': Push value 10-15 onto the stack.
        65..70:U(i-87);
        //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
        71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
        //'m': Takes all data from the current stack and moves it to the end of the other stack.
        77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
        //'n': Pops and outputs the value
        78:Write(O);
        //'o': Pops and outputs as a character
        79:Write(Chr(O));
        //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
        80:c[1+O+80*l]:=Chr(A); // Note : A was Popped in 1st case block, l was set to 1 in 2nd case block
        //'r': Reverses the stack.
        82:for j:=1to(l)do s[j]:=k[l-j+1]; // Note: This reads from the stack-copy
        //'v': Turn south
        86:T(0,1);
        //'|': Mirror x
        92:T(-x,y) // Note : This case is last, because it ends on ')', which avoids a closing ';'
      else // ';' (27) and unrecognized instructions end execution.
        Exit;
</span>      end;
<span class="diff-add">    end;
</span>  until 0=1;
end.
</code></pre><p><span class="diff-add"> Edit history :</span></p><p><span class="diff-add">(1855-154=1701) : Applied all ideas from the non-threaded version</span></p>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-ac60dc49-06f9-4707-8c67-5b39725e16c4">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('054d7084-63a2-4a07-955f-d9ecffdc6197') ">
                        <span id="rev-arrow-054d7084-63a2-4a07-955f-d9ecffdc6197" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('054d7084-63a2-4a07-955f-d9ecffdc6197') ">
                        <span title="revision 2">2</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">bugfix</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/054d7084-63a2-4a07-955f-d9ecffdc6197/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/1642/2" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info ">
    <div class="user-action-time">
        edited <span title="2011-03-15 22:11:18Z" class="relativetime">Mar 15 '11 at 22:11</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/907/patrickvl"><div><img src="https://www.gravatar.com/avatar/bc6453e15d0cd125744ba9a610ababe2?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/907/patrickvl">PatrickvL</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">541</span><span title="2 silver badges"><span class="badge2"></span><span class="badgecount">2</span></span><span title="6 bronze badges"><span class="badge3"></span><span class="badgecount">6</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev054d7084-63a2-4a07-955f-d9ecffdc6197" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <div class="diff-skipped"><div></div></div><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,q,v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.U(v:Int16);begin if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.O:Int16;begin if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1);l:=l-1;end;procedure _.T(a,b:Int16);begin if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w]);end;var j:byte;begin h:=AllocMem(36);h.n:=h;h.x:=1;h.v:=-1;AssignFile(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do if q&lt;&gt;0then if(q=i)then q:=0 else U(i)else begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:=Random(4);case i-32of 4,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-b;73:Read(PChar(@A)^);end;case i-32of 0:;1:E;2,7:q:=i;3:T(-x,-y);4:begin l:=O;U(A);U(l)end;5:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26:begin U(A);U(A)end;28:T(-1,0);29:U(Ord(O=O));30:T(1,0);31:if(l=0)or(k[l]=#0)then E;32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-delete">2</span><span class="diff-add">1</span>)else Insert(Char(A),s,l-2);59:if(d=nil)then d:=AllocMem(36);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;62:T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]));73:U(A);77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80:begin l:=O;c[1+O+80*l]:=Chr(A)end;82:for j:=0to l-1do s[j+1]:=k[l-j];86:T(0,1);88:T(1-2*(A and 1),1-(A and 2));91:begin l:=1;A:=O;U(A)end;92:T(-x,y);93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1);94:O;else Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.U(v:Int16); // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.O:Int16; // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  l:=l-1;
end;

procedure _.T(a,b:Int16); // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w]);
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)=36);
  // Initialize first thread :
  h:=AllocMem(36);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  AssignFile(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
    h.E;
    with h^ do
      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-delete">2</span><span class="diff-add">1</span>)else Insert(Char(A),s,l-<span class="diff-delete">2</span><span class="diff-add">1</span>); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
      end;
  until 0=1;
end.
</code></pre>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <div class="diff-skipped"><div></div></div><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,q,v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.U(v:Int16);begin if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.O:Int16;begin if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1);l:=l-1;end;procedure _.T(a,b:Int16);begin if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w]);end;var j:byte;begin h:=AllocMem(36);h.n:=h;h.x:=1;h.v:=-1;AssignFile(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do if q&lt;&gt;0then if(q=i)then q:=0 else U(i)else begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:=Random(4);case i-32of 4,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-b;73:Read(PChar(@A)^);end;case i-32of 0:;1:E;2,7:q:=i;3:T(-x,-y);4:begin l:=O;U(A);U(l)end;5:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26:begin U(A);U(A)end;28:T(-1,0);29:U(Ord(O=O));30:T(1,0);31:if(l=0)or(k[l]=#0)then E;32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-delete">2</span>)else Insert(Char(A),s,l-2);59:if(d=nil)then d:=AllocMem(36);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;62:T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]));73:U(A);77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80:begin l:=O;c[1+O+80*l]:=Chr(A)end;82:for j:=0to l-1do s[j+1]:=k[l-j];86:T(0,1);88:T(1-2*(A and 1),1-(A and 2));91:begin l:=1;A:=O;U(A)end;92:T(-x,y);93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1);94:O;else Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.U(v:Int16); // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.O:Int16; // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  l:=l-1;
end;

procedure _.T(a,b:Int16); // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w]);
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)=36);
  // Initialize first thread :
  h:=AllocMem(36);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  AssignFile(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
    h.E;
    with h^ do
      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-delete">2</span>)else Insert(Char(A),s,l-<span class="diff-delete">2</span>); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
      end;
  until 0=1;
end.
</code></pre>
            </div>
            <div class="post-text">
                <div class="diff-skipped"><div></div></div><pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,q,v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.U(v:Int16);begin if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.O:Int16;begin if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1);l:=l-1;end;procedure _.T(a,b:Int16);begin if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w]);end;var j:byte;begin h:=AllocMem(36);h.n:=h;h.x:=1;h.v:=-1;AssignFile(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do if q&lt;&gt;0then if(q=i)then q:=0 else U(i)else begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:=Random(4);case i-32of 4,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-b;73:Read(PChar(@A)^);end;case i-32of 0:;1:E;2,7:q:=i;3:T(-x,-y);4:begin l:=O;U(A);U(l)end;5:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26:begin U(A);U(A)end;28:T(-1,0);29:U(Ord(O=O));30:T(1,0);31:if(l=0)or(k[l]=#0)then E;32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-add">1</span>)else Insert(Char(A),s,l-2);59:if(d=nil)then d:=AllocMem(36);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;62:T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]));73:U(A);77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80:begin l:=O;c[1+O+80*l]:=Chr(A)end;82:for j:=0to l-1do s[j+1]:=k[l-j];86:T(0,1);88:T(1-2*(A and 1),1-(A and 2));91:begin l:=1;A:=O;U(A)end;92:T(-x,y);93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1);94:O;else Exit;end;end;until 0=1;end.
</code></pre><div class="diff-skipped"><div></div></div><pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.U(v:Int16); // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.O:Int16; // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  l:=l-1;
end;

procedure _.T(a,b:Int16); // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w]);
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)=36);
  // Initialize first thread :
  h:=AllocMem(36);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  AssignFile(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
    h.E;
    with h^ do
      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-<span class="diff-add">1</span>)else Insert(Char(A),s,l-<span class="diff-add">1</span>); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
      end;
  until 0=1;
end.
</code></pre>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-054d7084-63a2-4a07-955f-d9ecffdc6197">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('723c84cf-562f-40c2-b7e4-cc8de3535a26') ">
                        <span id="rev-arrow-723c84cf-562f-40c2-b7e4-cc8de3535a26" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('723c84cf-562f-40c2-b7e4-cc8de3535a26') ">
                        <span title="revision 1">1</span>
                    </td>
                    <td class="revcell3 vm">
                        <br>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/723c84cf-562f-40c2-b7e4-cc8de3535a26/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/1642/1" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info ">
    <div class="user-action-time">
        answered <span title="2011-03-15 21:39:24Z" class="relativetime">Mar 15 '11 at 21:39</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/907/patrickvl"><div><img src="https://www.gravatar.com/avatar/bc6453e15d0cd125744ba9a610ababe2?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/907/patrickvl">PatrickvL</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">541</span><span title="2 silver badges"><span class="badge2"></span><span class="badgecount">2</span></span><span title="6 bronze badges"><span class="badge3"></span><span class="badgecount">6</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev723c84cf-562f-40c2-b7e4-cc8de3535a26" class="revcell5" style="display: block">
<div class="diffs">
        <h1></h1>

        <div class="post-text">
            <h2>Delphi, 1855</h2>

<p>This version has thread-support (at quite a cost, alas) :</p>

<pre><code>type R=^_;_=record n:R;d:R;s:String;i,m,b,p,q,v,w,x,y,A,l:Int16;procedure U(v:Int16);function O:Int16;procedure T(a,b:Int16);procedure E;end;var f:TextFile;c,g,k:String;h:R;procedure _.U(v:Int16);begin if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)end;function _.O:Int16;begin if l=0then Exit(0);if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);if p&gt;0then Delete(g,l,1)else Delete(s,l,1);l:=l-1;end;procedure _.T(a,b:Int16);begin if(d&lt;&gt;nil)then begin d.n:=n;n:=d;d.v:=v;d.w:=w;d:=nil;n.T(a,b);Exit;end;x:=a;y:=b;end;procedure _.E;begin v:=(v+x+80)mod 80;w:=(w+y+25)mod 25;i:=Ord(c[1+v+80*w]);end;var j:byte;begin h:=AllocMem(36);h.n:=h;h.x:=1;h.v:=-1;AssignFile(f,ParamStr(1));Reset(f);for j:=1to 25do begin ReadLn(f,k);c:=c+k+StringOfChar(' ',80-Length(k))end;repeat h:=h.n;h.E;with h^ do if q&lt;&gt;0then if(q=i)then q:=0 else U(i)else begin k:=s;if p&gt;0then k:=g;l:=Length(k);A:=Random(4);case i-32of 4,5,8,9,12,13,26,32,71,80,93:A:=O;6:b:=1-b;73:Read(PChar(@A)^);end;case i-32of 0:;1:E;2,7:q:=i;3:T(-x,-y);4:begin l:=O;U(A);U(l)end;5:U(O mod A);6:if b=0then U(m)else m:=O;8:U(Ord(O&gt;A));9:U(Ord(O&lt;A));10:U(O*O);11:U(O+O);12:U(O div A);13:U(O-A);14:p:=1-p;15:T(-y,-x);16..25:U(i-48);26:begin U(A);U(A)end;28:T(-1,0);29:U(Ord(O=O));30:T(1,0);31:if(l=0)or(k[l]=#0)then E;32:if p&gt;0then Insert(Char(A),g,l-2)else Insert(Char(A),s,l-2);59:if(d=nil)then d:=AllocMem(36);60:T(y,x);61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;62:T(0,-1);63:T(x,-y);65..70:U(i-87);71:U(Ord(c[1+O+80*A]));73:U(A);77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;78:Write(O);79:Write(Chr(O));80:begin l:=O;c[1+O+80*l]:=Chr(A)end;82:for j:=0to l-1do s[j+1]:=k[l-j];86:T(0,1);88:T(1-2*(A and 1),1-(A and 2));91:begin l:=1;A:=O;U(A)end;92:T(-x,y);93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1);94:O;else Exit;end;end;until 0=1;end.
</code></pre>

<p>Note that this implementation contains a few ideas that will reduce my other submission by a few dozen characters (I'll apply them later).</p>

<p>This code runs the 'multithreaded hello, world' sample flawlessly, and most of the other samples. (My interpreter does give me an division by zero exception when running the 'e' sample - can anyone confirm this with another >&lt;> interpreter?)</p>

<p>Here the indented and commented code :</p>

<pre><code>{debug}uses Windows;{}
// Note : Lowercase identifiers are variables, Uppercase identifiers are types and functions.
type R=^_;_=record
  // n is the next thread (self if round robin)
  n:R;
  // d is an extra thread (will start running at next turn)
  d:R;
  // s is the thread-local stack (kept as a string)
  s:String;
  // i is the current instruction read from the program
  i,
  // m is the registry memory value (read/written by the '&amp;' instruction)
  m,
  // b indicates if the registry should be written (b=0) or read (b&gt;0) by the '&amp;' instruction
  b,
  // p is the stack selector (p=0 : Use thread local stack, p&gt;0 : Use global stack)
  p,
  // q is the string-parsing indicator (actually, it's the quote used, ' or ")
  q,
  // v,w are x,y positions into the program
  v,w,
  // x,y are steps in the respective direction (values -1,0 or 1) :
  x,y,
  // A is a temporary variable (only uppercase var, to coincide with comments)
  A,
  // l is the length of the stack (may be abused as a temporary)
  l
  :Int16;
  procedure U(v:Int16);
  function O:Int16;
  procedure T(a,b:Int16);
  procedure E;
end;

var
  // f is the source file
  f:TextFile;
  // c is the entire codebox (a 2-dimensional program)
  c,
  // g is the global stack
  g,
  // k is a temporary stack copy, needed for reversal
  k:String;
  // h is the current thread
  h:R;

procedure _.U(v:Int16); // PUSH
begin
  // Push value onto the stack:
  if p&gt;0then g:=g+Chr(v)else s:=s+Chr(v)
end;

function _.O:Int16; // POP
begin
  // Pop value from the stack :
  if l=0then Exit(0);
  if p&gt;0then O:=Ord(g[l])else O:=Ord(s[l]);
  if p&gt;0then Delete(g,l,1)else Delete(s,l,1);
  l:=l-1;
end;

procedure _.T(a,b:Int16); // TURN
begin
  // Split off a new thread when requested :
  if(d&lt;&gt;nil)then
  begin
    // Insert the new thread in the chain :
    d.n:=n;
    n:=d;
    // Split off the thread :
    d.v:=v;
    d.w:=w;
    d:=nil;
    n.T(a,b);
    Exit;
  end;

  // Turn in a new direction :
  x:=a;
  y:=b;
end;

procedure _.E; // STEP
begin
//{debug}Sleep(10);{}
  // Note : x-step needs to stay on same line, y-step needs to stay on same column
  v:=(v+x+80)mod 80;
  w:=(w+y+25)mod 25;
  i:=Ord(c[1+v+80*w]);
end;

var
  j:byte;
begin
  {debug}Assert(SizeOf(_)=36);
  // Initialize first thread :
  h:=AllocMem(36);
  h.n:=h;
  h.x:=1;
  h.v:=-1;
  // Open file given at the command-line, and read &amp; expand it's lines into our program buffer :
  AssignFile(f,ParamStr(1));
  Reset(f);
  for j:=1to 25do
  begin
    ReadLn(f,k);
    c:=c+k+StringOfChar(' ',80-Length(k))
    {debug};SetLength(c,j*80)
  end;
  // Cycle over all threads, executing one instruction per thread :
  repeat
    h:=h.n;
    h.E;
    with h^ do
      if q&lt;&gt;0then
        // String parsing mode, detect closing quote :
        if(q=i)then
          q:=0
        else
          U(i)
      else
      begin
        // Make a copy of the active stack, and determine it's length :
        k:=s;
        if p&gt;0then
          k:=g;
        l:=Length(k);
        // Shorten 'x' (case 88): Turn always randomizing direction into A (overwrites are okay) :
        A:=Random(4);
        // Prevent begin+end pair for instructions that need only 2 statements, by handling the 1st here :
        case i-32of // Note : The instruction is decreased by 32, resulting in less digits
          4,5,8,9,12,13,26,32,71,80,93:A:=O; // These instructions all Pop A
          6:b:=1-b;
          73:Read(PChar(@A)^);
        end;
        // All statements (1 statement, or 2nd statement, or begin+end pair with 2 or more statements) :
        case i-32of
          //' ': Ignore spaces
          0:;
          //'!': Skips the following instruction.
          1:E;
          //'"','''': Enables string parsing. String parsing pushes every character found to the stack until it finds a closing quote.
          2,7:q:=i;
          //'#': Mirror both axes
          3:T(-x,-y);
          //'$': Rotates the top 2 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,2,4,3)
          4:begin l:=O;U(A);U(l)end; // Note : A was Popped in 1st case block
          //'%': Pops A and B off the stack, and pushes B mod A.
          5:U(O mod A);
          //'&amp;': Pops the top value off the stack and puts it in the registry. Calling &amp; again will take the value in the registry and put it back on the stack.
          6:if b=0then U(m)else m:=O;
          //'(': Less than. Pops A and B off the stack, and pushes 1 if B &gt; A
          8:U(Ord(O&gt;A));
          //')': Greater than. Pops A and B off the stack, and pushes 1 if B &lt; A
          9:U(Ord(O&lt;A));
          //'*': Pops A and B off the stack, and pushes B * A.
          10:U(O*O); // Note : A and B are inverted, but order is irrelevant here
          //'+': Pops A and B off the stack, and pushes B + A.
          11:U(O+O); // Note : A and B are inverted, but order is irrelevant here
          //',': Pops A and B off the stack, and pushes B / A. Division by 0 raises an error.
          12:U(O div A);
          //'-': Pops A and B off the stack, and pushes B - A.
          13:U(O-A);
          //'.': Switch between thread-local and global stack
          14:p:=1-p;
          //'/': Mirror
          15:T(-y,-x);
          //'0'..'9': Push value 0-9 onto the stack.
          16..25:U(i-48);
          //':': Duplicates the top value on the stack.
          26:begin U(A);U(A)end; // Note : A was Popped in 1st case block
          //'&lt;': Turn west
          28:T(-1,0);
          //'=': Pops A and B off the stack, and pushes 1 if B = A, and 0 otherwise.
          29:U(Ord(O=O)); // Note : A and B are inverted, but order is irrelevant here
          //'&gt;': Turn east
          30:T(1,0);
          //'?': Skips the following instruction if top of stack is zero, or stack is empty. (note: this does not pop anything off the stack!)
          31:if(l=0)or(k[l]=#0)then E;
          //'@': Rotates the top 3 values on the stack clockwise, respectively. (eg. if your stack is 1,2,3,4, would result in 1,4,2,3)
          32:if p&gt;0then Insert(Char(A),g,l-2)else Insert(Char(A),s,l-2); // Note : A was Popped in 1st case block
          //'[': Creates a new thread at the next direction-changing instruction.
          59:if(d=nil)then d:=AllocMem(36);
          //'\': Mirror
          60:T(y,x);
          //']': Ends the current thread.
          61:begin if(h=n)then Exit;d:=n;while(d.n&lt;&gt;h)do d:=d.n;d.n:=h.n;d:=h;h:=n;FreeMem(d);end;
          //'^': Turn north
          62:T(0,-1);
          //'_': Mirror y
          63:T(x,-y);
          //'a'..'f': Push value 10-15 onto the stack.
          65..70:U(i-87);
          //'g': Pops A and B off the stack, and pushes the value at B,A in the codebox.
          71:U(Ord(c[1+O+80*A])); // Note : A was Popped in 1st case block
          //'i': Takes one character as user input and pushes it's ASCII value to the stack
          73:U(A); // Note : Read() into A was done in 1st case block
          //'m': Takes all data from the current stack and moves it to the end of the other stack.
          77:begin if p&gt;0then s:=s+g else g:=g+s;if p&gt;0then g:=''else s:=''end;
          //'n': Pops and outputs the value
          78:Write(O);
          //'o': Pops and outputs as a character
          79:Write(Chr(O));
          //'p': Pops A, B, and C off the stack, and changes the value at C,B to A.
          80:begin l:=O;c[1+O+80*l]:=Chr(A)end; // Note : A was Popped in 1st case block
          //'r': Reverses the stack.
          82:for j:=0to l-1do s[j+1]:=k[l-j]; // Note: This reads from the stack-copy
          //'v': Turn south
          86:T(0,1);
          //'x': Turn random direction
          88:T(1-2*(A and 1),1-(A and 2)); // Note: A is randomized before 1st case block
          //'{': Shifts the stack to the left / rotates entire stack counter-clockwise (e.g. 1,2,3,4 becomes 2,3,4,1)
          91:begin l:=1;A:=O;U(A)end; // Note: Here we use the fact that pop reads at 'l'
          //'|': Mirror x
          92:T(-x,y);
          //'}': Shifts the stack to the right / rotates entire stack clockwise (e.g. 1,2,3,4 becomes 4,1,2,3)
          93:if p&gt;0then Insert(Char(A),g,1)else Insert(Char(A),s,1); // Note : A was Popped in 1st case block
          //'~': Removes the top value from the stack.
          94:O;
        else // ';' (27) and unrecognized instructions end execution.
          Exit;
        end;
      end;
  until 0=1;
end.
</code></pre>

        </div>

        <div class="tags-diff">
            
        </div>
</div>                        </div>
                    </td>
                </tr>
                <tr id="spacer-723c84cf-562f-40c2-b7e4-cc8de3535a26">
                    <td colspan="4" height="10px"></td>
                </tr>

        </table>

            <div class="pager fl">
        





    </div>


    </div>
</div>

<script type="text/javascript">
    StackExchange.using("revisions", function () { StackExchange.revisions.init(1642) });
</script>

<div style="display:none" id="prettify-lang"></div>
        </div>
    </div>
    <div id="footer" class="categories">
        <div class="footerwrap">
            <div id="footer-menu">
                <div class="top-footer-links">
                        <a href="/about">about</a>
                    <a href="/help">help</a>
                        <a href="/help/badges">badges</a>
                    <a href="http://blog.stackexchange.com?blb=1">blog</a>
                        <a href="http://chat.stackexchange.com">chat</a>
                    <a href="http://data.stackexchange.com">data</a>
                    <a href="http://stackexchange.com/legal">legal</a>
                    <a href="http://stackexchange.com/legal/privacy-policy">privacy policy</a>
                    <a href="http://stackexchange.com/about/hiring">jobs</a>
                    <a href="http://stackexchange.com/about/contact">advertising info</a>

                    <a onclick='StackExchange.switchMobile("on", "/posts/1642/revisions")'>mobile</a>
                    <b><a href="/contact">contact us</a></b>
                        <b><a href="http://meta.codegolf.stackexchange.com">feedback</a></b>
                    
                </div>
                <div id="footer-sites">
                    <table>
    <tr>
            <th colspan=3>
                Technology
            </th>
            <th >
                Life / Arts
            </th>
            <th >
                Culture / Recreation
            </th>
            <th >
                Science
            </th>
            <th >
                Other
            </th>
    </tr>
    <tr>
            <td>
                <ol>
                        <li><a href="http://stackoverflow.com" title="professional and enthusiast programmers">Stack Overflow</a></li>
                        <li><a href="http://serverfault.com" title="professional system and network administrators">Server Fault</a></li>
                        <li><a href="http://superuser.com" title="computer enthusiasts and power users">Super User</a></li>
                        <li><a href="http://webapps.stackexchange.com" title="power users of web applications">Web Applications</a></li>
                        <li><a href="http://askubuntu.com" title="Ubuntu users and developers">Ask Ubuntu</a></li>
                        <li><a href="http://webmasters.stackexchange.com" title="pro webmasters">Webmasters</a></li>
                        <li><a href="http://gamedev.stackexchange.com" title="professional and independent game developers">Game Development</a></li>
                        <li><a href="http://tex.stackexchange.com" title="users of TeX, LaTeX, ConTeXt, and related typesetting systems">TeX - LaTeX</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://programmers.stackexchange.com" title="professional programmers interested in conceptual questions about software development">Programmers</a></li>
                        <li><a href="http://unix.stackexchange.com" title="users of Linux, FreeBSD and other Un*x-like operating systems.">Unix &amp; Linux</a></li>
                        <li><a href="http://apple.stackexchange.com" title="power users of Apple hardware and software">Ask Different (Apple)</a></li>
                        <li><a href="http://wordpress.stackexchange.com" title="WordPress developers and administrators">WordPress Answers</a></li>
                        <li><a href="http://gis.stackexchange.com" title="cartographers, geographers and GIS professionals">Geographic Information Systems</a></li>
                        <li><a href="http://electronics.stackexchange.com" title="electronics and electrical engineering professionals, students, and enthusiasts">Electrical Engineering</a></li>
                        <li><a href="http://android.stackexchange.com" title="enthusiasts and power users of the Android operating system">Android Enthusiasts</a></li>
                        <li><a href="http://security.stackexchange.com" title="Information security professionals">Information Security</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://dba.stackexchange.com" title="database professionals who wish to improve their database skills and learn from others in the community">Database Administrators</a></li>
                        <li><a href="http://drupal.stackexchange.com" title="Drupal developers and administrators">Drupal Answers</a></li>
                        <li><a href="http://sharepoint.stackexchange.com" title="SharePoint enthusiasts">SharePoint</a></li>
                        <li><a href="http://ux.stackexchange.com" title="user experience researchers and experts">User Experience</a></li>
                        <li><a href="http://mathematica.stackexchange.com" title="users of Mathematica">Mathematica</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#technology" class="more">
                                more (14)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://photo.stackexchange.com" title="professional, enthusiast and amateur photographers">Photography</a></li>
                        <li><a href="http://scifi.stackexchange.com" title="science fiction and fantasy enthusiasts">Science Fiction &amp; Fantasy</a></li>
                        <li><a href="http://cooking.stackexchange.com" title="professional and amateur chefs">Seasoned Advice (cooking)</a></li>
                        <li><a href="http://diy.stackexchange.com" title="contractors and serious DIYers">Home Improvement</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#lifearts" class="more">
                                more (13)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://english.stackexchange.com" title="linguists, etymologists, and serious English language enthusiasts">English Language &amp; Usage</a></li>
                        <li><a href="http://skeptics.stackexchange.com" title="scientific skepticism">Skeptics</a></li>
                        <li><a href="http://judaism.stackexchange.com" title="those who base their lives on Jewish law and tradition and anyone interested in learning more">Mi Yodeya (Judaism)</a></li>
                        <li><a href="http://travel.stackexchange.com" title="road warriors and seasoned travelers">Travel</a></li>
                        <li><a href="http://christianity.stackexchange.com" title="committed Christians, experts in Christianity and those interested in learning more">Christianity</a></li>
                        <li><a href="http://gaming.stackexchange.com" title="passionate videogamers on all platforms">Arqade (gaming)</a></li>
                        <li><a href="http://bicycles.stackexchange.com" title="people who build and repair bicycles, people who train cycling, or commute on bicycles">Bicycles</a></li>
                        <li><a href="http://rpg.stackexchange.com" title="gamemasters and players of tabletop, paper-and-pencil role-playing games">Role-playing Games</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#culturerecreation" class="more">
                                more (21)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://math.stackexchange.com" title="people studying math at any level and professionals in related fields">Mathematics</a></li>
                        <li><a href="http://stats.stackexchange.com" title="statisticians, data analysts, data miners and data visualization experts">Cross Validated (stats)</a></li>
                        <li><a href="http://cstheory.stackexchange.com" title="theoretical computer scientists and researchers in related fields">Theoretical Computer Science</a></li>
                        <li><a href="http://physics.stackexchange.com" title="active researchers, academics and students of physics">Physics</a></li>
                        <li><a href="http://mathoverflow.net" title="professional mathematicians">MathOverflow</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#science" class="more">
                                more (7)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://stackapps.com" title="apps, scripts, and development with the Stack Exchange API">Stack Apps</a></li>
                        <li><a href="http://meta.stackoverflow.com" title="meta-discussion of the Stack Exchange family of Q&amp;A websites">Meta Stack Overflow</a></li>
                        <li><a href="http://area51.stackexchange.com" title="proposing new sites in the Stack Exchange network">Area 51</a></li>
                        <li><a href="http://careers.stackoverflow.com">Stack Overflow Careers</a></li>
                    
                </ol>
            </td>
    </tr>
</table>
                </div>
            </div>

            <div id="copyright">
                site design / logo &#169; 2013 stack exchange inc; user contributions licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license">cc-wiki</a> 
 with <a href="http://blog.stackoverflow.com/2009/06/attribution-required/" rel="license">attribution required</a>
            </div>
            <div id="footer-flair">
                <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="cc-wiki-link"></a>
            </div>
            <div id="svnrev">
                rev 2013.11.26.1178
            </div>
            
        </div>
    </div>
    <noscript>
        <div id="noscript-warning">Programming Puzzles &amp; Code Golf Stack Exchange works best with JavaScript enabled<img src="http://pixel.quantserve.com/pixel/p-c1rF4kxgLUzNc.gif" alt="" class="dno"></div>
    </noscript>

    <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-5620270-24']);
        _gaq.push(['_setDomainName','.stackexchange.com']);
_gaq.push(['_trackPageview']);
    var _qevents = _qevents || [];
    var _comscore = _comscore || [];
    (function () {
        var ssl='https:'==document.location.protocol,
            s=document.getElementsByTagName('script')[0],
            ga=document.createElement('script');
        ga.type='text/javascript';
        ga.async=true;
        ga.src=(ssl?'https://ssl':'http://www')+'.google-analytics.com/ga.js';
        s.parentNode.insertBefore(ga,s);
        var sc=document.createElement('script');
        sc.type='text/javascript';
        sc.async=true;
        sc.src=(ssl?'https://secure':'http://edge')+'.quantserve.com/quant.js';
        s.parentNode.insertBefore(sc, s);
        
        var s = document.createElement("script"), el = document.getElementsByTagName("script")[0]; s.async = true;
        s.src = (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js";
        el.parentNode.insertBefore(s, el);
        
    })();
    _comscore.push({ c1: "2", c2: "17440561" });
    _qevents.push({ qacct: "p-c1rF4kxgLUzNc" });
    </script>            
</body>
</html>