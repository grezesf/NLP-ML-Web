<!DOCTYPE html>
<html>
<head>
    
    <title>Revisions - Programming Puzzles & Code Golf Stack Exchange</title>
    <link rel="shortcut icon" href="//cdn.sstatic.net/codegolf/img/favicon.ico">
    <link rel="apple-touch-icon image_src" href="//cdn.sstatic.net/codegolf/img/apple-touch-icon.png">
    <link rel="search" type="application/opensearchdescription+xml" title="Programming Puzzles &amp; Code Golf Stack Exchange" href="/opensearch.xml">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@StackCodeGolf" />
    <meta name="twitter:domain" content="codegolf.stackexchange.com"/>
    <meta name="og:type" content="website" />
    <meta name="og:image" content="http://cdn.sstatic.net/codegolf/img/apple-touch-icon.png?v=6f55f0b2476f"/>
    <meta name="og:title" content="Revisions" />
    <meta name="og:description" content="Q&amp;A for programming puzzle enthusiasts and code golfers" />
    <meta name="og:url" content="http://codegolf.stackexchange.com/posts/4985/revisions"/>

    
    
    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="//cdn.sstatic.net/Js/stub.en.js?v=e3d47b73fa12" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="//cdn.sstatic.net/codegolf/all.css?v=a1dd281cae8a">
    

    <script type="text/javascript">
        StackExchange.ready(function () {
            StackExchange.realtime.init('wss://qa.sockets.stackexchange.com,ws://qa.sockets.stackexchange.com');
            StackExchange.realtime.subscribeToInboxNotifications();
                    StackExchange.realtime.subscribeToReputationNotifications('200');
                        });
    </script>
    <script type="text/javascript">
        StackExchange.init({"locale":"en","stackAuthUrl":"https://stackauth.com","serverTime":1385444822,"styleCode":true,"enableUserHovercards":true,"site":{"name":"Programming Puzzles & Code Golf Stack Exchange","description":"Q&A for programming puzzle enthusiasts and code golfers","isNoticesTabEnabled":true,"recaptchaPublicKey":"6LdsB7sSAAAAAAzjgEF_Hd8vXv-C42sa_KyofaGR","enableSocialMediaInSharePopup":true},"user":{"fkey":"f51c005c36aeb04be7163e16a81b52d5","isAnonymous":true}});
        StackExchange.using.setCacheBreakers({"js/prettify-full.en.js":"e0bbd4760e83","js/moderator.en.js":"1a411fd265fe","js/full-anon.en.js":"8a881a0975af","js/full.en.js":"e87912181c10","js/wmd.en.js":"bd9234d44a40","js/third-party/jquery.autocomplete.min.js":"e5f01e97f7c3","js/third-party/jquery.autocomplete.min.en.js":"","js/mobile.en.js":"d1d834ef85d2","js/help.en.js":"d3cc74d8a93a","js/tageditor.en.js":"6d51a5f8d7f3","js/tageditornew.en.js":"111b781cf314","js/inline-tag-editing.en.js":"f951bd09dc69","js/revisions.en.js":"33fd38144303","js/review.en.js":"f45b4ec094ea","js/tagsuggestions.en.js":"e4e7b952fcc7","js/post-validation.en.js":"c275fe37d674","js/explore-qlist.en.js":"73825bd006fc","js/events.en.js":"53bc48767091"});
        StackExchange.using("gps", function() {
             StackExchange.gps.init(true);
        });
        
    </script>
    
        <script type="text/javascript">
            StackExchange.ready(function () {
                $('#nav-tour').click(function () {
                    StackExchange.using("gps", function() {
                        StackExchange.gps.track("aboutpage.click", { aboutclick_location: "headermain" }, true);
                    });
                });
            });
        </script>
</head>
<body class="revision-page">
    <noscript><div id="noscript-padding"></div></noscript>
    <div id="notify-container"></div>
    <div id="overlay-header"></div>
    <div id="custom-header"></div>
    <div class="container">
        <div id="header" class=headeranon>
            <div id="portalLink">
                <a class="genu" href="http://stackexchange.com" onclick="StackExchange.ready(function(){genuwine.click();});return false;">Stack Exchange</a>
            </div>
            <div id="topbar">
                <div id="hlinks">
                    
<span id="hlinks-user"></span>
<span id="hlinks-nav">                        <a href="/users/login?returnurl=%2fposts%2f4985%2frevisions">sign up</a>

 <span class="lsep">|</span>
                    <a href="/users/login?returnurl=%2fposts%2f4985%2frevisions">log in</a>

 <span class="lsep">|</span>
</span>
<span id="hlinks-custom"></span>
                </div>
                <div id="hsearch">
                    <form id="search" action="/search" method="get" autocomplete="off">
                        <div>
                            <input autocomplete="off" name="q" class="textbox" placeholder="search" tabindex="1" type="text" maxlength="240" size="28" value="">
                        </div>
                    </form>
                </div>
            </div>
            <br class="cbt">
            <div id="hlogo">
                <a href="/">
                    Programming Puzzles &amp; Code Golf
                        <span class="beta-title">beta</span>
                </a>
            </div>
            <div id="hmenus">
                <div class="nav mainnavs mainnavsanon">
                    <ul>
                            <li><a id="nav-questions" href="/questions">Questions</a></li>
                            <li><a id="nav-tags" href="/tags">Tags</a></li>
                            <li><a id="nav-tour" href="/about">Tour</a></li>
                            <li><a id="nav-users" href="/users">Users</a></li>
                    </ul>
                </div>
                <div class="nav askquestion">
                    <ul>
                        <li>
                            <a id="nav-askquestion"  href="/questions/ask">Ask Question</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        



        <div id="content">
            


<div id="mainbar-full">

    <div class="subheader">
        <h1><a href="/questions/4732/emulate-an-intel-8086-cpu/4985#4985" class="answer-hyperlink ">Return to Answer</a></h1>
    </div>

    <div id="revisions">
        <table>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('d587eb70-c0bc-4d55-915a-4a8f18910f4f') ">
                        <span id="rev-arrow-d587eb70-c0bc-4d55-915a-4a8f18910f4f" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('d587eb70-c0bc-4d55-915a-4a8f18910f4f') ">
                        <span title="revision 2">2</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">shorten the code</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/d587eb70-c0bc-4d55-915a-4a8f18910f4f/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/4985/2" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-02-27 23:11:41Z" class="relativetime">Feb 27 '12 at 23:11</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/199/j-b"><div><img src="https://www.gravatar.com/avatar/1eda356bddd3b93818cb1310a7bc952f?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/199/j-b">J B</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">6,327</span><span title="7 silver badges"><span class="badge2"></span><span class="badgecount">7</span></span><span title="38 bronze badges"><span class="badge3"></span><span class="badgecount">38</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="revd587eb70-c0bc-4d55-915a-4a8f18910f4f" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <h1>Haskell,<span class="diff-delete"> 256</span><span class="diff-add"> </span><s><span class="diff-add">256</span></s> <span class="diff-add">234</span> lines<span class="diff-delete"> ;-)</span></h1><div class="diff-skipped"><div></div></div><p><em>What's in:</em> barely enough of the 8086 instruction set to run the example binary flawlessly.  <strong>Self-modifying code is supported.</strong> (prefetch: zero bytes)<span class="diff-delete">  Ironically</span><br><span class="diff-add">
Ironically</span>, the first sufficient iterations of the code were longer and supported less of the opcode span<span class="diff-delete">, but refactoring was</span><span class="diff-add">.  Refactoring ended up</span> beneficial<span class="diff-delete"> to</span> both<span class="diff-add"> to</span> code length and<span class="diff-add"> to</span> opcode coverage.</p><p><em>What's out:</em> obviously, segments, prefixes and multibyte opcodes, interrupts, I/O ports, string operations, and FP.  I initially did follow the original<span class="diff-delete"> PUSH SP behavior</span><span class="diff-add"> </span><code><span class="diff-add">PUSH SP</span></code> <span class="diff-add">behavior</span>, but had to drop it after a few<span class="diff-delete"> refactorings</span><span class="diff-add"> iterations</span>.</p><p> Carry flag results are probably very messed up in a few cases of<span class="diff-delete"> ADC</span><span class="diff-add"> </span><code><span class="diff-add">ADC</span></code>/<span class="diff-delete">SBB</span><code><span class="diff-add">SBB</span></code>.</p><div class="diff-skipped"><div></div></div><pre><code>{-# LANGUAGE FlexibleContexts #-}

import Prelude hiding (read)
import Data.Char (chr,isPrint)
import Data.Word (Word8,Word16)
import Data.Int (Int8)
import Data.Bits
import Data.IORef
import Data.Array ((!))
import Data.Array.IO
import Control.Monad.Reader
import Control.Exception (bracket_)
import System
import System.IO (hSetEncoding,stdin,latin1)

ifte t <span class="diff-delete">_ True = t
ifte _ </span>f<span class="diff-delete"> False = f

type Place = (IOArray Word16 Word8,Word16)

[regAl,regAh,regCl,regCh,regDl,regDh,regBl,regBh] = [0..7]
[regAx,regCx,regDx,regBx,regSp,regBp,regSi,regDi] = [0,2..14]

decodeReg8  n = fromIntegral $ (n `shiftL` 1) .|. (n `shiftR` 2)
readDecodedReg8 = readReg .</span> <span class="diff-delete">decodeReg8
decodeReg16 n</span><span class="diff-add">c</span> =<span class="diff-delete"> fromIntegral</span> <span class="diff-delete">$  n `shiftL`</span><span class="diff-add">if</span> <span class="diff-delete">1
readDecodedReg16</span><span class="diff-add">c</span> <span class="diff-delete">=</span><span class="diff-add">then</span> <span class="diff-delete">readReg</span><span class="diff-add">t</span> <span class="diff-delete">.</span><span class="diff-add">else</span> <span class="diff-delete">decodeReg16</span><span class="diff-add">f</span>

concatBytes :: Word8 -&gt; Word8 -&gt; Word16
concatBytes l h = (fromIntegral l) .|. (fromIntegral h `shiftL` 8)

byteToWordSE :: Word8 -&gt; Word16
byteToWordSE = (fromIntegral :: Int8 -&gt; Word16) .
               (fromIntegral :: Word8 -&gt; Int8)

wordToByteL,wordToByteH :: Word16 -&gt; Word8
wordToByteL = fromIntegral
wordToByteH = fromIntegral . (`shiftR` 8)

byte = undefined :: Word8
word = undefined :: Word16

<span class="diff-delete">class Bits a =&gt; Width a where
  read :: MonadIO m =&gt; Place -&gt; m a
  write :: MonadIO m =&gt;</span><span class="diff-add">type</span> Place<span class="diff-delete"> -&gt; a -&gt; m ()

readReg reg</span> =<span class="diff-delete"> ask &gt;&gt;=</span> <span class="diff-delete">\p -&gt; read </span>(<span class="diff-delete">regs p,reg)
readRam addr = ask &gt;&gt;= \p -&gt; read</span><span class="diff-add">IOArray</span> <span class="diff-delete">(ram</span><span class="diff-add">Word16</span> <span class="diff-delete">p</span><span class="diff-add">Word8</span>,<span class="diff-delete">addr</span><span class="diff-add">Word16</span>)
<span class="diff-delete">writeReg reg val = ask &gt;&gt;= \p -&gt; write (regs p</span><span class="diff-add">[regAl</span>,<span class="diff-delete">reg) val
writeRam addr val = ask &gt;&gt;= \p -&gt; write (ram p</span><span class="diff-add">regAh</span>,<span class="diff-delete">addr) val

instance Width Word8 where
  read</span><span class="diff-add">regCl,regCh,regDl,regDh,regBl,regBh]</span> =<span class="diff-delete"> liftIO</span> <span class="diff-add">[0</span>.<span class="diff-delete"> uncurry readArray
  write p = liftIO </span>.<span class="diff-delete"> uncurry writeArray p

instance Width Word16 where</span><span class="diff-add">7]</span>
<span class="diff-delete">  read (p</span><span class="diff-add">[regAx</span>,<span class="diff-delete">a) = liftM2 concatBytes (read (p</span><span class="diff-add">regCx</span>,<span class="diff-delete">a)) (read (p</span><span class="diff-add">regDx</span>,<span class="diff-delete">a+1))
  write (p</span><span class="diff-add">regBx</span>,<span class="diff-delete">a) val = do
    write (p</span><span class="diff-add">regSp</span>,<span class="diff-delete">a)   $ wordToByteL val
    write (p</span><span class="diff-add">regBp</span>,<span class="diff-delete">a+1) $</span><span class="diff-add">regSi,regDi]</span> <span class="diff-delete">wordToByteH</span><span class="diff-add">=</span> <span class="diff-delete">val</span><span class="diff-add">[0,2..14]</span>

data Proc = Proc {
    ram :: IOArray Word16 Word8
  , regs :: IOArray Word16 Word8
  , ip :: IORef Word16
  , cf :: IORef Bool
  , zf :: IORef Bool
  , sf :: IORef Bool
}

readProc <span class="diff-add"> </span>ext<span class="diff-add">  </span> = liftIO .<span class="diff-add">   </span> <span class="diff-add">  </span>readIORef<span class="diff-add">   </span> . ext =&lt;&lt; ask
writeProc ext f = liftIO . flip writeIORef f . ext =&lt;&lt; ask

modifyIP f = do
  ipRef &lt;- liftM ip ask
  old &lt;- liftIO $ readIORef ipRef
  liftIO $ modifyIORef ipRef f
  return old

<span class="diff-add">readInstr8 = modifyIP (+1) &gt;&gt;= readRam
readInstr16 = liftM2 concatBytes readInstr8 readInstr8

class (Ord a,Bits a) =&gt; Width a where
  read :: MonadIO m =&gt; Place -&gt; m a
  write :: MonadIO m =&gt; Place -&gt; a -&gt; m ()

instance Width Word8 where
  read = liftIO . uncurry readArray
  write p = liftIO . uncurry writeArray p

instance Width Word16 where
  read (p,a) = liftM2 concatBytes (read (p,a)) (read (p,a+1))
  write (p,a) val = do
    write (p,a)   $ wordToByteL val
    write (p,a+1) $ wordToByteH val

readReg reg  = ask &gt;&gt;= \p -&gt; read (regs p,reg)
readRam addr = ask &gt;&gt;= \p -&gt; read (ram p,addr)
writeReg reg val  = ask &gt;&gt;= \p -&gt; write (regs p,reg) val
writeRam addr val = ask &gt;&gt;= \p -&gt; write (ram p,addr) val

decodeReg8  n = fromIntegral $ (n `shiftL` 1) .|. (n `shiftR` 2)
decodeReg16 n = fromIntegral $  n `shiftL` 1
readDecodedReg8 = readReg . decodeReg8
readDecodedReg16 = readReg . decodeReg16

</span>readModRM = do
  modRM &lt;- readInstr8
  let mod   =  modRM           `shiftR` 6
      opReg = (modRM .&amp;. 0x38) `shiftR` 3
      rm    =  modRM .&amp;. 0x07
  proc &lt;- ask
  operand &lt;- case mod of
               0 -&gt; do
                 addr &lt;- case rm of
                           1 -&gt; liftM2 (+) (readReg regBx) (readReg regDi)
                           2 -&gt; liftM2 (+) (readReg regBp) (readReg regSi)
                           6 -&gt; readInstr16
                           7 -&gt; readReg regBx
                 return (ram proc,addr)
               2 -&gt; do
                 addr &lt;- case rm of
                           5 -&gt; liftM2 (+) (readReg regDi) readInstr16
                           7 -&gt; liftM2 (+) (readReg regBx) readInstr16
                 return (ram proc,addr)
               3 -&gt; return (regs proc,2*fromIntegral rm)
  return (operand,opReg,opReg)

<span class="diff-delete">readInstr8 = modifyIP (+1) &gt;&gt;= readRam
readInstr16 = liftM2 concatBytes readInstr8 readInstr8

push16 :: (MonadIO m,MonadReader Proc m) =&gt; Word16 -&gt; m ()
</span>push16 val = do -- PUSH by value (doesn't reproduce PUSH SP behavior)
  sp &lt;- liftM (subtract 2) (readReg regSp)
  writeReg regSp sp
  writeRam sp <span class="diff-add">(</span>val<span class="diff-add"> :: Word16)</span>
pop16 = do
  sp &lt;- readReg regSp
  val &lt;- readRam sp
  writeReg regSp (sp+2)
  return val

jump cond = when cond . void . modifyIP . (+) . byteToWordSE =&lt;&lt; readInstr8

<span class="diff-delete">opAdd a b = return (Just $ a &gt;= negate b, a  +  b)
opOr  a b = return (Just False,           a .|. b)
opAdc a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &gt;= negate (b + c), a+b+c)
opXor a b = return (Just False,         a `xor` b)
opAnd a b = return (Just False,           a .&amp;. b)
opSub a b = return (Just $ a &lt;= b,        a  -  b)
opSbb a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &lt; b + c, a-b-c)
opInc a _ = return (Nothing,              a  +  1)
opDec a _ = return (Nothing,              a  -  1)

</span>alu :: (Width w,MonadIO m,MonadReader Proc m) =&gt; w -&gt; m w -&gt; m w -&gt;<span class="diff-delete"> Maybe</span> Place -&gt; (w -&gt; w -&gt; m (<span class="diff-add">Bool,</span>Maybe Bool,w)) -&gt; m ()
alu <span class="diff-delete">w</span><span class="diff-add">_</span> a b <span class="diff-delete">o</span><span class="diff-add">r</span> op = do
  (<span class="diff-add">rw,</span>c,v) &lt;- join (liftM2 op a b)<span class="diff-add">
  when rw $ write r v</span>
  maybe (return ()) (<span class="diff-delete">flip write</span><span class="diff-add">writeProc</span> <span class="diff-delete">v</span><span class="diff-add">cf</span>) <span class="diff-delete">o</span><span class="diff-add">c</span>
  writeProc zf (v == 0)
  writeProc sf (testBit v (bitSize v - 1))
<span class="diff-add">decodeALU</span> <span class="diff-add">0</span> <span class="diff-delete">maybe</span><span class="diff-add">=</span> (<span class="diff-add">\a b -&gt; </span>return (<span class="diff-delete">))</span><span class="diff-add">True, Just</span> (<span class="diff-delete">writeProc</span><span class="diff-add">a</span> <span class="diff-delete">cf</span><span class="diff-add">&gt;= negate b</span>)<span class="diff-add">,</span> <span class="diff-delete">c

decodeALU</span> <span class="diff-delete">0</span> <span class="diff-delete">o</span> <span class="diff-delete">=</span> <span class="diff-delete">(Just</span> <span class="diff-delete">o,</span> <span class="diff-delete">opAdd</span><span class="diff-add">a   +   b</span>)<span class="diff-add">)</span>
decodeALU 1 <span class="diff-delete">o </span>= (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-delete">o</span><span class="diff-add">False</span>, <span class="diff-delete">opOr</span><span class="diff-add">                a  .|.  b)</span>)
decodeALU 2 <span class="diff-delete">o </span>= (<span class="diff-add">\a b -&gt; liftM (ifte 1 0) (readProc cf) &gt;&gt;= \c -&gt;
                       return (True, </span>Just <span class="diff-delete">o</span><span class="diff-add">(a &gt;= negate (b + c))</span>, <span class="diff-delete">opAdc</span><span class="diff-add">a + b + c</span>)<span class="diff-add">)</span>
decodeALU 3<span class="diff-delete"> o</span> = (<span class="diff-add">\a b -&gt; liftM (ifte 1 0) (readProc cf) &gt;&gt;= \c -&gt;
                       return (True, </span>Just <span class="diff-delete">o</span><span class="diff-add">(a &lt; b + c)</span>, <span class="diff-delete">opSbb</span><span class="diff-add">          a - b - c)</span>)
decodeALU 4<span class="diff-delete"> o</span> = (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-delete">o</span><span class="diff-add">False</span>, <span class="diff-delete">opAnd</span><span class="diff-add">                a  .&amp;.  b</span>)<span class="diff-add">)</span>
decodeALU 5<span class="diff-delete"> o</span> =<span class="diff-add"> (\a</span> <span class="diff-add">b -&gt; return </span>(<span class="diff-add">True, </span>Just <span class="diff-delete">o</span><span class="diff-add">(a &lt;= b)</span>, <span class="diff-delete">opSub</span><span class="diff-add">             a   -   b)</span>)
decodeALU 6<span class="diff-delete"> o</span> = (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-delete">o</span><span class="diff-add">False</span>, <span class="diff-delete">opXor</span><span class="diff-add">                a `xor` b</span>)<span class="diff-add">)</span>
decodeALU 7 <span class="diff-delete">_</span><span class="diff-add">= (\a b -&gt; return (False,Just (a &lt;= b),          </span> <span class="diff-add">   a   -   b))
opIncDec    </span>= <span class="diff-add"> \a b -&gt; return </span>(<span class="diff-add">True, </span>Nothing, <span class="diff-delete">opSub</span><span class="diff-add">                   a   +   b</span>)

processInstr = do
  opcode &lt;- readInstr8
  regs &lt;- liftM regs ask
  let zReg = <span class="diff-add">(regs,</span>decodeReg16 (opcode .&amp;. 0x07<span class="diff-add">)</span>)
  <span class="diff-add">if</span> <span class="diff-add">opcode</span> <span class="diff-add">&lt;</span> <span class="diff-add">0x40</span> <span class="diff-delete">zRegPlace</span><span class="diff-add">then</span> <span class="diff-delete">=</span><span class="diff-add">--</span> <span class="diff-delete">(regs,zReg)
</span><span class="diff-add">no segment</span> <span class="diff-add">or</span> <span class="diff-add">BCD
</span>    <span class="diff-add">let </span>aluOp = (opcode .&amp;. 0x38) `shiftR` 3<span class="diff-delete">
 </span> <span class="diff-delete">if opcode &lt; 0x40 then do
   </span><span class="diff-add">in</span> case opcode .&amp;. 0x07 of
<span class="diff-delete">  </span>    0 -&gt; do
      <span class="diff-delete">  </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>      <span class="diff-delete"> uncurry (</span>alu byte (read operand) (readDecodedReg8 reg)<span class="diff-delete">)
 </span> <span class="diff-delete">             </span><span class="diff-add">operand</span> (decodeALU aluOp<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>    <span class="diff-delete"> </span>1 -&gt; do
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>      <span class="diff-delete">uncurry (</span>alu word (read operand) (readDecodedReg16 reg<span class="diff-delete">)</span>)<span class="diff-delete">
  </span> <span class="diff-delete">            </span><span class="diff-add">operand</span> (decodeALU aluOp<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>    <span class="diff-delete"> </span>4 -&gt;<span class="diff-delete"> do
        uncurry</span> <span class="diff-delete">(</span>alu byte (readReg regAl) readInstr8<span class="diff-delete">)
           </span> <span class="diff-delete">    (decodeALU aluOp </span>(regs,regAl)<span class="diff-add"> (decodeALU aluOp</span>)
  else case opcode .&amp;. 0xF8 of<span class="diff-add"> -- 16-bit (mostly) reg ops</span>
    0x40 -&gt; alu word (<span class="diff-delete">readReg</span><span class="diff-add">read</span> zReg) (return <span class="diff-delete">undefined)</span> <span class="diff-delete">(Just</span> <span class="diff-delete">zRegPlace</span><span class="diff-add">1 </span>) <span class="diff-delete">opInc</span><span class="diff-add">zReg opIncDec -- 16b INC</span>
    0x48 -&gt; alu word (<span class="diff-delete">readReg</span><span class="diff-add">read</span> zReg) (return <span class="diff-delete">undefined</span><span class="diff-add">(-1)</span>) <span class="diff-delete">(Just</span><span class="diff-add">zReg</span> <span class="diff-delete">zRegPlace)</span><span class="diff-add">opIncDec</span> <span class="diff-delete">opDec</span><span class="diff-add">-- 16b DEC</span>
    0x50 -&gt; <span class="diff-delete">readReg</span><span class="diff-add">read</span> zReg &gt;&gt;= push16                       <span class="diff-delete">--</span> <span class="diff-delete">16</span>-<span class="diff-delete">bit</span><span class="diff-add">-</span> <span class="diff-delete">reg</span><span class="diff-add">16b</span> PUSH<span class="diff-add"> reg</span>
    0x58 -&gt; pop16 &gt;&gt;= <span class="diff-delete">writeReg</span><span class="diff-add">write</span> zReg                       <span class="diff-delete">--</span> <span class="diff-delete">16</span>-<span class="diff-delete">bit</span><span class="diff-add">-</span> <span class="diff-delete">reg</span><span class="diff-add">16b</span> POP<span class="diff-add"> reg</span>
    0x90 -&gt; do<span class="diff-delete"> </span>                                          <span class="diff-delete"> </span>-- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> XCHG (or NOP)
      v1 &lt;- <span class="diff-delete">readReg</span><span class="diff-add">read</span> zReg
      v2 &lt;- readReg regAx
      <span class="diff-delete">writeReg</span><span class="diff-add">write</span> zReg (v2 :: Word16)
      writeReg regAx (v1 :: Word16)
    0xB0 -&gt; readInstr8  &gt;&gt;= <span class="diff-delete">writeReg</span><span class="diff-add">write</span> zReg<span class="diff-delete">   </span> <span class="diff-delete">    </span><span class="diff-add">--</span> <span class="diff-add">(BUG!)</span>        -- <span class="diff-delete"> 8-bit</span><span class="diff-add">8b</span> MOV reg,imm
    0xB8 -&gt; readInstr16 &gt;&gt;= <span class="diff-delete">writeReg</span><span class="diff-add">write</span> zReg                 <span class="diff-add"> </span>-- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> MOV reg,imm
    _ -&gt;<span class="diff-delete"> do
   </span> <span class="diff-delete">  </span>case if opcode == 0x80 then 0x82 else opcode of
<span class="diff-delete">  </span>      0x72 -&gt; jump       =&lt;&lt; (readProc cf)              -- JB/JNAE/JC
      <span class="diff-delete">  </span>0x74 -&gt; jump       =&lt;&lt; (readProc zf)              -- JE/JZ
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x75 -&gt; jump . not =&lt;&lt; (readProc zf)              -- JNE/JNZ
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x76 -&gt; jump       =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JBE
<span class="diff-delete">  </span>      0x77 -&gt; jump . not =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JA
<span class="diff-delete">  </span>      0x79 -&gt; jump . not =&lt;&lt; (readProc sf)              -- JNS
      <span class="diff-delete">  </span>0x81 -&gt; do                                        -- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> arith<span class="diff-delete">
&nbsp;</span> <span class="diff-add">to</span> <span class="diff-add">imm
</span>        (operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>       <span class="diff-delete"> uncurry</span> <span class="diff-delete">(</span>alu word (read operand) readInstr16<span class="diff-delete">)</span><span class="diff-add"> operand</span> (decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x82 -&gt; do                                        -- <span class="diff-delete">8-bit</span><span class="diff-add">8b</span> arith<span class="diff-delete">
&nbsp;</span> <span class="diff-add">to</span> <span class="diff-add">imm
</span>        (operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>        <span class="diff-delete">uncurry (</span>alu byte (read operand) readInstr8<span class="diff-delete">)</span> <span class="diff-add">operand </span>(decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete">  </span>      0x83 -&gt; do                                        -- <span class="diff-delete">16</span><span class="diff-add">16b arith</span> to 8s <span class="diff-delete">arith</span><span class="diff-add">imm</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,_,op) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> uncurry (</span>alu word (read operand) (liftM byteToWordSE readInstr8)<span class="diff-delete">)
   </span> <span class="diff-delete">  </span><span class="diff-add">operand
</span>            (decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x86 -&gt; do                                        -- <span class="diff-delete">8-bit</span><span class="diff-add">8b</span> XCHG reg,<span class="diff-delete">modRM</span><span class="diff-add">RM</span>
        <span class="diff-delete">  </span>(operand,reg,_)<span class="diff-add"> </span>&lt;- readModRM
<span class="diff-delete">  </span>        v1 &lt;- readDecodedReg8 reg
        <span class="diff-delete">  </span>v2 &lt;- read operand
<span class="diff-delete">  </span>        writeReg (decodeReg8 reg) (v2 :: Word8)
        <span class="diff-delete">  </span>write operand v1
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x88 -&gt; do                                        -- <span class="diff-delete">8-bit</span><span class="diff-add">8b</span> MOV <span class="diff-delete">modRM</span><span class="diff-add">RM</span>,reg
<span class="diff-delete">  </span>        (operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>        readDecodedReg8 reg &gt;&gt;= write operand
      <span class="diff-delete">  </span>0x89 -&gt; do                                        -- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> MOV <span class="diff-delete">modRM</span><span class="diff-add">RM</span>,reg
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>        readDecodedReg16 reg &gt;&gt;= write operand
<span class="diff-delete">  </span>      0x8A -&gt; do                                        -- <span class="diff-delete">8-bit</span><span class="diff-add">8b</span> MOV reg,<span class="diff-delete">modRM</span><span class="diff-add">RM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>val &lt;- read operand 
<span class="diff-delete">  </span>        writeReg (decodeReg8 reg) (val :: Word8)
<span class="diff-delete">  </span>      0x8B -&gt; do                                        -- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> MOV reg,<span class="diff-delete">modRM</span><span class="diff-add">RM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>val &lt;- read operand 
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>writeReg (decodeReg16 reg) (val :: Word16)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xC3 -&gt; pop16 &gt;&gt;= writeProc ip                    -- RET
<span class="diff-delete">  </span>      0xC7 -&gt; do<span class="diff-add">                                  </span> <span class="diff-add">     </span>-- <span class="diff-delete">16-bit</span><span class="diff-add">16b</span> MOV <span class="diff-delete">modRM</span><span class="diff-add">RM</span>,imm
<span class="diff-delete">  </span>        (operand,_,_) &lt;- readModRM
<span class="diff-delete">  </span>        readInstr16 &gt;&gt;= write operand
      <span class="diff-delete">  </span>0xE8 -&gt; readInstr16 &gt;&gt;= modifyIP . (+) &gt;&gt;= push16 -- CALL relative
<span class="diff-delete">  </span>      0xEB -&gt; jump True                                 -- JMP short
      <span class="diff-delete">  </span>0xF4 -&gt; liftIO (exitWith ExitSuccess)             -- HLT
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xF9 -&gt; writeProc cf True                         -- STC
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xFE -&gt; do                                        -- 8-bit INC/DEC <span class="diff-delete">modRM</span><span class="diff-add">RM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>        alu byte (read operand) (return <span class="diff-delete">undefined)</span><span class="diff-add">$</span> <span class="diff-delete">(Just</span><span class="diff-add">1-2*op)</span> operand<span class="diff-delete">)</span>
<span class="diff-delete"> </span>            <span class="diff-delete">  </span>(<span class="diff-delete">if</span><span class="diff-add">\a</span> <span class="diff-delete">op</span><span class="diff-add">b</span> <span class="diff-delete">==</span><span class="diff-add">-&gt;</span> <span class="diff-delete">0</span><span class="diff-add">return</span> <span class="diff-delete">then</span><span class="diff-add">(True,Nothing,a+b))</span> <span class="diff-delete">opInc</span><span class="diff-add">--</span> <span class="diff-delete">else</span><span class="diff-add">kinda</span> <span class="diff-delete">opDec)</span><span class="diff-add">duplicate :(</span>

main = do
  ramRef &lt;- newArray (0,0xFFFF) 0 :: IO (IOArray Word16 Word8)
  hSetEncoding stdin latin1
  mapM_ (uncurry (writeArray ramRef)) .
    zip [0..] .
    map (fromIntegral . fromEnum) =&lt;&lt;
    getContents
  regFile &lt;- newArray (0,15) 0 :: IO (IOArray Word16 Word8)
  ip &lt;- newIORef 0
  cf &lt;- newIORef False
  zf &lt;- newIORef False
  sf &lt;- newIORef False
  let proc = Proc ramRef regFile ip cf zf sf
  runReaderT (writeReg regSp (0x100 :: Word16)) proc

  bracket_ (return ()) 
           (dumpScreen ramRef) 
           (forever . flip runReaderT proc $ processInstr)

dumpScreen ramRef = do
  mem &lt;- freeze ramRef
  forM_ [0..25] $ \i -&gt; do
    forM_ [0..79] $ \j -&gt; do
      let c = chr . fromIntegral $ mem ! (0x8000 + 80*i + j)
      putChar (if isPrint c then c else ' ')
    putChar '\n'
</code></pre><div class="diff-skipped"><div></div></div><p><span class="diff-add"> Update 1: got it down to 234 lines.  Better organized the code by functionality, re-aligned what could be, tried to stick to 80 columns.  And refactored the ALU multiple times.</span></p>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <h1>Haskell,<span class="diff-delete"> 256</span> lines<span class="diff-delete"> ;-)</span></h1><div class="diff-skipped"><div></div></div><p><em>What's in:</em> barely enough of the 8086 instruction set to run the example binary flawlessly.  <strong>Self-modifying code is supported.</strong> (prefetch: zero bytes)<span class="diff-delete">  Ironically</span>, the first sufficient iterations of the code were longer and supported less of the opcode span<span class="diff-delete">, but refactoring was</span> beneficial<span class="diff-delete"> to</span> both code length and opcode coverage.</p><p><em>What's out:</em> obviously, segments, prefixes and multibyte opcodes, interrupts, I/O ports, string operations, and FP.  I initially did follow the original<span class="diff-delete"> PUSH SP behavior</span>, but had to drop it after a few<span class="diff-delete"> refactorings</span>.</p><p> Carry flag results are probably very messed up in a few cases of<span class="diff-delete"> ADC</span>/<span class="diff-delete">SBB</span>.</p><div class="diff-skipped"><div></div></div><pre><code>{-# LANGUAGE FlexibleContexts #-}

import Prelude hiding (read)
import Data.Char (chr,isPrint)
import Data.Word (Word8,Word16)
import Data.Int (Int8)
import Data.Bits
import Data.IORef
import Data.Array ((!))
import Data.Array.IO
import Control.Monad.Reader
import Control.Exception (bracket_)
import System
import System.IO (hSetEncoding,stdin,latin1)

ifte t <span class="diff-delete">_ True = t
ifte _ </span>f<span class="diff-delete"> False = f

type Place = (IOArray Word16 Word8,Word16)

[regAl,regAh,regCl,regCh,regDl,regDh,regBl,regBh] = [0..7]
[regAx,regCx,regDx,regBx,regSp,regBp,regSi,regDi] = [0,2..14]

decodeReg8  n = fromIntegral $ (n `shiftL` 1) .|. (n `shiftR` 2)
readDecodedReg8 = readReg .</span> <span class="diff-delete">decodeReg8
decodeReg16 n</span> =<span class="diff-delete"> fromIntegral</span> <span class="diff-delete">$  n `shiftL`</span> <span class="diff-delete">1
readDecodedReg16</span> <span class="diff-delete">=</span> <span class="diff-delete">readReg</span> <span class="diff-delete">.</span> <span class="diff-delete">decodeReg16</span>

concatBytes :: Word8 -&gt; Word8 -&gt; Word16
concatBytes l h = (fromIntegral l) .|. (fromIntegral h `shiftL` 8)

byteToWordSE :: Word8 -&gt; Word16
byteToWordSE = (fromIntegral :: Int8 -&gt; Word16) .
               (fromIntegral :: Word8 -&gt; Int8)

wordToByteL,wordToByteH :: Word16 -&gt; Word8
wordToByteL = fromIntegral
wordToByteH = fromIntegral . (`shiftR` 8)

byte = undefined :: Word8
word = undefined :: Word16

<span class="diff-delete">class Bits a =&gt; Width a where
  read :: MonadIO m =&gt; Place -&gt; m a
  write :: MonadIO m =&gt;</span> Place<span class="diff-delete"> -&gt; a -&gt; m ()

readReg reg</span> =<span class="diff-delete"> ask &gt;&gt;=</span> <span class="diff-delete">\p -&gt; read </span>(<span class="diff-delete">regs p,reg)
readRam addr = ask &gt;&gt;= \p -&gt; read</span> <span class="diff-delete">(ram</span> <span class="diff-delete">p</span>,<span class="diff-delete">addr</span>)
<span class="diff-delete">writeReg reg val = ask &gt;&gt;= \p -&gt; write (regs p</span>,<span class="diff-delete">reg) val
writeRam addr val = ask &gt;&gt;= \p -&gt; write (ram p</span>,<span class="diff-delete">addr) val

instance Width Word8 where
  read</span> =<span class="diff-delete"> liftIO</span> .<span class="diff-delete"> uncurry readArray
  write p = liftIO </span>.<span class="diff-delete"> uncurry writeArray p

instance Width Word16 where</span>
<span class="diff-delete">  read (p</span>,<span class="diff-delete">a) = liftM2 concatBytes (read (p</span>,<span class="diff-delete">a)) (read (p</span>,<span class="diff-delete">a+1))
  write (p</span>,<span class="diff-delete">a) val = do
    write (p</span>,<span class="diff-delete">a)   $ wordToByteL val
    write (p</span>,<span class="diff-delete">a+1) $</span> <span class="diff-delete">wordToByteH</span> <span class="diff-delete">val</span>

data Proc = Proc {
    ram :: IOArray Word16 Word8
  , regs :: IOArray Word16 Word8
  , ip :: IORef Word16
  , cf :: IORef Bool
  , zf :: IORef Bool
  , sf :: IORef Bool
}

readProc ext = liftIO . readIORef . ext =&lt;&lt; ask
writeProc ext f = liftIO . flip writeIORef f . ext =&lt;&lt; ask

modifyIP f = do
  ipRef &lt;- liftM ip ask
  old &lt;- liftIO $ readIORef ipRef
  liftIO $ modifyIORef ipRef f
  return old

readModRM = do
  modRM &lt;- readInstr8
  let mod   =  modRM           `shiftR` 6
      opReg = (modRM .&amp;. 0x38) `shiftR` 3
      rm    =  modRM .&amp;. 0x07
  proc &lt;- ask
  operand &lt;- case mod of
               0 -&gt; do
                 addr &lt;- case rm of
                           1 -&gt; liftM2 (+) (readReg regBx) (readReg regDi)
                           2 -&gt; liftM2 (+) (readReg regBp) (readReg regSi)
                           6 -&gt; readInstr16
                           7 -&gt; readReg regBx
                 return (ram proc,addr)
               2 -&gt; do
                 addr &lt;- case rm of
                           5 -&gt; liftM2 (+) (readReg regDi) readInstr16
                           7 -&gt; liftM2 (+) (readReg regBx) readInstr16
                 return (ram proc,addr)
               3 -&gt; return (regs proc,2*fromIntegral rm)
  return (operand,opReg,opReg)

<span class="diff-delete">readInstr8 = modifyIP (+1) &gt;&gt;= readRam
readInstr16 = liftM2 concatBytes readInstr8 readInstr8

push16 :: (MonadIO m,MonadReader Proc m) =&gt; Word16 -&gt; m ()
</span>push16 val = do -- PUSH by value (doesn't reproduce PUSH SP behavior)
  sp &lt;- liftM (subtract 2) (readReg regSp)
  writeReg regSp sp
  writeRam sp val
pop16 = do
  sp &lt;- readReg regSp
  val &lt;- readRam sp
  writeReg regSp (sp+2)
  return val

jump cond = when cond . void . modifyIP . (+) . byteToWordSE =&lt;&lt; readInstr8

<span class="diff-delete">opAdd a b = return (Just $ a &gt;= negate b, a  +  b)
opOr  a b = return (Just False,           a .|. b)
opAdc a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &gt;= negate (b + c), a+b+c)
opXor a b = return (Just False,         a `xor` b)
opAnd a b = return (Just False,           a .&amp;. b)
opSub a b = return (Just $ a &lt;= b,        a  -  b)
opSbb a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &lt; b + c, a-b-c)
opInc a _ = return (Nothing,              a  +  1)
opDec a _ = return (Nothing,              a  -  1)

</span>alu :: (Width w,MonadIO m,MonadReader Proc m) =&gt; w -&gt; m w -&gt; m w -&gt;<span class="diff-delete"> Maybe</span> Place -&gt; (w -&gt; w -&gt; m (Maybe Bool,w)) -&gt; m ()
alu <span class="diff-delete">w</span> a b <span class="diff-delete">o</span> op = do
  (c,v) &lt;- join (liftM2 op a b)
  maybe (return ()) (<span class="diff-delete">flip write</span> <span class="diff-delete">v</span>) <span class="diff-delete">o</span>
  writeProc zf (v == 0)
  writeProc sf (testBit v (bitSize v - 1))
  <span class="diff-delete">maybe</span> (return (<span class="diff-delete">))</span> (<span class="diff-delete">writeProc</span> <span class="diff-delete">cf</span>) <span class="diff-delete">c

decodeALU</span> <span class="diff-delete">0</span> <span class="diff-delete">o</span> <span class="diff-delete">=</span> <span class="diff-delete">(Just</span> <span class="diff-delete">o,</span> <span class="diff-delete">opAdd</span>)
decodeALU 1 <span class="diff-delete">o </span>= (Just <span class="diff-delete">o</span>, <span class="diff-delete">opOr</span>)
decodeALU 2 <span class="diff-delete">o </span>= (Just <span class="diff-delete">o</span>, <span class="diff-delete">opAdc</span>)
decodeALU 3<span class="diff-delete"> o</span> = (Just <span class="diff-delete">o</span>, <span class="diff-delete">opSbb</span>)
decodeALU 4<span class="diff-delete"> o</span> = (Just <span class="diff-delete">o</span>, <span class="diff-delete">opAnd</span>)
decodeALU 5<span class="diff-delete"> o</span> = (Just <span class="diff-delete">o</span>, <span class="diff-delete">opSub</span>)
decodeALU 6<span class="diff-delete"> o</span> = (Just <span class="diff-delete">o</span>, <span class="diff-delete">opXor</span>)
decodeALU 7 <span class="diff-delete">_</span> = (Nothing, <span class="diff-delete">opSub</span>)

processInstr = do
  opcode &lt;- readInstr8
  regs &lt;- liftM regs ask
  let zReg = decodeReg16 (opcode .&amp;. 0x07)
      <span class="diff-delete">zRegPlace</span> <span class="diff-delete">=</span> <span class="diff-delete">(regs,zReg)
</span>      aluOp = (opcode .&amp;. 0x38) `shiftR` 3<span class="diff-delete">
 </span> <span class="diff-delete">if opcode &lt; 0x40 then do
   </span> case opcode .&amp;. 0x07 of
<span class="diff-delete">  </span>    0 -&gt; do
      <span class="diff-delete">  </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>      <span class="diff-delete"> uncurry (</span>alu byte (read operand) (readDecodedReg8 reg)<span class="diff-delete">)
 </span> <span class="diff-delete">             </span> (decodeALU aluOp<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>    <span class="diff-delete"> </span>1 -&gt; do
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>      <span class="diff-delete">uncurry (</span>alu word (read operand) (readDecodedReg16 reg<span class="diff-delete">)</span>)<span class="diff-delete">
  </span> <span class="diff-delete">            </span> (decodeALU aluOp<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>    <span class="diff-delete"> </span>4 -&gt;<span class="diff-delete"> do
        uncurry</span> <span class="diff-delete">(</span>alu byte (readReg regAl) readInstr8<span class="diff-delete">)
           </span> <span class="diff-delete">    (decodeALU aluOp </span>(regs,regAl))
  else case opcode .&amp;. 0xF8 of
    0x40 -&gt; alu word (<span class="diff-delete">readReg</span> zReg) (return <span class="diff-delete">undefined)</span> <span class="diff-delete">(Just</span> <span class="diff-delete">zRegPlace</span>) <span class="diff-delete">opInc</span>
    0x48 -&gt; alu word (<span class="diff-delete">readReg</span> zReg) (return <span class="diff-delete">undefined</span>) <span class="diff-delete">(Just</span> <span class="diff-delete">zRegPlace)</span> <span class="diff-delete">opDec</span>
    0x50 -&gt; <span class="diff-delete">readReg</span> zReg &gt;&gt;= push16                       <span class="diff-delete">--</span> <span class="diff-delete">16</span>-<span class="diff-delete">bit</span> <span class="diff-delete">reg</span> PUSH
    0x58 -&gt; pop16 &gt;&gt;= <span class="diff-delete">writeReg</span> zReg                       <span class="diff-delete">--</span> <span class="diff-delete">16</span>-<span class="diff-delete">bit</span> <span class="diff-delete">reg</span> POP
    0x90 -&gt; do<span class="diff-delete"> </span>                                          <span class="diff-delete"> </span>-- <span class="diff-delete">16-bit</span> XCHG (or NOP)
      v1 &lt;- <span class="diff-delete">readReg</span> zReg
      v2 &lt;- readReg regAx
      <span class="diff-delete">writeReg</span> zReg (v2 :: Word16)
      writeReg regAx (v1 :: Word16)
    0xB0 -&gt; readInstr8  &gt;&gt;= <span class="diff-delete">writeReg</span> zReg<span class="diff-delete">   </span> <span class="diff-delete">    </span>         -- <span class="diff-delete"> 8-bit</span> MOV reg,imm
    0xB8 -&gt; readInstr16 &gt;&gt;= <span class="diff-delete">writeReg</span> zReg                 -- <span class="diff-delete">16-bit</span> MOV reg,imm
    _ -&gt;<span class="diff-delete"> do
   </span> <span class="diff-delete">  </span>case if opcode == 0x80 then 0x82 else opcode of
<span class="diff-delete">  </span>      0x72 -&gt; jump       =&lt;&lt; (readProc cf)              -- JB/JNAE/JC
      <span class="diff-delete">  </span>0x74 -&gt; jump       =&lt;&lt; (readProc zf)              -- JE/JZ
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x75 -&gt; jump . not =&lt;&lt; (readProc zf)              -- JNE/JNZ
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x76 -&gt; jump       =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JBE
<span class="diff-delete">  </span>      0x77 -&gt; jump . not =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JA
<span class="diff-delete">  </span>      0x79 -&gt; jump . not =&lt;&lt; (readProc sf)              -- JNS
      <span class="diff-delete">  </span>0x81 -&gt; do                                        -- <span class="diff-delete">16-bit</span> arith<span class="diff-delete">
&nbsp;</span>          (operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>       <span class="diff-delete"> uncurry</span> <span class="diff-delete">(</span>alu word (read operand) readInstr16<span class="diff-delete">)</span> (decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x82 -&gt; do                                        -- <span class="diff-delete">8-bit</span> arith<span class="diff-delete">
&nbsp;</span>          (operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>        <span class="diff-delete">uncurry (</span>alu byte (read operand) readInstr8<span class="diff-delete">)</span> (decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete">  </span>      0x83 -&gt; do                                        -- <span class="diff-delete">16</span> to 8s <span class="diff-delete">arith</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,_,op) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> uncurry (</span>alu word (read operand) (liftM byteToWordSE readInstr8)<span class="diff-delete">)
   </span> <span class="diff-delete">  </span>            (decodeALU op<span class="diff-delete"> operand</span>)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x86 -&gt; do                                        -- <span class="diff-delete">8-bit</span> XCHG reg,<span class="diff-delete">modRM</span>
        <span class="diff-delete">  </span>(operand,reg,_)&lt;- readModRM
<span class="diff-delete">  </span>        v1 &lt;- readDecodedReg8 reg
        <span class="diff-delete">  </span>v2 &lt;- read operand
<span class="diff-delete">  </span>        writeReg (decodeReg8 reg) (v2 :: Word8)
        <span class="diff-delete">  </span>write operand v1
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0x88 -&gt; do                                        -- <span class="diff-delete">8-bit</span> MOV <span class="diff-delete">modRM</span>,reg
<span class="diff-delete">  </span>        (operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>        readDecodedReg8 reg &gt;&gt;= write operand
      <span class="diff-delete">  </span>0x89 -&gt; do                                        -- <span class="diff-delete">16-bit</span> MOV <span class="diff-delete">modRM</span>,reg
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete">  </span>        readDecodedReg16 reg &gt;&gt;= write operand
<span class="diff-delete">  </span>      0x8A -&gt; do                                        -- <span class="diff-delete">8-bit</span> MOV reg,<span class="diff-delete">modRM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>val &lt;- read operand 
<span class="diff-delete">  </span>        writeReg (decodeReg8 reg) (val :: Word8)
<span class="diff-delete">  </span>      0x8B -&gt; do                                        -- <span class="diff-delete">16-bit</span> MOV reg,<span class="diff-delete">modRM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,reg,_) &lt;- readModRM
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>val &lt;- read operand 
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>writeReg (decodeReg16 reg) (val :: Word16)
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xC3 -&gt; pop16 &gt;&gt;= writeProc ip                    -- RET
<span class="diff-delete">  </span>      0xC7 -&gt; do -- <span class="diff-delete">16-bit</span> MOV <span class="diff-delete">modRM</span>,imm
<span class="diff-delete">  </span>        (operand,_,_) &lt;- readModRM
<span class="diff-delete">  </span>        readInstr16 &gt;&gt;= write operand
      <span class="diff-delete">  </span>0xE8 -&gt; readInstr16 &gt;&gt;= modifyIP . (+) &gt;&gt;= push16 -- CALL relative
<span class="diff-delete">  </span>      0xEB -&gt; jump True                                 -- JMP short
      <span class="diff-delete">  </span>0xF4 -&gt; liftIO (exitWith ExitSuccess)             -- HLT
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xF9 -&gt; writeProc cf True                         -- STC
<span class="diff-delete"> </span>      <span class="diff-delete"> </span>0xFE -&gt; do                                        -- 8-bit INC/DEC <span class="diff-delete">modRM</span>
<span class="diff-delete"> </span>        <span class="diff-delete"> </span>(operand,_,op) &lt;- readModRM
<span class="diff-delete">  </span>        alu byte (read operand) (return <span class="diff-delete">undefined)</span> <span class="diff-delete">(Just</span> operand<span class="diff-delete">)</span>
<span class="diff-delete"> </span>            <span class="diff-delete">  </span>(<span class="diff-delete">if</span> <span class="diff-delete">op</span> <span class="diff-delete">==</span> <span class="diff-delete">0</span> <span class="diff-delete">then</span> <span class="diff-delete">opInc</span> <span class="diff-delete">else</span> <span class="diff-delete">opDec)</span>

main = do
  ramRef &lt;- newArray (0,0xFFFF) 0 :: IO (IOArray Word16 Word8)
  hSetEncoding stdin latin1
  mapM_ (uncurry (writeArray ramRef)) .
    zip [0..] .
    map (fromIntegral . fromEnum) =&lt;&lt;
    getContents
  regFile &lt;- newArray (0,15) 0 :: IO (IOArray Word16 Word8)
  ip &lt;- newIORef 0
  cf &lt;- newIORef False
  zf &lt;- newIORef False
  sf &lt;- newIORef False
  let proc = Proc ramRef regFile ip cf zf sf
  runReaderT (writeReg regSp (0x100 :: Word16)) proc

  bracket_ (return ()) 
           (dumpScreen ramRef) 
           (forever . flip runReaderT proc $ processInstr)

dumpScreen ramRef = do
  mem &lt;- freeze ramRef
  forM_ [0..25] $ \i -&gt; do
    forM_ [0..79] $ \j -&gt; do
      let c = chr . fromIntegral $ mem ! (0x8000 + 80*i + j)
      putChar (if isPrint c then c else ' ')
    putChar '\n'
</code></pre><div class="diff-skipped"><div></div></div>
            </div>
            <div class="post-text">
                <h1>Haskell,<span class="diff-add"> </span><s><span class="diff-add">256</span></s> <span class="diff-add">234</span> lines</h1><div class="diff-skipped"><div></div></div><p><em>What's in:</em> barely enough of the 8086 instruction set to run the example binary flawlessly.  <strong>Self-modifying code is supported.</strong> (prefetch: zero bytes)<br><span class="diff-add">
Ironically</span>, the first sufficient iterations of the code were longer and supported less of the opcode span<span class="diff-add">.  Refactoring ended up</span> beneficial both<span class="diff-add"> to</span> code length and<span class="diff-add"> to</span> opcode coverage.</p><p><em>What's out:</em> obviously, segments, prefixes and multibyte opcodes, interrupts, I/O ports, string operations, and FP.  I initially did follow the original<span class="diff-add"> </span><code><span class="diff-add">PUSH SP</span></code> <span class="diff-add">behavior</span>, but had to drop it after a few<span class="diff-add"> iterations</span>.</p><p> Carry flag results are probably very messed up in a few cases of<span class="diff-add"> </span><code><span class="diff-add">ADC</span></code>/<code><span class="diff-add">SBB</span></code>.</p><div class="diff-skipped"><div></div></div><pre><code>{-# LANGUAGE FlexibleContexts #-}

import Prelude hiding (read)
import Data.Char (chr,isPrint)
import Data.Word (Word8,Word16)
import Data.Int (Int8)
import Data.Bits
import Data.IORef
import Data.Array ((!))
import Data.Array.IO
import Control.Monad.Reader
import Control.Exception (bracket_)
import System
import System.IO (hSetEncoding,stdin,latin1)

ifte t f <span class="diff-add">c</span> = <span class="diff-add">if</span> <span class="diff-add">c</span> <span class="diff-add">then</span> <span class="diff-add">t</span> <span class="diff-add">else</span> <span class="diff-add">f</span>

concatBytes :: Word8 -&gt; Word8 -&gt; Word16
concatBytes l h = (fromIntegral l) .|. (fromIntegral h `shiftL` 8)

byteToWordSE :: Word8 -&gt; Word16
byteToWordSE = (fromIntegral :: Int8 -&gt; Word16) .
               (fromIntegral :: Word8 -&gt; Int8)

wordToByteL,wordToByteH :: Word16 -&gt; Word8
wordToByteL = fromIntegral
wordToByteH = fromIntegral . (`shiftR` 8)

byte = undefined :: Word8
word = undefined :: Word16

<span class="diff-add">type</span> Place = (<span class="diff-add">IOArray</span> <span class="diff-add">Word16</span> <span class="diff-add">Word8</span>,<span class="diff-add">Word16</span>)
<span class="diff-add">[regAl</span>,<span class="diff-add">regAh</span>,<span class="diff-add">regCl,regCh,regDl,regDh,regBl,regBh]</span> = <span class="diff-add">[0</span>..<span class="diff-add">7]</span>
<span class="diff-add">[regAx</span>,<span class="diff-add">regCx</span>,<span class="diff-add">regDx</span>,<span class="diff-add">regBx</span>,<span class="diff-add">regSp</span>,<span class="diff-add">regBp</span>,<span class="diff-add">regSi,regDi]</span> <span class="diff-add">=</span> <span class="diff-add">[0,2..14]</span>

data Proc = Proc {
    ram :: IOArray Word16 Word8
  , regs :: IOArray Word16 Word8
  , ip :: IORef Word16
  , cf :: IORef Bool
  , zf :: IORef Bool
  , sf :: IORef Bool
}

readProc <span class="diff-add"> </span>ext<span class="diff-add">  </span> = liftIO .<span class="diff-add">   </span> <span class="diff-add">  </span>readIORef<span class="diff-add">   </span> . ext =&lt;&lt; ask
writeProc ext f = liftIO . flip writeIORef f . ext =&lt;&lt; ask

modifyIP f = do
  ipRef &lt;- liftM ip ask
  old &lt;- liftIO $ readIORef ipRef
  liftIO $ modifyIORef ipRef f
  return old

<span class="diff-add">readInstr8 = modifyIP (+1) &gt;&gt;= readRam
readInstr16 = liftM2 concatBytes readInstr8 readInstr8

class (Ord a,Bits a) =&gt; Width a where
  read :: MonadIO m =&gt; Place -&gt; m a
  write :: MonadIO m =&gt; Place -&gt; a -&gt; m ()

instance Width Word8 where
  read = liftIO . uncurry readArray
  write p = liftIO . uncurry writeArray p

instance Width Word16 where
  read (p,a) = liftM2 concatBytes (read (p,a)) (read (p,a+1))
  write (p,a) val = do
    write (p,a)   $ wordToByteL val
    write (p,a+1) $ wordToByteH val

readReg reg  = ask &gt;&gt;= \p -&gt; read (regs p,reg)
readRam addr = ask &gt;&gt;= \p -&gt; read (ram p,addr)
writeReg reg val  = ask &gt;&gt;= \p -&gt; write (regs p,reg) val
writeRam addr val = ask &gt;&gt;= \p -&gt; write (ram p,addr) val

decodeReg8  n = fromIntegral $ (n `shiftL` 1) .|. (n `shiftR` 2)
decodeReg16 n = fromIntegral $  n `shiftL` 1
readDecodedReg8 = readReg . decodeReg8
readDecodedReg16 = readReg . decodeReg16

</span>readModRM = do
  modRM &lt;- readInstr8
  let mod   =  modRM           `shiftR` 6
      opReg = (modRM .&amp;. 0x38) `shiftR` 3
      rm    =  modRM .&amp;. 0x07
  proc &lt;- ask
  operand &lt;- case mod of
               0 -&gt; do
                 addr &lt;- case rm of
                           1 -&gt; liftM2 (+) (readReg regBx) (readReg regDi)
                           2 -&gt; liftM2 (+) (readReg regBp) (readReg regSi)
                           6 -&gt; readInstr16
                           7 -&gt; readReg regBx
                 return (ram proc,addr)
               2 -&gt; do
                 addr &lt;- case rm of
                           5 -&gt; liftM2 (+) (readReg regDi) readInstr16
                           7 -&gt; liftM2 (+) (readReg regBx) readInstr16
                 return (ram proc,addr)
               3 -&gt; return (regs proc,2*fromIntegral rm)
  return (operand,opReg,opReg)

push16 val = do -- PUSH by value (doesn't reproduce PUSH SP behavior)
  sp &lt;- liftM (subtract 2) (readReg regSp)
  writeReg regSp sp
  writeRam sp <span class="diff-add">(</span>val<span class="diff-add"> :: Word16)</span>
pop16 = do
  sp &lt;- readReg regSp
  val &lt;- readRam sp
  writeReg regSp (sp+2)
  return val

jump cond = when cond . void . modifyIP . (+) . byteToWordSE =&lt;&lt; readInstr8

alu :: (Width w,MonadIO m,MonadReader Proc m) =&gt; w -&gt; m w -&gt; m w -&gt; Place -&gt; (w -&gt; w -&gt; m (<span class="diff-add">Bool,</span>Maybe Bool,w)) -&gt; m ()
alu <span class="diff-add">_</span> a b <span class="diff-add">r</span> op = do
  (<span class="diff-add">rw,</span>c,v) &lt;- join (liftM2 op a b)<span class="diff-add">
  when rw $ write r v</span>
  maybe (return ()) (<span class="diff-add">writeProc</span> <span class="diff-add">cf</span>) <span class="diff-add">c</span>
  writeProc zf (v == 0)
  writeProc sf (testBit v (bitSize v - 1))
<span class="diff-add">decodeALU</span> <span class="diff-add">0</span> <span class="diff-add">=</span> (<span class="diff-add">\a b -&gt; </span>return (<span class="diff-add">True, Just</span> (<span class="diff-add">a</span> <span class="diff-add">&gt;= negate b</span>)<span class="diff-add">,</span>       <span class="diff-add">a   +   b</span>)<span class="diff-add">)</span>
decodeALU 1 = (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-add">False</span>, <span class="diff-add">                a  .|.  b)</span>)
decodeALU 2 = (<span class="diff-add">\a b -&gt; liftM (ifte 1 0) (readProc cf) &gt;&gt;= \c -&gt;
                       return (True, </span>Just <span class="diff-add">(a &gt;= negate (b + c))</span>, <span class="diff-add">a + b + c</span>)<span class="diff-add">)</span>
decodeALU 3 = (<span class="diff-add">\a b -&gt; liftM (ifte 1 0) (readProc cf) &gt;&gt;= \c -&gt;
                       return (True, </span>Just <span class="diff-add">(a &lt; b + c)</span>, <span class="diff-add">          a - b - c)</span>)
decodeALU 4 = (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-add">False</span>, <span class="diff-add">                a  .&amp;.  b</span>)<span class="diff-add">)</span>
decodeALU 5 =<span class="diff-add"> (\a</span> <span class="diff-add">b -&gt; return </span>(<span class="diff-add">True, </span>Just <span class="diff-add">(a &lt;= b)</span>, <span class="diff-add">             a   -   b)</span>)
decodeALU 6 = (<span class="diff-add">\a b -&gt; return (True, </span>Just <span class="diff-add">False</span>, <span class="diff-add">                a `xor` b</span>)<span class="diff-add">)</span>
decodeALU 7 <span class="diff-add">= (\a b -&gt; return (False,Just (a &lt;= b),          </span> <span class="diff-add">   a   -   b))
opIncDec    </span>= <span class="diff-add"> \a b -&gt; return </span>(<span class="diff-add">True, </span>Nothing, <span class="diff-add">                   a   +   b</span>)

processInstr = do
  opcode &lt;- readInstr8
  regs &lt;- liftM regs ask
  let zReg = <span class="diff-add">(regs,</span>decodeReg16 (opcode .&amp;. 0x07<span class="diff-add">)</span>)
  <span class="diff-add">if</span> <span class="diff-add">opcode</span> <span class="diff-add">&lt;</span> <span class="diff-add">0x40</span> <span class="diff-add">then</span> <span class="diff-add">--</span> <span class="diff-add">no segment</span> <span class="diff-add">or</span> <span class="diff-add">BCD
</span>    <span class="diff-add">let </span>aluOp = (opcode .&amp;. 0x38) `shiftR` 3 <span class="diff-add">in</span> case opcode .&amp;. 0x07 of
    0 -&gt; do
      (operand,reg,_) &lt;- readModRM
      alu byte (read operand) (readDecodedReg8 reg) <span class="diff-add">operand</span> (decodeALU aluOp)
    1 -&gt; do
      (operand,reg,_) &lt;- readModRM
      alu word (read operand) (readDecodedReg16 reg) <span class="diff-add">operand</span> (decodeALU aluOp)
    4 -&gt; alu byte (readReg regAl) readInstr8 (regs,regAl)<span class="diff-add"> (decodeALU aluOp</span>)
  else case opcode .&amp;. 0xF8 of<span class="diff-add"> -- 16-bit (mostly) reg ops</span>
    0x40 -&gt; alu word (<span class="diff-add">read</span> zReg) (return   <span class="diff-add">1 </span>) <span class="diff-add">zReg opIncDec -- 16b INC</span>
    0x48 -&gt; alu word (<span class="diff-add">read</span> zReg) (return <span class="diff-add">(-1)</span>) <span class="diff-add">zReg</span> <span class="diff-add">opIncDec</span> <span class="diff-add">-- 16b DEC</span>
    0x50 -&gt; <span class="diff-add">read</span> zReg &gt;&gt;= push16                        -<span class="diff-add">-</span> <span class="diff-add">16b</span> PUSH<span class="diff-add"> reg</span>
    0x58 -&gt; pop16 &gt;&gt;= <span class="diff-add">write</span> zReg                        -<span class="diff-add">-</span> <span class="diff-add">16b</span> POP<span class="diff-add"> reg</span>
    0x90 -&gt; do                                          -- <span class="diff-add">16b</span> XCHG (or NOP)
      v1 &lt;- <span class="diff-add">read</span> zReg
      v2 &lt;- readReg regAx
      <span class="diff-add">write</span> zReg (v2 :: Word16)
      writeReg regAx (v1 :: Word16)
    0xB0 -&gt; readInstr8  &gt;&gt;= <span class="diff-add">write</span> zReg <span class="diff-add">--</span> <span class="diff-add">(BUG!)</span>        -- <span class="diff-add">8b</span> MOV reg,imm
    0xB8 -&gt; readInstr16 &gt;&gt;= <span class="diff-add">write</span> zReg                 <span class="diff-add"> </span>-- <span class="diff-add">16b</span> MOV reg,imm
    _ -&gt; case if opcode == 0x80 then 0x82 else opcode of
      0x72 -&gt; jump       =&lt;&lt; (readProc cf)              -- JB/JNAE/JC
      0x74 -&gt; jump       =&lt;&lt; (readProc zf)              -- JE/JZ
      0x75 -&gt; jump . not =&lt;&lt; (readProc zf)              -- JNE/JNZ
      0x76 -&gt; jump       =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JBE
      0x77 -&gt; jump . not =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JA
      0x79 -&gt; jump . not =&lt;&lt; (readProc sf)              -- JNS
      0x81 -&gt; do                                        -- <span class="diff-add">16b</span> arith <span class="diff-add">to</span> <span class="diff-add">imm
</span>        (operand,_,op) &lt;- readModRM
        alu word (read operand) readInstr16<span class="diff-add"> operand</span> (decodeALU op)
      0x82 -&gt; do                                        -- <span class="diff-add">8b</span> arith <span class="diff-add">to</span> <span class="diff-add">imm
</span>        (operand,_,op) &lt;- readModRM
        alu byte (read operand) readInstr8 <span class="diff-add">operand </span>(decodeALU op)
      0x83 -&gt; do                                        -- <span class="diff-add">16b arith</span> to 8s <span class="diff-add">imm</span>
        (operand,_,op) &lt;- readModRM
        alu word (read operand) (liftM byteToWordSE readInstr8) <span class="diff-add">operand
</span>            (decodeALU op)
      0x86 -&gt; do                                        -- <span class="diff-add">8b</span> XCHG reg,<span class="diff-add">RM</span>
        (operand,reg,_)<span class="diff-add"> </span>&lt;- readModRM
        v1 &lt;- readDecodedReg8 reg
        v2 &lt;- read operand
        writeReg (decodeReg8 reg) (v2 :: Word8)
        write operand v1
      0x88 -&gt; do                                        -- <span class="diff-add">8b</span> MOV <span class="diff-add">RM</span>,reg
        (operand,reg,_) &lt;- readModRM
        readDecodedReg8 reg &gt;&gt;= write operand
      0x89 -&gt; do                                        -- <span class="diff-add">16b</span> MOV <span class="diff-add">RM</span>,reg
        (operand,reg,_) &lt;- readModRM
        readDecodedReg16 reg &gt;&gt;= write operand
      0x8A -&gt; do                                        -- <span class="diff-add">8b</span> MOV reg,<span class="diff-add">RM</span>
        (operand,reg,_) &lt;- readModRM
        val &lt;- read operand 
        writeReg (decodeReg8 reg) (val :: Word8)
      0x8B -&gt; do                                        -- <span class="diff-add">16b</span> MOV reg,<span class="diff-add">RM</span>
        (operand,reg,_) &lt;- readModRM
        val &lt;- read operand 
        writeReg (decodeReg16 reg) (val :: Word16)
      0xC3 -&gt; pop16 &gt;&gt;= writeProc ip                    -- RET
      0xC7 -&gt; do<span class="diff-add">                                  </span> <span class="diff-add">     </span>-- <span class="diff-add">16b</span> MOV <span class="diff-add">RM</span>,imm
        (operand,_,_) &lt;- readModRM
        readInstr16 &gt;&gt;= write operand
      0xE8 -&gt; readInstr16 &gt;&gt;= modifyIP . (+) &gt;&gt;= push16 -- CALL relative
      0xEB -&gt; jump True                                 -- JMP short
      0xF4 -&gt; liftIO (exitWith ExitSuccess)             -- HLT
      0xF9 -&gt; writeProc cf True                         -- STC
      0xFE -&gt; do                                        -- 8-bit INC/DEC <span class="diff-add">RM</span>
        (operand,_,op) &lt;- readModRM
        alu byte (read operand) (return <span class="diff-add">$</span> <span class="diff-add">1-2*op)</span> operand
            (<span class="diff-add">\a</span> <span class="diff-add">b</span> <span class="diff-add">-&gt;</span> <span class="diff-add">return</span> <span class="diff-add">(True,Nothing,a+b))</span> <span class="diff-add">--</span> <span class="diff-add">kinda</span> <span class="diff-add">duplicate :(</span>

main = do
  ramRef &lt;- newArray (0,0xFFFF) 0 :: IO (IOArray Word16 Word8)
  hSetEncoding stdin latin1
  mapM_ (uncurry (writeArray ramRef)) .
    zip [0..] .
    map (fromIntegral . fromEnum) =&lt;&lt;
    getContents
  regFile &lt;- newArray (0,15) 0 :: IO (IOArray Word16 Word8)
  ip &lt;- newIORef 0
  cf &lt;- newIORef False
  zf &lt;- newIORef False
  sf &lt;- newIORef False
  let proc = Proc ramRef regFile ip cf zf sf
  runReaderT (writeReg regSp (0x100 :: Word16)) proc

  bracket_ (return ()) 
           (dumpScreen ramRef) 
           (forever . flip runReaderT proc $ processInstr)

dumpScreen ramRef = do
  mem &lt;- freeze ramRef
  forM_ [0..25] $ \i -&gt; do
    forM_ [0..79] $ \j -&gt; do
      let c = chr . fromIntegral $ mem ! (0x8000 + 80*i + j)
      putChar (if isPrint c then c else ' ')
    putChar '\n'
</code></pre><div class="diff-skipped"><div></div></div><p><span class="diff-add"> Update 1: got it down to 234 lines.  Better organized the code by functionality, re-aligned what could be, tried to stick to 80 columns.  And refactored the ALU multiple times.</span></p>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-d587eb70-c0bc-4d55-915a-4a8f18910f4f">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('58177744-7375-4f35-947f-b5fc1de43666') ">
                        <span id="rev-arrow-58177744-7375-4f35-947f-b5fc1de43666" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('58177744-7375-4f35-947f-b5fc1de43666') ">
                        <span title="revision 1">1</span>
                    </td>
                    <td class="revcell3 vm">
                        <br>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/58177744-7375-4f35-947f-b5fc1de43666/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/4985/1" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        answered <span title="2012-02-27 15:57:20Z" class="relativetime">Feb 27 '12 at 15:57</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/199/j-b"><div><img src="https://www.gravatar.com/avatar/1eda356bddd3b93818cb1310a7bc952f?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/199/j-b">J B</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">6,327</span><span title="7 silver badges"><span class="badge2"></span><span class="badgecount">7</span></span><span title="38 bronze badges"><span class="badge3"></span><span class="badgecount">38</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev58177744-7375-4f35-947f-b5fc1de43666" class="revcell5" style="display: block">
<div class="diffs">
        <h1></h1>

        <div class="post-text">
            <h1>Haskell, 256 lines ;-)</h1>

<p>I've had this work-in-progress one for some time, I intended to polish it a bit more before publishing, but now the fun's officially started, there's not much point in keeping it hidden anymore.  I noticed while extracting it that it's exactly 256 lines long, so I suppose it is at a "remarkable" point of its existence.</p>

<p><em>What's in:</em> barely enough of the 8086 instruction set to run the example binary flawlessly.  <strong>Self-modifying code is supported.</strong> (prefetch: zero bytes)  Ironically, the first sufficient iterations of the code were longer and supported less of the opcode span, but refactoring was beneficial to both code length and opcode coverage.</p>

<p><em>What's out:</em> obviously, segments, prefixes and multibyte opcodes, interrupts, I/O ports, string operations, and FP.  I initially did follow the original PUSH SP behavior, but had to drop it after a few refactorings.</p>

<p>Carry flag results are probably very messed up in a few cases of ADC/SBB.</p>

<p>Anyway, here's the code:</p>

<pre><code>{-# LANGUAGE FlexibleContexts #-}

import Prelude hiding (read)
import Data.Char (chr,isPrint)
import Data.Word (Word8,Word16)
import Data.Int (Int8)
import Data.Bits
import Data.IORef
import Data.Array ((!))
import Data.Array.IO
import Control.Monad.Reader
import Control.Exception (bracket_)
import System
import System.IO (hSetEncoding,stdin,latin1)

ifte t _ True = t
ifte _ f False = f

type Place = (IOArray Word16 Word8,Word16)

[regAl,regAh,regCl,regCh,regDl,regDh,regBl,regBh] = [0..7]
[regAx,regCx,regDx,regBx,regSp,regBp,regSi,regDi] = [0,2..14]

decodeReg8  n = fromIntegral $ (n `shiftL` 1) .|. (n `shiftR` 2)
readDecodedReg8 = readReg . decodeReg8
decodeReg16 n = fromIntegral $  n `shiftL` 1
readDecodedReg16 = readReg . decodeReg16

concatBytes :: Word8 -&gt; Word8 -&gt; Word16
concatBytes l h = (fromIntegral l) .|. (fromIntegral h `shiftL` 8)

byteToWordSE :: Word8 -&gt; Word16
byteToWordSE = (fromIntegral :: Int8 -&gt; Word16) .
               (fromIntegral :: Word8 -&gt; Int8)

wordToByteL,wordToByteH :: Word16 -&gt; Word8
wordToByteL = fromIntegral
wordToByteH = fromIntegral . (`shiftR` 8)

byte = undefined :: Word8
word = undefined :: Word16

class Bits a =&gt; Width a where
  read :: MonadIO m =&gt; Place -&gt; m a
  write :: MonadIO m =&gt; Place -&gt; a -&gt; m ()

readReg reg = ask &gt;&gt;= \p -&gt; read (regs p,reg)
readRam addr = ask &gt;&gt;= \p -&gt; read (ram p,addr)
writeReg reg val = ask &gt;&gt;= \p -&gt; write (regs p,reg) val
writeRam addr val = ask &gt;&gt;= \p -&gt; write (ram p,addr) val

instance Width Word8 where
  read = liftIO . uncurry readArray
  write p = liftIO . uncurry writeArray p

instance Width Word16 where
  read (p,a) = liftM2 concatBytes (read (p,a)) (read (p,a+1))
  write (p,a) val = do
    write (p,a)   $ wordToByteL val
    write (p,a+1) $ wordToByteH val

data Proc = Proc {
    ram :: IOArray Word16 Word8
  , regs :: IOArray Word16 Word8
  , ip :: IORef Word16
  , cf :: IORef Bool
  , zf :: IORef Bool
  , sf :: IORef Bool
}

readProc ext = liftIO . readIORef . ext =&lt;&lt; ask
writeProc ext f = liftIO . flip writeIORef f . ext =&lt;&lt; ask

modifyIP f = do
  ipRef &lt;- liftM ip ask
  old &lt;- liftIO $ readIORef ipRef
  liftIO $ modifyIORef ipRef f
  return old

readModRM = do
  modRM &lt;- readInstr8
  let mod   =  modRM           `shiftR` 6
      opReg = (modRM .&amp;. 0x38) `shiftR` 3
      rm    =  modRM .&amp;. 0x07
  proc &lt;- ask
  operand &lt;- case mod of
               0 -&gt; do
                 addr &lt;- case rm of
                           1 -&gt; liftM2 (+) (readReg regBx) (readReg regDi)
                           2 -&gt; liftM2 (+) (readReg regBp) (readReg regSi)
                           6 -&gt; readInstr16
                           7 -&gt; readReg regBx
                 return (ram proc,addr)
               2 -&gt; do
                 addr &lt;- case rm of
                           5 -&gt; liftM2 (+) (readReg regDi) readInstr16
                           7 -&gt; liftM2 (+) (readReg regBx) readInstr16
                 return (ram proc,addr)
               3 -&gt; return (regs proc,2*fromIntegral rm)
  return (operand,opReg,opReg)

readInstr8 = modifyIP (+1) &gt;&gt;= readRam
readInstr16 = liftM2 concatBytes readInstr8 readInstr8

push16 :: (MonadIO m,MonadReader Proc m) =&gt; Word16 -&gt; m ()
push16 val = do -- PUSH by value (doesn't reproduce PUSH SP behavior)
  sp &lt;- liftM (subtract 2) (readReg regSp)
  writeReg regSp sp
  writeRam sp val
pop16 = do
  sp &lt;- readReg regSp
  val &lt;- readRam sp
  writeReg regSp (sp+2)
  return val

jump cond = when cond . void . modifyIP . (+) . byteToWordSE =&lt;&lt; readInstr8

opAdd a b = return (Just $ a &gt;= negate b, a  +  b)
opOr  a b = return (Just False,           a .|. b)
opAdc a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &gt;= negate (b + c), a+b+c)
opXor a b = return (Just False,         a `xor` b)
opAnd a b = return (Just False,           a .&amp;. b)
opSub a b = return (Just $ a &lt;= b,        a  -  b)
opSbb a b = do
  c &lt;- liftM (ifte 1 0) (readProc cf)
  return (Just $ a &lt; b + c, a-b-c)
opInc a _ = return (Nothing,              a  +  1)
opDec a _ = return (Nothing,              a  -  1)

alu :: (Width w,MonadIO m,MonadReader Proc m) =&gt; w -&gt; m w -&gt; m w -&gt; Maybe Place -&gt; (w -&gt; w -&gt; m (Maybe Bool,w)) -&gt; m ()
alu w a b o op = do
  (c,v) &lt;- join (liftM2 op a b)
  maybe (return ()) (flip write v) o
  writeProc zf (v == 0)
  writeProc sf (testBit v (bitSize v - 1))
  maybe (return ()) (writeProc cf) c

decodeALU 0 o = (Just o, opAdd)
decodeALU 1 o = (Just o, opOr)
decodeALU 2 o = (Just o, opAdc)
decodeALU 3 o = (Just o, opSbb)
decodeALU 4 o = (Just o, opAnd)
decodeALU 5 o = (Just o, opSub)
decodeALU 6 o = (Just o, opXor)
decodeALU 7 _ = (Nothing, opSub)

processInstr = do
  opcode &lt;- readInstr8
  regs &lt;- liftM regs ask
  let zReg = decodeReg16 (opcode .&amp;. 0x07)
      zRegPlace = (regs,zReg)
      aluOp = (opcode .&amp;. 0x38) `shiftR` 3
  if opcode &lt; 0x40 then do
    case opcode .&amp;. 0x07 of
      0 -&gt; do
        (operand,reg,_) &lt;- readModRM
        uncurry (alu byte (read operand) (readDecodedReg8 reg))
                (decodeALU aluOp operand)
      1 -&gt; do
        (operand,reg,_) &lt;- readModRM
        uncurry (alu word (read operand) (readDecodedReg16 reg))
                (decodeALU aluOp operand)
      4 -&gt; do
        uncurry (alu byte (readReg regAl) readInstr8)
                (decodeALU aluOp (regs,regAl))
  else case opcode .&amp;. 0xF8 of
    0x40 -&gt; alu word (readReg zReg) (return undefined) (Just zRegPlace) opInc
    0x48 -&gt; alu word (readReg zReg) (return undefined) (Just zRegPlace) opDec
    0x50 -&gt; readReg zReg &gt;&gt;= push16                       -- 16-bit reg PUSH
    0x58 -&gt; pop16 &gt;&gt;= writeReg zReg                       -- 16-bit reg POP
    0x90 -&gt; do                                            -- 16-bit XCHG (or NOP)
      v1 &lt;- readReg zReg
      v2 &lt;- readReg regAx
      writeReg zReg (v2 :: Word16)
      writeReg regAx (v1 :: Word16)
    0xB0 -&gt; readInstr8  &gt;&gt;= writeReg zReg                 --  8-bit MOV reg,imm
    0xB8 -&gt; readInstr16 &gt;&gt;= writeReg zReg                 -- 16-bit MOV reg,imm
    _ -&gt; do
      case if opcode == 0x80 then 0x82 else opcode of
        0x72 -&gt; jump       =&lt;&lt; (readProc cf)              -- JB/JNAE/JC
        0x74 -&gt; jump       =&lt;&lt; (readProc zf)              -- JE/JZ
        0x75 -&gt; jump . not =&lt;&lt; (readProc zf)              -- JNE/JNZ
        0x76 -&gt; jump       =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JBE
        0x77 -&gt; jump . not =&lt;&lt; liftM2 (||) (readProc cf) (readProc zf) -- JA
        0x79 -&gt; jump . not =&lt;&lt; (readProc sf)              -- JNS
        0x81 -&gt; do                                        -- 16-bit arith
          (operand,_,op) &lt;- readModRM
          uncurry (alu word (read operand) readInstr16) (decodeALU op operand)
        0x82 -&gt; do                                        -- 8-bit arith
          (operand,_,op) &lt;- readModRM
          uncurry (alu byte (read operand) readInstr8) (decodeALU op operand)
        0x83 -&gt; do                                        -- 16 to 8s arith
          (operand,_,op) &lt;- readModRM
          uncurry (alu word (read operand) (liftM byteToWordSE readInstr8))
                  (decodeALU op operand)
        0x86 -&gt; do                                        -- 8-bit XCHG reg,modRM
          (operand,reg,_)&lt;- readModRM
          v1 &lt;- readDecodedReg8 reg
          v2 &lt;- read operand
          writeReg (decodeReg8 reg) (v2 :: Word8)
          write operand v1
        0x88 -&gt; do                                        -- 8-bit MOV modRM,reg
          (operand,reg,_) &lt;- readModRM
          readDecodedReg8 reg &gt;&gt;= write operand
        0x89 -&gt; do                                        -- 16-bit MOV modRM,reg
          (operand,reg,_) &lt;- readModRM
          readDecodedReg16 reg &gt;&gt;= write operand
        0x8A -&gt; do                                        -- 8-bit MOV reg,modRM
          (operand,reg,_) &lt;- readModRM
          val &lt;- read operand 
          writeReg (decodeReg8 reg) (val :: Word8)
        0x8B -&gt; do                                        -- 16-bit MOV reg,modRM
          (operand,reg,_) &lt;- readModRM
          val &lt;- read operand 
          writeReg (decodeReg16 reg) (val :: Word16)
        0xC3 -&gt; pop16 &gt;&gt;= writeProc ip                    -- RET
        0xC7 -&gt; do -- 16-bit MOV modRM,imm
          (operand,_,_) &lt;- readModRM
          readInstr16 &gt;&gt;= write operand
        0xE8 -&gt; readInstr16 &gt;&gt;= modifyIP . (+) &gt;&gt;= push16 -- CALL relative
        0xEB -&gt; jump True                                 -- JMP short
        0xF4 -&gt; liftIO (exitWith ExitSuccess)             -- HLT
        0xF9 -&gt; writeProc cf True                         -- STC
        0xFE -&gt; do                                        -- 8-bit INC/DEC modRM
          (operand,_,op) &lt;- readModRM
          alu byte (read operand) (return undefined) (Just operand)
               (if op == 0 then opInc else opDec)

main = do
  ramRef &lt;- newArray (0,0xFFFF) 0 :: IO (IOArray Word16 Word8)
  hSetEncoding stdin latin1
  mapM_ (uncurry (writeArray ramRef)) .
    zip [0..] .
    map (fromIntegral . fromEnum) =&lt;&lt;
    getContents
  regFile &lt;- newArray (0,15) 0 :: IO (IOArray Word16 Word8)
  ip &lt;- newIORef 0
  cf &lt;- newIORef False
  zf &lt;- newIORef False
  sf &lt;- newIORef False
  let proc = Proc ramRef regFile ip cf zf sf
  runReaderT (writeReg regSp (0x100 :: Word16)) proc

  bracket_ (return ()) 
           (dumpScreen ramRef) 
           (forever . flip runReaderT proc $ processInstr)

dumpScreen ramRef = do
  mem &lt;- freeze ramRef
  forM_ [0..25] $ \i -&gt; do
    forM_ [0..79] $ \j -&gt; do
      let c = chr . fromIntegral $ mem ! (0x8000 + 80*i + j)
      putChar (if isPrint c then c else ' ')
    putChar '\n'
</code></pre>

<p>The output for the provided sample binary matches the specification perfectly.  Try it out using an invocation such as:</p>

<pre><code>runhaskell 8086.hs &lt;8086.bin
</code></pre>

<p>Most non-implemented operations will simply result in a pattern matching failure.</p>

<p>I still intend to factor quite a bit more, and implement actual live output with curses.</p>

        </div>

        <div class="tags-diff">
            
        </div>
</div>                        </div>
                    </td>
                </tr>
                <tr id="spacer-58177744-7375-4f35-947f-b5fc1de43666">
                    <td colspan="4" height="10px"></td>
                </tr>

        </table>

            <div class="pager fl">
        





    </div>


    </div>
</div>

<script type="text/javascript">
    StackExchange.using("revisions", function () { StackExchange.revisions.init(4985) });
</script>

<div style="display:none" id="prettify-lang"></div>
        </div>
    </div>
    <div id="footer" class="categories">
        <div class="footerwrap">
            <div id="footer-menu">
                <div class="top-footer-links">
                        <a href="/about">about</a>
                    <a href="/help">help</a>
                        <a href="/help/badges">badges</a>
                    <a href="http://blog.stackexchange.com?blb=1">blog</a>
                        <a href="http://chat.stackexchange.com">chat</a>
                    <a href="http://data.stackexchange.com">data</a>
                    <a href="http://stackexchange.com/legal">legal</a>
                    <a href="http://stackexchange.com/legal/privacy-policy">privacy policy</a>
                    <a href="http://stackexchange.com/about/hiring">jobs</a>
                    <a href="http://stackexchange.com/about/contact">advertising info</a>

                    <a onclick='StackExchange.switchMobile("on", "/posts/4985/revisions")'>mobile</a>
                    <b><a href="/contact">contact us</a></b>
                        <b><a href="http://meta.codegolf.stackexchange.com">feedback</a></b>
                    
                </div>
                <div id="footer-sites">
                    <table>
    <tr>
            <th colspan=3>
                Technology
            </th>
            <th >
                Life / Arts
            </th>
            <th >
                Culture / Recreation
            </th>
            <th >
                Science
            </th>
            <th >
                Other
            </th>
    </tr>
    <tr>
            <td>
                <ol>
                        <li><a href="http://stackoverflow.com" title="professional and enthusiast programmers">Stack Overflow</a></li>
                        <li><a href="http://serverfault.com" title="professional system and network administrators">Server Fault</a></li>
                        <li><a href="http://superuser.com" title="computer enthusiasts and power users">Super User</a></li>
                        <li><a href="http://webapps.stackexchange.com" title="power users of web applications">Web Applications</a></li>
                        <li><a href="http://askubuntu.com" title="Ubuntu users and developers">Ask Ubuntu</a></li>
                        <li><a href="http://webmasters.stackexchange.com" title="pro webmasters">Webmasters</a></li>
                        <li><a href="http://gamedev.stackexchange.com" title="professional and independent game developers">Game Development</a></li>
                        <li><a href="http://tex.stackexchange.com" title="users of TeX, LaTeX, ConTeXt, and related typesetting systems">TeX - LaTeX</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://programmers.stackexchange.com" title="professional programmers interested in conceptual questions about software development">Programmers</a></li>
                        <li><a href="http://unix.stackexchange.com" title="users of Linux, FreeBSD and other Un*x-like operating systems.">Unix &amp; Linux</a></li>
                        <li><a href="http://apple.stackexchange.com" title="power users of Apple hardware and software">Ask Different (Apple)</a></li>
                        <li><a href="http://wordpress.stackexchange.com" title="WordPress developers and administrators">WordPress Answers</a></li>
                        <li><a href="http://gis.stackexchange.com" title="cartographers, geographers and GIS professionals">Geographic Information Systems</a></li>
                        <li><a href="http://electronics.stackexchange.com" title="electronics and electrical engineering professionals, students, and enthusiasts">Electrical Engineering</a></li>
                        <li><a href="http://android.stackexchange.com" title="enthusiasts and power users of the Android operating system">Android Enthusiasts</a></li>
                        <li><a href="http://security.stackexchange.com" title="Information security professionals">Information Security</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://dba.stackexchange.com" title="database professionals who wish to improve their database skills and learn from others in the community">Database Administrators</a></li>
                        <li><a href="http://drupal.stackexchange.com" title="Drupal developers and administrators">Drupal Answers</a></li>
                        <li><a href="http://sharepoint.stackexchange.com" title="SharePoint enthusiasts">SharePoint</a></li>
                        <li><a href="http://ux.stackexchange.com" title="user experience researchers and experts">User Experience</a></li>
                        <li><a href="http://mathematica.stackexchange.com" title="users of Mathematica">Mathematica</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#technology" class="more">
                                more (14)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://photo.stackexchange.com" title="professional, enthusiast and amateur photographers">Photography</a></li>
                        <li><a href="http://scifi.stackexchange.com" title="science fiction and fantasy enthusiasts">Science Fiction &amp; Fantasy</a></li>
                        <li><a href="http://cooking.stackexchange.com" title="professional and amateur chefs">Seasoned Advice (cooking)</a></li>
                        <li><a href="http://diy.stackexchange.com" title="contractors and serious DIYers">Home Improvement</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#lifearts" class="more">
                                more (13)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://english.stackexchange.com" title="linguists, etymologists, and serious English language enthusiasts">English Language &amp; Usage</a></li>
                        <li><a href="http://skeptics.stackexchange.com" title="scientific skepticism">Skeptics</a></li>
                        <li><a href="http://judaism.stackexchange.com" title="those who base their lives on Jewish law and tradition and anyone interested in learning more">Mi Yodeya (Judaism)</a></li>
                        <li><a href="http://travel.stackexchange.com" title="road warriors and seasoned travelers">Travel</a></li>
                        <li><a href="http://christianity.stackexchange.com" title="committed Christians, experts in Christianity and those interested in learning more">Christianity</a></li>
                        <li><a href="http://gaming.stackexchange.com" title="passionate videogamers on all platforms">Arqade (gaming)</a></li>
                        <li><a href="http://bicycles.stackexchange.com" title="people who build and repair bicycles, people who train cycling, or commute on bicycles">Bicycles</a></li>
                        <li><a href="http://rpg.stackexchange.com" title="gamemasters and players of tabletop, paper-and-pencil role-playing games">Role-playing Games</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#culturerecreation" class="more">
                                more (21)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://math.stackexchange.com" title="people studying math at any level and professionals in related fields">Mathematics</a></li>
                        <li><a href="http://stats.stackexchange.com" title="statisticians, data analysts, data miners and data visualization experts">Cross Validated (stats)</a></li>
                        <li><a href="http://cstheory.stackexchange.com" title="theoretical computer scientists and researchers in related fields">Theoretical Computer Science</a></li>
                        <li><a href="http://physics.stackexchange.com" title="active researchers, academics and students of physics">Physics</a></li>
                        <li><a href="http://mathoverflow.net" title="professional mathematicians">MathOverflow</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#science" class="more">
                                more (7)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://stackapps.com" title="apps, scripts, and development with the Stack Exchange API">Stack Apps</a></li>
                        <li><a href="http://meta.stackoverflow.com" title="meta-discussion of the Stack Exchange family of Q&amp;A websites">Meta Stack Overflow</a></li>
                        <li><a href="http://area51.stackexchange.com" title="proposing new sites in the Stack Exchange network">Area 51</a></li>
                        <li><a href="http://careers.stackoverflow.com">Stack Overflow Careers</a></li>
                    
                </ol>
            </td>
    </tr>
</table>
                </div>
            </div>

            <div id="copyright">
                site design / logo &#169; 2013 stack exchange inc; user contributions licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license">cc-wiki</a> 
 with <a href="http://blog.stackoverflow.com/2009/06/attribution-required/" rel="license">attribution required</a>
            </div>
            <div id="footer-flair">
                <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="cc-wiki-link"></a>
            </div>
            <div id="svnrev">
                rev 2013.11.26.1178
            </div>
            
        </div>
    </div>
    <noscript>
        <div id="noscript-warning">Programming Puzzles &amp; Code Golf Stack Exchange works best with JavaScript enabled<img src="http://pixel.quantserve.com/pixel/p-c1rF4kxgLUzNc.gif" alt="" class="dno"></div>
    </noscript>

    <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-5620270-24']);
        _gaq.push(['_setDomainName','.stackexchange.com']);
_gaq.push(['_trackPageview']);
    var _qevents = _qevents || [];
    var _comscore = _comscore || [];
    (function () {
        var ssl='https:'==document.location.protocol,
            s=document.getElementsByTagName('script')[0],
            ga=document.createElement('script');
        ga.type='text/javascript';
        ga.async=true;
        ga.src=(ssl?'https://ssl':'http://www')+'.google-analytics.com/ga.js';
        s.parentNode.insertBefore(ga,s);
        var sc=document.createElement('script');
        sc.type='text/javascript';
        sc.async=true;
        sc.src=(ssl?'https://secure':'http://edge')+'.quantserve.com/quant.js';
        s.parentNode.insertBefore(sc, s);
        
        var s = document.createElement("script"), el = document.getElementsByTagName("script")[0]; s.async = true;
        s.src = (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js";
        el.parentNode.insertBefore(s, el);
        
    })();
    _comscore.push({ c1: "2", c2: "17440561" });
    _qevents.push({ qacct: "p-c1rF4kxgLUzNc" });
    </script>            
</body>
</html>