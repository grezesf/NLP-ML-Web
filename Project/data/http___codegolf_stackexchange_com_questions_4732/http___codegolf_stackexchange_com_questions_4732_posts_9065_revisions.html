<!DOCTYPE html>
<html>
<head>
    
    <title>Revisions - Programming Puzzles & Code Golf Stack Exchange</title>
    <link rel="shortcut icon" href="//cdn.sstatic.net/codegolf/img/favicon.ico">
    <link rel="apple-touch-icon image_src" href="//cdn.sstatic.net/codegolf/img/apple-touch-icon.png">
    <link rel="search" type="application/opensearchdescription+xml" title="Programming Puzzles &amp; Code Golf Stack Exchange" href="/opensearch.xml">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@StackCodeGolf" />
    <meta name="twitter:domain" content="codegolf.stackexchange.com"/>
    <meta name="og:type" content="website" />
    <meta name="og:image" content="http://cdn.sstatic.net/codegolf/img/apple-touch-icon.png?v=6f55f0b2476f"/>
    <meta name="og:title" content="Revisions" />
    <meta name="og:description" content="Q&amp;A for programming puzzle enthusiasts and code golfers" />
    <meta name="og:url" content="http://codegolf.stackexchange.com/posts/9065/revisions"/>

    
    
    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="//cdn.sstatic.net/Js/stub.en.js?v=e3d47b73fa12" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="//cdn.sstatic.net/codegolf/all.css?v=a1dd281cae8a">
    

    <script type="text/javascript">
        StackExchange.ready(function () {
            StackExchange.realtime.init('wss://qa.sockets.stackexchange.com,ws://qa.sockets.stackexchange.com');
            StackExchange.realtime.subscribeToInboxNotifications();
                    StackExchange.realtime.subscribeToReputationNotifications('200');
                        });
    </script>
    <script type="text/javascript">
        StackExchange.init({"locale":"en","stackAuthUrl":"https://stackauth.com","serverTime":1385444823,"styleCode":true,"enableUserHovercards":true,"site":{"name":"Programming Puzzles & Code Golf Stack Exchange","description":"Q&A for programming puzzle enthusiasts and code golfers","isNoticesTabEnabled":true,"recaptchaPublicKey":"6LdsB7sSAAAAAAzjgEF_Hd8vXv-C42sa_KyofaGR","enableSocialMediaInSharePopup":true},"user":{"fkey":"f51c005c36aeb04be7163e16a81b52d5","isAnonymous":true}});
        StackExchange.using.setCacheBreakers({"js/prettify-full.en.js":"e0bbd4760e83","js/moderator.en.js":"1a411fd265fe","js/full-anon.en.js":"8a881a0975af","js/full.en.js":"e87912181c10","js/wmd.en.js":"bd9234d44a40","js/third-party/jquery.autocomplete.min.js":"e5f01e97f7c3","js/third-party/jquery.autocomplete.min.en.js":"","js/mobile.en.js":"d1d834ef85d2","js/help.en.js":"d3cc74d8a93a","js/tageditor.en.js":"6d51a5f8d7f3","js/tageditornew.en.js":"111b781cf314","js/inline-tag-editing.en.js":"f951bd09dc69","js/revisions.en.js":"33fd38144303","js/review.en.js":"f45b4ec094ea","js/tagsuggestions.en.js":"e4e7b952fcc7","js/post-validation.en.js":"c275fe37d674","js/explore-qlist.en.js":"73825bd006fc","js/events.en.js":"53bc48767091"});
        StackExchange.using("gps", function() {
             StackExchange.gps.init(true);
        });
        
    </script>
    
        <script type="text/javascript">
            StackExchange.ready(function () {
                $('#nav-tour').click(function () {
                    StackExchange.using("gps", function() {
                        StackExchange.gps.track("aboutpage.click", { aboutclick_location: "headermain" }, true);
                    });
                });
            });
        </script>
</head>
<body class="revision-page">
    <noscript><div id="noscript-padding"></div></noscript>
    <div id="notify-container"></div>
    <div id="overlay-header"></div>
    <div id="custom-header"></div>
    <div class="container">
        <div id="header" class=headeranon>
            <div id="portalLink">
                <a class="genu" href="http://stackexchange.com" onclick="StackExchange.ready(function(){genuwine.click();});return false;">Stack Exchange</a>
            </div>
            <div id="topbar">
                <div id="hlinks">
                    
<span id="hlinks-user"></span>
<span id="hlinks-nav">                        <a href="/users/login?returnurl=%2fposts%2f9065%2frevisions">sign up</a>

 <span class="lsep">|</span>
                    <a href="/users/login?returnurl=%2fposts%2f9065%2frevisions">log in</a>

 <span class="lsep">|</span>
</span>
<span id="hlinks-custom"></span>
                </div>
                <div id="hsearch">
                    <form id="search" action="/search" method="get" autocomplete="off">
                        <div>
                            <input autocomplete="off" name="q" class="textbox" placeholder="search" tabindex="1" type="text" maxlength="240" size="28" value="">
                        </div>
                    </form>
                </div>
            </div>
            <br class="cbt">
            <div id="hlogo">
                <a href="/">
                    Programming Puzzles &amp; Code Golf
                        <span class="beta-title">beta</span>
                </a>
            </div>
            <div id="hmenus">
                <div class="nav mainnavs mainnavsanon">
                    <ul>
                            <li><a id="nav-questions" href="/questions">Questions</a></li>
                            <li><a id="nav-tags" href="/tags">Tags</a></li>
                            <li><a id="nav-tour" href="/about">Tour</a></li>
                            <li><a id="nav-users" href="/users">Users</a></li>
                    </ul>
                </div>
                <div class="nav askquestion">
                    <ul>
                        <li>
                            <a id="nav-askquestion"  href="/questions/ask">Ask Question</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        



        <div id="content">
            


<div id="mainbar-full">

    <div class="subheader">
        <h1><a href="/questions/4732/emulate-an-intel-8086-cpu/9065#9065" class="answer-hyperlink ">Return to Answer</a></h1>
    </div>

    <div id="revisions">
        <table>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('a1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186') ">
                        <span id="rev-arrow-a1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('a1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186') ">
                        <span title="revision 7">7</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">Completed the challenge.</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/a1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/7" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-12-20 05:22:42Z" class="relativetime">Dec 20 '12 at 5:22</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="reva1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <del>531</del> <em><span class="diff-delete">222</span></em> <span class="diff-delete">lines</span><del><em><span class="diff-add">222</span></em></del> <span class="diff-add">246 lines</span>)</h1><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Runs the test program, again! The final few bugs for the shorter re-write were neglecting to sign-extend the immediate byte in opcodes 83 (the "Immediate" group) and EB (short JMP). 24-line increase covers additional debugging routines needed to track down those final bugs.</span></p><pre><code>%!
%a8086.ps Draught2:BREVITY
[/NULL&lt;0000&gt;/nul 0
/mem 16#ffff string %16-bit memory
/CF 0 /OF 0 /AF 0 /ZF 0 /SF 0
/regs 20 string &gt;&gt;begin %register byte storage
0{AL AH CL CH DL DH BL BH}{regs 2 index 1 getinterval def 1 add}forall pop
0{AX CX DX BX SP BP SI DI IP FL}{regs 2 index 2 getinterval def 2 add}forall pop

%getting and fetching
[/*b{0 get} %get byte from pointer
/*w{dup *b exch 1 get bbw} %get word from pointer
/*{{*b *w}W get exec} %get data(W) from pointer
/bbw{8 bitshift add} %lo-byte hi-byte -&gt; word
/shiftmask{2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and}
/fetchb{IP *w mem exch get bytedump   IP dup *w 1 add storew} % byte(IP++)
/fetchw{fetchb fetchb bbw} % word(IP),IP+=2

%storing and accessing
/storeb{16#ff and 0 exch put} % ptr val8 -&gt; -
/storew{2 copy storeb -8 bitshift 16#ff and 1 exch put} % ptr val16 -&gt; -
/stor{{storeb storew}W get exec} % ptr val(W) -&gt; -
/memptr{<span class="diff-add">16#ffff and </span>mem exch {1 2}W get getinterval} % addr -&gt; ptr(W)

%decoding the mod-reg-reg/mem byte
/mrm{fetchb 3 shiftmask /RM exch def 3 shiftmask /REG exch def /MOD exch def}
/REGTAB[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]
/decreg{REGTAB W get REG get} % REGTAB[W][REG]
%2 indexes,   with immed byte,   with immed word
/2*w{exch *w exch *w add}/fba{fetchb add}/fwa{fetchw add}
/RMTAB[[{BX SI 2*w}{BX DI 2*w}{BP SI 2*w}{BP DI 2*w}
    {SI *w}{DI *w}{fetchw}{BX *w}]
[{BX SI 2*w fba}{BX DI 2*w fba}{BP SI 2*w fba}{BP DI 2*w fba}
    {SI *w fba}{DI *w fba}{BP *w fba}{BX *w fba}]
[{BX SI 2*w fwa}{BX DI 2*w fwa}{BP SI 2*w fwa}{BP DI 2*w fwa}
    {SI *w fwa}{DI *w fwa}{BP *w fwa}{BX *w fwa}]]
/decrm{MOD 3 eq{REGTAB W get RM get} %MOD=3:register mode
    {RMTAB MOD get RM get exec memptr}ifelse} % RMTAB[MOD][RM] -&gt; addr -&gt; ptr

%setting and storing flags
/flagw{OF 11 bitshift SF 7 bitshift or ZF 6 bitshift or AF 4 bitshift CF or}
/wflag{dup 1 and /CF exch def dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def}
/nz1{0 ne{1}{0}ifelse}
/logflags{/CF 0 def /OF 0 def /AF 0 def %clear mathflags
    dup {16#80 16#8000}W get and nz1 /SF exch def
    dup {16#ff 16#ffff}W get and 0 eq{1}{0}ifelse /ZF exch def}
/mathflags{{z y x}{exch def}forall
    /CF z {16#ff00 16#ffff0000}W get and nz1 def
    /OF z x xor z y xor and {16#80 16#8000}W get and nz1 def
    /AF x y xor z xor 16#10 and nz1 def
    z} %leave the result on stack

%opcodes (each followed by 'stor')  %% { OPTAB fetchb get exec stor } loop
/ADD{2 copy add logflags mathflags}
/OR{or logflags}
/ADC{CF add ADD}
/SBB{D 1 xor {exch}repeat CF add 2 copy sub logflags mathflags}
/AND{and logflags}
/SUB{D 1 xor {exch}repeat 2 copy sub logflags mathflags}
/XOR{xor logflags}
/CMP{3 2 roll pop NULL 3 1 roll SUB} %dummy stor target
/INC{t CF exch dup * 1 ADD 3 2 roll /CF exch def}
/DEC{t CF exch dup * 1 SUB 3 2 roll /CF exch def}
/PUSH{SP dup *w 2 sub storew   *w SP *w memptr exch}
/POP{SP *w memptr *w   SP dup *w 2 add storew}

/jrel{w {CBW IP *w add IP exch}{NULL exch}ifelse}
/JO{fetchb OF 1 eq jrel }
/JNO{fetchb OF 0 eq jrel }
/JB{fetchb CF 1 eq jrel }
/JNB{fetchb CF 0 eq jrel }
/JZ{fetchb ZF 1 eq jrel }
/JNZ{fetchb ZF 0 eq jrel }
/JBE{fetchb CF ZF or 1 eq jrel }
/JNBE{fetchb CF ZF or 0 eq jrel }
/JS{fetchb SF 1 eq jrel }
/JNS{fetchb SF 0 eq jrel }
/JL{fetchb SF OF xor 1 eq jrel }
/JNL{fetchb SF OF xor 0 eq jrel }
/JLE{fetchb SF OF xor ZF or 1 eq jrel }
/JNLE{fetchb SF OF xor ZF or 0 eq jrel }

/bw{dup 16#80 and 0 ne{16#ff xor 1 add 16#ffff xor 1 add}if}
/IMMTAB{ADD OR ADC SBB AND SUB XOR CMP }cvlit
/immed{<span class="diff-delete">mrm
   </span> <span class="diff-delete">{fetchb</span><span class="diff-add">W</span> <span class="diff-delete">fetchw</span><span class="diff-add">2</span> <span class="diff-add">eq</span>{<span class="diff-delete">fetchb bw</span> /W 1 def<span class="diff-delete">}}W</span><span class="diff-add">&nbsp;
</span> <span class="diff-delete">get</span> <span class="diff-delete">exec</span><span class="diff-add">          mrm decrm dup * fetchb bw</span>
    <span class="diff-add">}{ mrm </span>decrm dup * <span class="diff-delete">3</span><span class="diff-add">{fetchb</span> <span class="diff-delete">2</span><span class="diff-add">fetchw}W</span> <span class="diff-delete">roll</span><span class="diff-add">get</span> <span class="diff-add">exec }ifelse
    </span>exch IMMTAB REG get<span class="diff-add"> dup ==</span> exec }

%/TEST{ }
/XCHG{3 2 roll pop 2 copy exch * 4 2 roll * stor }
/AXCH{w dup AX XCHG }
<span class="diff-add">/NOP{ NULL nul }
</span>/pMOV{D{exch}repeat pop }
/<span class="diff-delete">MOV</span><span class="diff-add">mMOV</span>{<span class="diff-add"> 3 1 roll pop</span> <span class="diff-add">pop </span>}<span class="diff-add">
/MOV{</span> <span class="diff-delete">%8-D</span><span class="diff-add">}</span>
/LEA{w mrm decreg RMTAB MOD get RM get exec }

/CBW{dup 16#80 and 0 ne {16#ff xor 1 add 16#ffff xor 1 add } if }
/CWD{dup 16#8000 and 0 ne {16#ffff xor 1 add neg } if }
/CALL{w xp /xp{}def fetchw IP PUSH storew IP dup *w 3 2 roll add dsp /dsp{}def }
%/WAIT{ }
/PUSHF{NULL dup flagw storew 2 copy PUSH }
/POPF{NULL dup POP *w wflag }
%/SAHF{ }
%/LAHF{ }

%/MOVS{ }
%/CMPS{ }
%/STOS{ }
%/LODS{ }
%/SCAS{ }
/RET{w IP POP storew SP dup * 3 2 roll add }
%/LES{ }
%/LDS{ }

/JMP{IP dup fetchw exch *w add<span class="diff-delete"> </span>}
/sJMP{IP dup fetchb<span class="diff-add"> bw</span> exch *w add<span class="diff-delete"> </span>}

/HLT{<span class="diff-delete">stop</span><span class="diff-add">exit</span>}
/CMC{/CF CF 1 xor def NULL nul}
/CLC{/CF 0 def NULL nul}
/STC{/CF 1 def NULL nul}

/NOT{not logflags }
/NEG{neg logflags }
/GRP1TAB{TEST --- NOT NEG MUL IMUL DIV IDIV } cvlit
/Grp1{mrm decrm dup * GRP1TAB REG get<span class="diff-add">
dup</span> <span class="diff-add">==
</span>exec }
/GRP2TAB{INC DEC {id CALL}{l id CALL}{id JMP}{l id JMP} PUSH --- } cvlit
/Grp2{mrm decrm GRP2TAB REG get<span class="diff-add">
dup</span> <span class="diff-add">==
</span>exec }

%optab shortcuts
/2*{exch * exch *}
/rm{mrm decreg decrm D index 3 1 roll 2*} % fetch,decode mrm -&gt; dest *reg *r-m
/rmp{mrm decreg decrm D index 3 1 roll} % fetch,decode mrm -&gt; dest reg r-m
/ia{ {{AL dup *b fetchb}{AX dup *w fetchw}}W get exec } %immed to accumulator
/is{/W 2 def}
/b{/W 0 def} %select byte operation
/w{/W 1 def} %select word operation
/t{/D 1 def} %dest = reg
/f{/D 0 def} %dest = r/m
/xp{} /dsp{}
%/far{ /xp { &lt;0000&gt; PUSH storew } /dsp { fetchw pop } def }
/i{ {fetchb fetchw}W get exec }

/OPTAB{
{b f rm ADD}{w f rm ADD}{b t rm ADD}{w t rm ADD}{b ia ADD}{w ia ADD}{ES PUSH}{ES POP} %00-07
 {b f rm OR}{w f rm OR}{b t rm OR}{w t rm OR}{b ia OR}{w ia OR}{CS PUSH}{}            %08-0F
{b f rm ADC}{w f rm ADC}{b t rm ADC}{w t rm ADC}{b ia ADC}{w ia ADC}{SS PUSH}{SS POP} %10-17
 {b f rm SBB}{w f rm SBB}{b t rm SBB}{w t rm SBB}{b ia SBB}{w ia SBB}{DS PUSH}{DS POP}%18-1F
{b f rm AND}{w f rm AND}{b t rm AND}{w t rm AND}{b ia AND}{w ia AND}{ES SEG}{DAA}     %20-27
 {b f rm SUB}{w f rm SUB}{b t rm SUB}{w t rm SUB}{b ia SUB}{w ia SUB}{CS SEG}{DAS}    %28-2F
{b f rm XOR}{w f rm XOR}{b t rm XOR}{w t rm XOR}{b ia XOR}{w ia XOR}{SS SEG}{AAA}     %30-37
 {b f rm CMP}{w f rm CMP}{b t rm CMP}{w t rm CMP}{b ia CMP}{w ia CMP}{DS SEG}{AAS}    %38-3F
{w AX INC}{w CX INC}{w DX INC}{w BX INC}{w SP INC}{w BP INC}{w SI INC}{w DI INC}      %40-47
 {w AX DEC}{w CX DEC}{w DX DEC}{w BX DEC}{w SP DEC}{w BP DEC}{w SI DEC}{w DI DEC}     %48-4F
{AX PUSH}{CX PUSH}{DX PUSH}{BX PUSH}{SP PUSH}{BP PUSH}{SI PUSH}{DI PUSH}              %50-57
 {AX POP}{CX POP}{DX POP}{BX POP}{SP POP}{BP POP}{SI POP}{DI POP}                     %58-5F
{}{}{}{}{}{}{}{}  {}{}{}{}{}{}{}{}                                                    %60-6F
{JO}{JNO}{JB}{JNB}{JZ}{JNZ}{JBE}{JNBE} {JS}{JNS}{JP}{JNP}{JL}{JNL}{JLE}{JNLE}         %70-7F

{b f immed}{w f immed}{b f immed}{is f immed}{b TEST}{w TEST}{b rmp XCHG}{w rmp XCHG}   %80-87
 {b f rm pMOV}{w f rm pMOV}{b t rm pMOV}{w t rm pMOV}                                 %88-8B
   {sr f rm pMOV}{LEA}{sr t rm pMOV}{w mrm decrm POP}                                 %8C-8F
{<span class="diff-delete">AX AXCH</span><span class="diff-add">NOP</span>}{CX AXCH}{DX AXCH}{BX AXCHG}{SP AXCH}{BP AXCH}{SI AXCH}{DI AXCH}             %90-97
 {CBW}{CWD}{far CALL}{WAIT}{PUSHF}{POPF}{SAHF}{LAHF}                                  %98-9F
{b AL m MOV}{w AX m MOV}{b m AL MOV}{b AX m MOV}{MOVS}{MOVS}{CMPS}{CMPS}              %A0-A7
 {b i a TEST}{w i a TEST}{STOS}{STOS}{LODS}{LODS}{SCAS}{SCAS}                         %A8-AF
{b AL i MOV}{b CL i MOV}{b DL i MOV}{b BL i MOV}                                      %B0-B3
 {b AH i MOV}{b CH i MOV}{b DH i MOV}{b BH i MOV}                                     %B4-B7
 {w AX i MOV}{w CX i MOV}{w DX i MOV}{w BX i MOV}                                     %B8-BB
 {w SP i MOV}{w BP i MOV}{w SI i MOV}{w DI i MOV}                                     %BC-BF
{}{}{fetchw RET}{0 RET}{LES}{LDS}{b <span class="diff-delete">i</span><span class="diff-add">f</span> rm <span class="diff-delete">MOV</span><span class="diff-add">i mMOV</span>}{w <span class="diff-delete">i</span><span class="diff-add">f</span> rm<span class="diff-delete"> MOV}   </span> <span class="diff-delete"> </span><span class="diff-add">i</span> <span class="diff-add">mMOV}</span>                       %C0-B7
 {}{}{fetchw RET}{0 RET}{3 INT}{fetchb INT}{INTO}{IRET}                               %C8-CF
{b Shift}{w Shift}{b v Shift}{w v Shift}{AAM}{AAD}{}{XLAT}                            %D0-D7
 {0 ESC}{1 ESC}{2 ESC}{3 ESC}{4 ESC}{5 ESC}{6 ESC}{7 ESC}                             %D8-DF
{LOOPNZ}{LOOPZ}{LOOP}{JCXZ}{b IN}{w IN}{b OUT}{w OUT}                                 %E0-E7
 {CALL}{JMP}{far JMP}{sJMP}{v b IN}{v w IN}{v b OUT}{v w OUT}                         %E8-EF
{LOCK}{}{REP}{z REP}{HLT}{CMC}{b Grp1}{w Grp}                                         %F0-F7
 {CLC}{STC}{CLI}{STI}{CLD}{STD}{b Grp2}{w Grp2}                                       %F8-FF
}cvlit

<span class="diff-add">/break{ /hook /pause load def }
/c{ /hook {} def }
/doprompt{
    (\nbreak&gt;)print
    flush(%lineedit)(r)file
    cvx {exec}stopped pop }
/pause{ doprompt }
/hook{}

</span>/stdout(%stdout)(w)file
/bytedump{ &lt;00&gt; dup 0 3 index put stdout exch writehexstring ( )print }
/regdump{ REGTAB 1 get{ stdout exch writehexstring ( )print }forall
    stdout IP writehexstring ( )print
    {(NC )(CA )}CF get print
    {(NO )(OV )}OF get print
    {(NS )(SN )}SF get print
    {(NZ )(ZR )}ZF get print<span class="diff-add">
    stdout 16#1d3 w</span> <span class="diff-add">memptr writehexstring
    </span>(\n)print<span class="diff-delete"> </span><span class="diff-add">&nbsp;
</span>}
/mainloop{{
    <span class="diff-delete">regdump</span><span class="diff-add">%regdump</span>
    OPTAB fetchb get
    dup ==
    exec
    <span class="diff-delete">pstack</span><span class="diff-add">%pstack flush
    %hook</span>
    stor
    /ic ic 1 add def ictime
}loop}

/printvideo{
    0 1 <span class="diff-delete">24</span><span class="diff-add">28</span> {
        80 mul 16#8000 add mem exch 80 getinterval {
            dup 0 eq { pop 32 } if
<span class="diff-add">                    dup 32 lt 1 index 126 gt or { pop 46 } if
</span>            stdout exch write
        } forall (\n)print
    } for
    (\n)print
}
/ic 0
/ictime{ic 10 mod 0 eq {onq} if}
/timeq 10
/onq{<span class="diff-delete">printvideo</span><span class="diff-add"> %printvideo
</span>}
&gt;&gt;begin<span class="diff-delete"> </span><span class="diff-add">&nbsp;
</span>currentdict{<span class="diff-delete">
    </span>dup type/arraytype eq 1 index xcheck and<span class="diff-add">&nbsp;
</span> <span class="diff-add">   </span>{bind def}{pop pop}ifelse<span class="diff-delete"> </span>}forall

SP 16#100 storew
(codegolf.8086)(r)file mem readstring pop
pop[

mainloop<span class="diff-add">
printvideo</span>

%eof
</code></pre><p> And<span class="diff-delete"> we're back to square 2 with</span> the output<span class="diff-delete">. It's crashing on one of</span><span class="diff-add"> (with</span> the<span class="diff-delete"> MOV permutations</span><span class="diff-add"> tail-end of abbreviated debugging output)</span>.<span class="diff-add">&nbsp; </span></p><pre><span class="diff-delete">7e01 0000 0000 0080 fc0f 0000 0000 beff 7a01 CA NO NS NZ
5b {BX POP}
114
(\000\200)
-mark-
7e01 0000 0000 7200 fe0f 0000 0000 beff 7b01 CA NO NS NZ
c3 {0 RET}
4096
(\000\020)
-mark-
.........
Hello, world!
0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~























7e01 0000 0000 7200 0010 0000 0000 beff 9200 CA NO NS NZ
fe {b Grp2}
c0 127
(~)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9400 CA NO NS NZ
3c {b ia CMP}
7f 0
(\377\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9600 NC NO NS ZR
75 {JNZ}
f7 247
(\000\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9800 NC NO NS ZR
b0 {b AL i MOV}
23 35
(\177)
-mark-
2301 0000 0000 7200 0010 0000 0000 beff 9a00 NC NO NS ZR
c7 {w i rm MOV}
06 d3 01 Error: /rangecheck in --getinterval--
Operand stack:
   --nostringval--   54022   (#\001)   (\201\374\000\001t\001\364\274\000\020\260.\273\000\000K\203\373\377u\361\350Q\001Cu\353\350K\0011\311\t\313u\342r\340\350@\001\271\000\2009\331v\326\3506\001\001\313r\317\350/\001\001\333\203\321\000y\305r\303Q\203\341\001t\275\350\035\001Y\371\273\000\200\031\331u\261r\257\350\017\001\350\000\000[\201\373]\000u\242\201\374\000\020u\234\350\374\000\273r\000S\303\201\374\000\020u\216\350\356\000\220\220\220\353\001\364\350\370\000\270\305\001\350\312\000\350\357\000\2600\350\327\000\376\300\323\001\340\001u\n\261P\307\006\323\001\200\007\353\347\307\006\323\001\340\001\261\022\350\243\000\350\240...)   65584   2
Execution stack:
   %interp_exit   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   --nostringval--   false   1   %stopped_push   1905   1   3   %oparray_pop   1904   1   3   %oparray_pop   1888   1   3   %oparray_pop   1771   1   3   %oparray_pop   --nostringval--   %errorexec_pop   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   %loop_continue   --nostringval--   --nostringval--   --nostringval--
Dictionary stack:
   --dict:1152/1684(ro)(G)--   --dict:0/20(G)--   --dict:92/200(L)--   --dict:27/29(L)--   --dict:112/198(L)--
Current allocation mode is local
Current file position is 9187
GPL Ghostscript 8.62: Unrecoverable error, exit code 1

shell returned 1

Press ENTER or type command to continue
</span><code><span class="diff-add">75 {JNZ}
19 43 {w BX INC}
83 {is f immed}
fb 64 CMP
76 {JBE}
da f4 {HLT}
.........
Hello, world!
0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~


################################################################################
##                                                                            ##
##  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987                          ##
##                                                                            ##
##  0 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400     ##
##                                                                            ##
##  2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97    ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
################################################################################





GS&lt;1&gt;
</span></code></pre>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <del>531</del> <em><span class="diff-delete">222</span></em> <span class="diff-delete">lines</span>)</h1><div class="diff-skipped"><div></div></div><pre><code>%!
%a8086.ps Draught2:BREVITY
[/NULL&lt;0000&gt;/nul 0
/mem 16#ffff string %16-bit memory
/CF 0 /OF 0 /AF 0 /ZF 0 /SF 0
/regs 20 string &gt;&gt;begin %register byte storage
0{AL AH CL CH DL DH BL BH}{regs 2 index 1 getinterval def 1 add}forall pop
0{AX CX DX BX SP BP SI DI IP FL}{regs 2 index 2 getinterval def 2 add}forall pop

%getting and fetching
[/*b{0 get} %get byte from pointer
/*w{dup *b exch 1 get bbw} %get word from pointer
/*{{*b *w}W get exec} %get data(W) from pointer
/bbw{8 bitshift add} %lo-byte hi-byte -&gt; word
/shiftmask{2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and}
/fetchb{IP *w mem exch get bytedump   IP dup *w 1 add storew} % byte(IP++)
/fetchw{fetchb fetchb bbw} % word(IP),IP+=2

%storing and accessing
/storeb{16#ff and 0 exch put} % ptr val8 -&gt; -
/storew{2 copy storeb -8 bitshift 16#ff and 1 exch put} % ptr val16 -&gt; -
/stor{{storeb storew}W get exec} % ptr val(W) -&gt; -
/memptr{mem exch {1 2}W get getinterval} % addr -&gt; ptr(W)

%decoding the mod-reg-reg/mem byte
/mrm{fetchb 3 shiftmask /RM exch def 3 shiftmask /REG exch def /MOD exch def}
/REGTAB[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]
/decreg{REGTAB W get REG get} % REGTAB[W][REG]
%2 indexes,   with immed byte,   with immed word
/2*w{exch *w exch *w add}/fba{fetchb add}/fwa{fetchw add}
/RMTAB[[{BX SI 2*w}{BX DI 2*w}{BP SI 2*w}{BP DI 2*w}
    {SI *w}{DI *w}{fetchw}{BX *w}]
[{BX SI 2*w fba}{BX DI 2*w fba}{BP SI 2*w fba}{BP DI 2*w fba}
    {SI *w fba}{DI *w fba}{BP *w fba}{BX *w fba}]
[{BX SI 2*w fwa}{BX DI 2*w fwa}{BP SI 2*w fwa}{BP DI 2*w fwa}
    {SI *w fwa}{DI *w fwa}{BP *w fwa}{BX *w fwa}]]
/decrm{MOD 3 eq{REGTAB W get RM get} %MOD=3:register mode
    {RMTAB MOD get RM get exec memptr}ifelse} % RMTAB[MOD][RM] -&gt; addr -&gt; ptr

%setting and storing flags
/flagw{OF 11 bitshift SF 7 bitshift or ZF 6 bitshift or AF 4 bitshift CF or}
/wflag{dup 1 and /CF exch def dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def}
/nz1{0 ne{1}{0}ifelse}
/logflags{/CF 0 def /OF 0 def /AF 0 def %clear mathflags
    dup {16#80 16#8000}W get and nz1 /SF exch def
    dup {16#ff 16#ffff}W get and 0 eq{1}{0}ifelse /ZF exch def}
/mathflags{{z y x}{exch def}forall
    /CF z {16#ff00 16#ffff0000}W get and nz1 def
    /OF z x xor z y xor and {16#80 16#8000}W get and nz1 def
    /AF x y xor z xor 16#10 and nz1 def
    z} %leave the result on stack

%opcodes (each followed by 'stor')  %% { OPTAB fetchb get exec stor } loop
/ADD{2 copy add logflags mathflags}
/OR{or logflags}
/ADC{CF add ADD}
/SBB{D 1 xor {exch}repeat CF add 2 copy sub logflags mathflags}
/AND{and logflags}
/SUB{D 1 xor {exch}repeat 2 copy sub logflags mathflags}
/XOR{xor logflags}
/CMP{3 2 roll pop NULL 3 1 roll SUB} %dummy stor target
/INC{t CF exch dup * 1 ADD 3 2 roll /CF exch def}
/DEC{t CF exch dup * 1 SUB 3 2 roll /CF exch def}
/PUSH{SP dup *w 2 sub storew   *w SP *w memptr exch}
/POP{SP *w memptr *w   SP dup *w 2 add storew}

/jrel{w {CBW IP *w add IP exch}{NULL exch}ifelse}
/JO{fetchb OF 1 eq jrel }
/JNO{fetchb OF 0 eq jrel }
/JB{fetchb CF 1 eq jrel }
/JNB{fetchb CF 0 eq jrel }
/JZ{fetchb ZF 1 eq jrel }
/JNZ{fetchb ZF 0 eq jrel }
/JBE{fetchb CF ZF or 1 eq jrel }
/JNBE{fetchb CF ZF or 0 eq jrel }
/JS{fetchb SF 1 eq jrel }
/JNS{fetchb SF 0 eq jrel }
/JL{fetchb SF OF xor 1 eq jrel }
/JNL{fetchb SF OF xor 0 eq jrel }
/JLE{fetchb SF OF xor ZF or 1 eq jrel }
/JNLE{fetchb SF OF xor ZF or 0 eq jrel }

/bw{dup 16#80 and 0 ne{16#ff xor 1 add 16#ffff xor 1 add}if}
/IMMTAB{ADD OR ADC SBB AND SUB XOR CMP }cvlit
/immed{<span class="diff-delete">mrm
   </span> <span class="diff-delete">{fetchb</span> <span class="diff-delete">fetchw</span> {<span class="diff-delete">fetchb bw</span> /W 1 def<span class="diff-delete">}}W</span> <span class="diff-delete">get</span> <span class="diff-delete">exec</span>
    decrm dup * <span class="diff-delete">3</span> <span class="diff-delete">2</span> <span class="diff-delete">roll</span> exch IMMTAB REG get exec }

%/TEST{ }
/XCHG{3 2 roll pop 2 copy exch * 4 2 roll * stor }
/AXCH{w dup AX XCHG }
/pMOV{D{exch}repeat pop }
/<span class="diff-delete">MOV</span>{ } <span class="diff-delete">%8-D</span>
/LEA{w mrm decreg RMTAB MOD get RM get exec }

/CBW{dup 16#80 and 0 ne {16#ff xor 1 add 16#ffff xor 1 add } if }
/CWD{dup 16#8000 and 0 ne {16#ffff xor 1 add neg } if }
/CALL{w xp /xp{}def fetchw IP PUSH storew IP dup *w 3 2 roll add dsp /dsp{}def }
%/WAIT{ }
/PUSHF{NULL dup flagw storew 2 copy PUSH }
/POPF{NULL dup POP *w wflag }
%/SAHF{ }
%/LAHF{ }

%/MOVS{ }
%/CMPS{ }
%/STOS{ }
%/LODS{ }
%/SCAS{ }
/RET{w IP POP storew SP dup * 3 2 roll add }
%/LES{ }
%/LDS{ }

/JMP{IP dup fetchw exch *w add<span class="diff-delete"> </span>}
/sJMP{IP dup fetchb exch *w add<span class="diff-delete"> </span>}

/HLT{<span class="diff-delete">stop</span>}
/CMC{/CF CF 1 xor def NULL nul}
/CLC{/CF 0 def NULL nul}
/STC{/CF 1 def NULL nul}

/NOT{not logflags }
/NEG{neg logflags }
/GRP1TAB{TEST --- NOT NEG MUL IMUL DIV IDIV } cvlit
/Grp1{mrm decrm dup * GRP1TAB REG get exec }
/GRP2TAB{INC DEC {id CALL}{l id CALL}{id JMP}{l id JMP} PUSH --- } cvlit
/Grp2{mrm decrm GRP2TAB REG get exec }

%optab shortcuts
/2*{exch * exch *}
/rm{mrm decreg decrm D index 3 1 roll 2*} % fetch,decode mrm -&gt; dest *reg *r-m
/rmp{mrm decreg decrm D index 3 1 roll} % fetch,decode mrm -&gt; dest reg r-m
/ia{ {{AL dup *b fetchb}{AX dup *w fetchw}}W get exec } %immed to accumulator
/is{/W 2 def}
/b{/W 0 def} %select byte operation
/w{/W 1 def} %select word operation
/t{/D 1 def} %dest = reg
/f{/D 0 def} %dest = r/m
/xp{} /dsp{}
%/far{ /xp { &lt;0000&gt; PUSH storew } /dsp { fetchw pop } def }
/i{ {fetchb fetchw}W get exec }

/OPTAB{
{b f rm ADD}{w f rm ADD}{b t rm ADD}{w t rm ADD}{b ia ADD}{w ia ADD}{ES PUSH}{ES POP} %00-07
 {b f rm OR}{w f rm OR}{b t rm OR}{w t rm OR}{b ia OR}{w ia OR}{CS PUSH}{}            %08-0F
{b f rm ADC}{w f rm ADC}{b t rm ADC}{w t rm ADC}{b ia ADC}{w ia ADC}{SS PUSH}{SS POP} %10-17
 {b f rm SBB}{w f rm SBB}{b t rm SBB}{w t rm SBB}{b ia SBB}{w ia SBB}{DS PUSH}{DS POP}%18-1F
{b f rm AND}{w f rm AND}{b t rm AND}{w t rm AND}{b ia AND}{w ia AND}{ES SEG}{DAA}     %20-27
 {b f rm SUB}{w f rm SUB}{b t rm SUB}{w t rm SUB}{b ia SUB}{w ia SUB}{CS SEG}{DAS}    %28-2F
{b f rm XOR}{w f rm XOR}{b t rm XOR}{w t rm XOR}{b ia XOR}{w ia XOR}{SS SEG}{AAA}     %30-37
 {b f rm CMP}{w f rm CMP}{b t rm CMP}{w t rm CMP}{b ia CMP}{w ia CMP}{DS SEG}{AAS}    %38-3F
{w AX INC}{w CX INC}{w DX INC}{w BX INC}{w SP INC}{w BP INC}{w SI INC}{w DI INC}      %40-47
 {w AX DEC}{w CX DEC}{w DX DEC}{w BX DEC}{w SP DEC}{w BP DEC}{w SI DEC}{w DI DEC}     %48-4F
{AX PUSH}{CX PUSH}{DX PUSH}{BX PUSH}{SP PUSH}{BP PUSH}{SI PUSH}{DI PUSH}              %50-57
 {AX POP}{CX POP}{DX POP}{BX POP}{SP POP}{BP POP}{SI POP}{DI POP}                     %58-5F
{}{}{}{}{}{}{}{}  {}{}{}{}{}{}{}{}                                                    %60-6F
{JO}{JNO}{JB}{JNB}{JZ}{JNZ}{JBE}{JNBE} {JS}{JNS}{JP}{JNP}{JL}{JNL}{JLE}{JNLE}         %70-7F

{b f immed}{w f immed}{b f immed}{is f immed}{b TEST}{w TEST}{b rmp XCHG}{w rmp XCHG}   %80-87
 {b f rm pMOV}{w f rm pMOV}{b t rm pMOV}{w t rm pMOV}                                 %88-8B
   {sr f rm pMOV}{LEA}{sr t rm pMOV}{w mrm decrm POP}                                 %8C-8F
{<span class="diff-delete">AX AXCH</span>}{CX AXCH}{DX AXCH}{BX AXCHG}{SP AXCH}{BP AXCH}{SI AXCH}{DI AXCH}             %90-97
 {CBW}{CWD}{far CALL}{WAIT}{PUSHF}{POPF}{SAHF}{LAHF}                                  %98-9F
{b AL m MOV}{w AX m MOV}{b m AL MOV}{b AX m MOV}{MOVS}{MOVS}{CMPS}{CMPS}              %A0-A7
 {b i a TEST}{w i a TEST}{STOS}{STOS}{LODS}{LODS}{SCAS}{SCAS}                         %A8-AF
{b AL i MOV}{b CL i MOV}{b DL i MOV}{b BL i MOV}                                      %B0-B3
 {b AH i MOV}{b CH i MOV}{b DH i MOV}{b BH i MOV}                                     %B4-B7
 {w AX i MOV}{w CX i MOV}{w DX i MOV}{w BX i MOV}                                     %B8-BB
 {w SP i MOV}{w BP i MOV}{w SI i MOV}{w DI i MOV}                                     %BC-BF
{}{}{fetchw RET}{0 RET}{LES}{LDS}{b <span class="diff-delete">i</span> rm <span class="diff-delete">MOV</span>}{w <span class="diff-delete">i</span> rm<span class="diff-delete"> MOV}   </span> <span class="diff-delete"> </span>                        %C0-B7
 {}{}{fetchw RET}{0 RET}{3 INT}{fetchb INT}{INTO}{IRET}                               %C8-CF
{b Shift}{w Shift}{b v Shift}{w v Shift}{AAM}{AAD}{}{XLAT}                            %D0-D7
 {0 ESC}{1 ESC}{2 ESC}{3 ESC}{4 ESC}{5 ESC}{6 ESC}{7 ESC}                             %D8-DF
{LOOPNZ}{LOOPZ}{LOOP}{JCXZ}{b IN}{w IN}{b OUT}{w OUT}                                 %E0-E7
 {CALL}{JMP}{far JMP}{sJMP}{v b IN}{v w IN}{v b OUT}{v w OUT}                         %E8-EF
{LOCK}{}{REP}{z REP}{HLT}{CMC}{b Grp1}{w Grp}                                         %F0-F7
 {CLC}{STC}{CLI}{STI}{CLD}{STD}{b Grp2}{w Grp2}                                       %F8-FF
}cvlit

/stdout(%stdout)(w)file
/bytedump{ &lt;00&gt; dup 0 3 index put stdout exch writehexstring ( )print }
/regdump{ REGTAB 1 get{ stdout exch writehexstring ( )print }forall
    stdout IP writehexstring ( )print
    {(NC )(CA )}CF get print
    {(NO )(OV )}OF get print
    {(NS )(SN )}SF get print
    {(NZ )(ZR )}ZF get print (\n)print<span class="diff-delete"> </span>}
/mainloop{{
    <span class="diff-delete">regdump</span>
    OPTAB fetchb get
    dup ==
    exec
    <span class="diff-delete">pstack</span>
    stor
    /ic ic 1 add def ictime
}loop}

/printvideo{
    0 1 <span class="diff-delete">24</span> {
        80 mul 16#8000 add mem exch 80 getinterval {
            dup 0 eq { pop 32 } if
            stdout exch write
        } forall (\n)print
    } for
    (\n)print
}
/ic 0
/ictime{ic 10 mod 0 eq {onq} if}
/timeq 10
/onq{<span class="diff-delete">printvideo</span>}
&gt;&gt;begin<span class="diff-delete"> </span>currentdict{<span class="diff-delete">
    </span>dup type/arraytype eq 1 index xcheck and {bind def}{pop pop}ifelse<span class="diff-delete"> </span>}forall

SP 16#100 storew
(codegolf.8086)(r)file mem readstring pop
pop[

mainloop

%eof
</code></pre><p> And<span class="diff-delete"> we're back to square 2 with</span> the output<span class="diff-delete">. It's crashing on one of</span> the<span class="diff-delete"> MOV permutations</span>.</p><pre><span class="diff-delete">7e01 0000 0000 0080 fc0f 0000 0000 beff 7a01 CA NO NS NZ
5b {BX POP}
114
(\000\200)
-mark-
7e01 0000 0000 7200 fe0f 0000 0000 beff 7b01 CA NO NS NZ
c3 {0 RET}
4096
(\000\020)
-mark-
.........
Hello, world!
0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~























7e01 0000 0000 7200 0010 0000 0000 beff 9200 CA NO NS NZ
fe {b Grp2}
c0 127
(~)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9400 CA NO NS NZ
3c {b ia CMP}
7f 0
(\377\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9600 NC NO NS ZR
75 {JNZ}
f7 247
(\000\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9800 NC NO NS ZR
b0 {b AL i MOV}
23 35
(\177)
-mark-
2301 0000 0000 7200 0010 0000 0000 beff 9a00 NC NO NS ZR
c7 {w i rm MOV}
06 d3 01 Error: /rangecheck in --getinterval--
Operand stack:
   --nostringval--   54022   (#\001)   (\201\374\000\001t\001\364\274\000\020\260.\273\000\000K\203\373\377u\361\350Q\001Cu\353\350K\0011\311\t\313u\342r\340\350@\001\271\000\2009\331v\326\3506\001\001\313r\317\350/\001\001\333\203\321\000y\305r\303Q\203\341\001t\275\350\035\001Y\371\273\000\200\031\331u\261r\257\350\017\001\350\000\000[\201\373]\000u\242\201\374\000\020u\234\350\374\000\273r\000S\303\201\374\000\020u\216\350\356\000\220\220\220\353\001\364\350\370\000\270\305\001\350\312\000\350\357\000\2600\350\327\000\376\300\323\001\340\001u\n\261P\307\006\323\001\200\007\353\347\307\006\323\001\340\001\261\022\350\243\000\350\240...)   65584   2
Execution stack:
   %interp_exit   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   --nostringval--   false   1   %stopped_push   1905   1   3   %oparray_pop   1904   1   3   %oparray_pop   1888   1   3   %oparray_pop   1771   1   3   %oparray_pop   --nostringval--   %errorexec_pop   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   %loop_continue   --nostringval--   --nostringval--   --nostringval--
Dictionary stack:
   --dict:1152/1684(ro)(G)--   --dict:0/20(G)--   --dict:92/200(L)--   --dict:27/29(L)--   --dict:112/198(L)--
Current allocation mode is local
Current file position is 9187
GPL Ghostscript 8.62: Unrecoverable error, exit code 1

shell returned 1

Press ENTER or type command to continue
</span></pre>
            </div>
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <del>531</del> <del><em><span class="diff-add">222</span></em></del> <span class="diff-add">246 lines</span>)</h1><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Runs the test program, again! The final few bugs for the shorter re-write were neglecting to sign-extend the immediate byte in opcodes 83 (the "Immediate" group) and EB (short JMP). 24-line increase covers additional debugging routines needed to track down those final bugs.</span></p><pre><code>%!
%a8086.ps Draught2:BREVITY
[/NULL&lt;0000&gt;/nul 0
/mem 16#ffff string %16-bit memory
/CF 0 /OF 0 /AF 0 /ZF 0 /SF 0
/regs 20 string &gt;&gt;begin %register byte storage
0{AL AH CL CH DL DH BL BH}{regs 2 index 1 getinterval def 1 add}forall pop
0{AX CX DX BX SP BP SI DI IP FL}{regs 2 index 2 getinterval def 2 add}forall pop

%getting and fetching
[/*b{0 get} %get byte from pointer
/*w{dup *b exch 1 get bbw} %get word from pointer
/*{{*b *w}W get exec} %get data(W) from pointer
/bbw{8 bitshift add} %lo-byte hi-byte -&gt; word
/shiftmask{2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and}
/fetchb{IP *w mem exch get bytedump   IP dup *w 1 add storew} % byte(IP++)
/fetchw{fetchb fetchb bbw} % word(IP),IP+=2

%storing and accessing
/storeb{16#ff and 0 exch put} % ptr val8 -&gt; -
/storew{2 copy storeb -8 bitshift 16#ff and 1 exch put} % ptr val16 -&gt; -
/stor{{storeb storew}W get exec} % ptr val(W) -&gt; -
/memptr{<span class="diff-add">16#ffff and </span>mem exch {1 2}W get getinterval} % addr -&gt; ptr(W)

%decoding the mod-reg-reg/mem byte
/mrm{fetchb 3 shiftmask /RM exch def 3 shiftmask /REG exch def /MOD exch def}
/REGTAB[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]
/decreg{REGTAB W get REG get} % REGTAB[W][REG]
%2 indexes,   with immed byte,   with immed word
/2*w{exch *w exch *w add}/fba{fetchb add}/fwa{fetchw add}
/RMTAB[[{BX SI 2*w}{BX DI 2*w}{BP SI 2*w}{BP DI 2*w}
    {SI *w}{DI *w}{fetchw}{BX *w}]
[{BX SI 2*w fba}{BX DI 2*w fba}{BP SI 2*w fba}{BP DI 2*w fba}
    {SI *w fba}{DI *w fba}{BP *w fba}{BX *w fba}]
[{BX SI 2*w fwa}{BX DI 2*w fwa}{BP SI 2*w fwa}{BP DI 2*w fwa}
    {SI *w fwa}{DI *w fwa}{BP *w fwa}{BX *w fwa}]]
/decrm{MOD 3 eq{REGTAB W get RM get} %MOD=3:register mode
    {RMTAB MOD get RM get exec memptr}ifelse} % RMTAB[MOD][RM] -&gt; addr -&gt; ptr

%setting and storing flags
/flagw{OF 11 bitshift SF 7 bitshift or ZF 6 bitshift or AF 4 bitshift CF or}
/wflag{dup 1 and /CF exch def dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def}
/nz1{0 ne{1}{0}ifelse}
/logflags{/CF 0 def /OF 0 def /AF 0 def %clear mathflags
    dup {16#80 16#8000}W get and nz1 /SF exch def
    dup {16#ff 16#ffff}W get and 0 eq{1}{0}ifelse /ZF exch def}
/mathflags{{z y x}{exch def}forall
    /CF z {16#ff00 16#ffff0000}W get and nz1 def
    /OF z x xor z y xor and {16#80 16#8000}W get and nz1 def
    /AF x y xor z xor 16#10 and nz1 def
    z} %leave the result on stack

%opcodes (each followed by 'stor')  %% { OPTAB fetchb get exec stor } loop
/ADD{2 copy add logflags mathflags}
/OR{or logflags}
/ADC{CF add ADD}
/SBB{D 1 xor {exch}repeat CF add 2 copy sub logflags mathflags}
/AND{and logflags}
/SUB{D 1 xor {exch}repeat 2 copy sub logflags mathflags}
/XOR{xor logflags}
/CMP{3 2 roll pop NULL 3 1 roll SUB} %dummy stor target
/INC{t CF exch dup * 1 ADD 3 2 roll /CF exch def}
/DEC{t CF exch dup * 1 SUB 3 2 roll /CF exch def}
/PUSH{SP dup *w 2 sub storew   *w SP *w memptr exch}
/POP{SP *w memptr *w   SP dup *w 2 add storew}

/jrel{w {CBW IP *w add IP exch}{NULL exch}ifelse}
/JO{fetchb OF 1 eq jrel }
/JNO{fetchb OF 0 eq jrel }
/JB{fetchb CF 1 eq jrel }
/JNB{fetchb CF 0 eq jrel }
/JZ{fetchb ZF 1 eq jrel }
/JNZ{fetchb ZF 0 eq jrel }
/JBE{fetchb CF ZF or 1 eq jrel }
/JNBE{fetchb CF ZF or 0 eq jrel }
/JS{fetchb SF 1 eq jrel }
/JNS{fetchb SF 0 eq jrel }
/JL{fetchb SF OF xor 1 eq jrel }
/JNL{fetchb SF OF xor 0 eq jrel }
/JLE{fetchb SF OF xor ZF or 1 eq jrel }
/JNLE{fetchb SF OF xor ZF or 0 eq jrel }

/bw{dup 16#80 and 0 ne{16#ff xor 1 add 16#ffff xor 1 add}if}
/IMMTAB{ADD OR ADC SBB AND SUB XOR CMP }cvlit
/immed{ <span class="diff-add">W</span> <span class="diff-add">2</span> <span class="diff-add">eq</span>{ /W 1 def<span class="diff-add">&nbsp;
</span>  <span class="diff-add">          mrm decrm dup * fetchb bw</span>
    <span class="diff-add">}{ mrm </span>decrm dup * <span class="diff-add">{fetchb</span> <span class="diff-add">fetchw}W</span> <span class="diff-add">get</span> <span class="diff-add">exec }ifelse
    </span>exch IMMTAB REG get<span class="diff-add"> dup ==</span> exec }

%/TEST{ }
/XCHG{3 2 roll pop 2 copy exch * 4 2 roll * stor }
/AXCH{w dup AX XCHG }
<span class="diff-add">/NOP{ NULL nul }
</span>/pMOV{D{exch}repeat pop }
/<span class="diff-add">mMOV</span>{<span class="diff-add"> 3 1 roll pop</span> <span class="diff-add">pop </span>}<span class="diff-add">
/MOV{</span> <span class="diff-add">}</span>
/LEA{w mrm decreg RMTAB MOD get RM get exec }

/CBW{dup 16#80 and 0 ne {16#ff xor 1 add 16#ffff xor 1 add } if }
/CWD{dup 16#8000 and 0 ne {16#ffff xor 1 add neg } if }
/CALL{w xp /xp{}def fetchw IP PUSH storew IP dup *w 3 2 roll add dsp /dsp{}def }
%/WAIT{ }
/PUSHF{NULL dup flagw storew 2 copy PUSH }
/POPF{NULL dup POP *w wflag }
%/SAHF{ }
%/LAHF{ }

%/MOVS{ }
%/CMPS{ }
%/STOS{ }
%/LODS{ }
%/SCAS{ }
/RET{w IP POP storew SP dup * 3 2 roll add }
%/LES{ }
%/LDS{ }

/JMP{IP dup fetchw exch *w add}
/sJMP{IP dup fetchb<span class="diff-add"> bw</span> exch *w add}

/HLT{<span class="diff-add">exit</span>}
/CMC{/CF CF 1 xor def NULL nul}
/CLC{/CF 0 def NULL nul}
/STC{/CF 1 def NULL nul}

/NOT{not logflags }
/NEG{neg logflags }
/GRP1TAB{TEST --- NOT NEG MUL IMUL DIV IDIV } cvlit
/Grp1{mrm decrm dup * GRP1TAB REG get<span class="diff-add">
dup</span> <span class="diff-add">==
</span>exec }
/GRP2TAB{INC DEC {id CALL}{l id CALL}{id JMP}{l id JMP} PUSH --- } cvlit
/Grp2{mrm decrm GRP2TAB REG get<span class="diff-add">
dup</span> <span class="diff-add">==
</span>exec }

%optab shortcuts
/2*{exch * exch *}
/rm{mrm decreg decrm D index 3 1 roll 2*} % fetch,decode mrm -&gt; dest *reg *r-m
/rmp{mrm decreg decrm D index 3 1 roll} % fetch,decode mrm -&gt; dest reg r-m
/ia{ {{AL dup *b fetchb}{AX dup *w fetchw}}W get exec } %immed to accumulator
/is{/W 2 def}
/b{/W 0 def} %select byte operation
/w{/W 1 def} %select word operation
/t{/D 1 def} %dest = reg
/f{/D 0 def} %dest = r/m
/xp{} /dsp{}
%/far{ /xp { &lt;0000&gt; PUSH storew } /dsp { fetchw pop } def }
/i{ {fetchb fetchw}W get exec }

/OPTAB{
{b f rm ADD}{w f rm ADD}{b t rm ADD}{w t rm ADD}{b ia ADD}{w ia ADD}{ES PUSH}{ES POP} %00-07
 {b f rm OR}{w f rm OR}{b t rm OR}{w t rm OR}{b ia OR}{w ia OR}{CS PUSH}{}            %08-0F
{b f rm ADC}{w f rm ADC}{b t rm ADC}{w t rm ADC}{b ia ADC}{w ia ADC}{SS PUSH}{SS POP} %10-17
 {b f rm SBB}{w f rm SBB}{b t rm SBB}{w t rm SBB}{b ia SBB}{w ia SBB}{DS PUSH}{DS POP}%18-1F
{b f rm AND}{w f rm AND}{b t rm AND}{w t rm AND}{b ia AND}{w ia AND}{ES SEG}{DAA}     %20-27
 {b f rm SUB}{w f rm SUB}{b t rm SUB}{w t rm SUB}{b ia SUB}{w ia SUB}{CS SEG}{DAS}    %28-2F
{b f rm XOR}{w f rm XOR}{b t rm XOR}{w t rm XOR}{b ia XOR}{w ia XOR}{SS SEG}{AAA}     %30-37
 {b f rm CMP}{w f rm CMP}{b t rm CMP}{w t rm CMP}{b ia CMP}{w ia CMP}{DS SEG}{AAS}    %38-3F
{w AX INC}{w CX INC}{w DX INC}{w BX INC}{w SP INC}{w BP INC}{w SI INC}{w DI INC}      %40-47
 {w AX DEC}{w CX DEC}{w DX DEC}{w BX DEC}{w SP DEC}{w BP DEC}{w SI DEC}{w DI DEC}     %48-4F
{AX PUSH}{CX PUSH}{DX PUSH}{BX PUSH}{SP PUSH}{BP PUSH}{SI PUSH}{DI PUSH}              %50-57
 {AX POP}{CX POP}{DX POP}{BX POP}{SP POP}{BP POP}{SI POP}{DI POP}                     %58-5F
{}{}{}{}{}{}{}{}  {}{}{}{}{}{}{}{}                                                    %60-6F
{JO}{JNO}{JB}{JNB}{JZ}{JNZ}{JBE}{JNBE} {JS}{JNS}{JP}{JNP}{JL}{JNL}{JLE}{JNLE}         %70-7F

{b f immed}{w f immed}{b f immed}{is f immed}{b TEST}{w TEST}{b rmp XCHG}{w rmp XCHG}   %80-87
 {b f rm pMOV}{w f rm pMOV}{b t rm pMOV}{w t rm pMOV}                                 %88-8B
   {sr f rm pMOV}{LEA}{sr t rm pMOV}{w mrm decrm POP}                                 %8C-8F
{<span class="diff-add">NOP</span>}{CX AXCH}{DX AXCH}{BX AXCHG}{SP AXCH}{BP AXCH}{SI AXCH}{DI AXCH}             %90-97
 {CBW}{CWD}{far CALL}{WAIT}{PUSHF}{POPF}{SAHF}{LAHF}                                  %98-9F
{b AL m MOV}{w AX m MOV}{b m AL MOV}{b AX m MOV}{MOVS}{MOVS}{CMPS}{CMPS}              %A0-A7
 {b i a TEST}{w i a TEST}{STOS}{STOS}{LODS}{LODS}{SCAS}{SCAS}                         %A8-AF
{b AL i MOV}{b CL i MOV}{b DL i MOV}{b BL i MOV}                                      %B0-B3
 {b AH i MOV}{b CH i MOV}{b DH i MOV}{b BH i MOV}                                     %B4-B7
 {w AX i MOV}{w CX i MOV}{w DX i MOV}{w BX i MOV}                                     %B8-BB
 {w SP i MOV}{w BP i MOV}{w SI i MOV}{w DI i MOV}                                     %BC-BF
{}{}{fetchw RET}{0 RET}{LES}{LDS}{b <span class="diff-add">f</span> rm <span class="diff-add">i mMOV</span>}{w <span class="diff-add">f</span> rm <span class="diff-add">i</span> <span class="diff-add">mMOV}</span>                       %C0-B7
 {}{}{fetchw RET}{0 RET}{3 INT}{fetchb INT}{INTO}{IRET}                               %C8-CF
{b Shift}{w Shift}{b v Shift}{w v Shift}{AAM}{AAD}{}{XLAT}                            %D0-D7
 {0 ESC}{1 ESC}{2 ESC}{3 ESC}{4 ESC}{5 ESC}{6 ESC}{7 ESC}                             %D8-DF
{LOOPNZ}{LOOPZ}{LOOP}{JCXZ}{b IN}{w IN}{b OUT}{w OUT}                                 %E0-E7
 {CALL}{JMP}{far JMP}{sJMP}{v b IN}{v w IN}{v b OUT}{v w OUT}                         %E8-EF
{LOCK}{}{REP}{z REP}{HLT}{CMC}{b Grp1}{w Grp}                                         %F0-F7
 {CLC}{STC}{CLI}{STI}{CLD}{STD}{b Grp2}{w Grp2}                                       %F8-FF
}cvlit

<span class="diff-add">/break{ /hook /pause load def }
/c{ /hook {} def }
/doprompt{
    (\nbreak&gt;)print
    flush(%lineedit)(r)file
    cvx {exec}stopped pop }
/pause{ doprompt }
/hook{}

</span>/stdout(%stdout)(w)file
/bytedump{ &lt;00&gt; dup 0 3 index put stdout exch writehexstring ( )print }
/regdump{ REGTAB 1 get{ stdout exch writehexstring ( )print }forall
    stdout IP writehexstring ( )print
    {(NC )(CA )}CF get print
    {(NO )(OV )}OF get print
    {(NS )(SN )}SF get print
    {(NZ )(ZR )}ZF get print<span class="diff-add">
    stdout 16#1d3 w</span> <span class="diff-add">memptr writehexstring
    </span>(\n)print<span class="diff-add">&nbsp;
</span>}
/mainloop{{
    <span class="diff-add">%regdump</span>
    OPTAB fetchb get
    dup ==
    exec
    <span class="diff-add">%pstack flush
    %hook</span>
    stor
    /ic ic 1 add def ictime
}loop}

/printvideo{
    0 1 <span class="diff-add">28</span> {
        80 mul 16#8000 add mem exch 80 getinterval {
            dup 0 eq { pop 32 } if
<span class="diff-add">                    dup 32 lt 1 index 126 gt or { pop 46 } if
</span>            stdout exch write
        } forall (\n)print
    } for
    (\n)print
}
/ic 0
/ictime{ic 10 mod 0 eq {onq} if}
/timeq 10
/onq{<span class="diff-add"> %printvideo
</span>}
&gt;&gt;begin<span class="diff-add">&nbsp;
</span>currentdict{dup type/arraytype eq 1 index xcheck and<span class="diff-add">&nbsp;
</span> <span class="diff-add">   </span>{bind def}{pop pop}ifelse}forall

SP 16#100 storew
(codegolf.8086)(r)file mem readstring pop
pop[

mainloop<span class="diff-add">
printvideo</span>

%eof
</code></pre><p> And the output<span class="diff-add"> (with</span> the<span class="diff-add"> tail-end of abbreviated debugging output)</span>.<span class="diff-add">&nbsp; </span></p><pre><code><span class="diff-add">75 {JNZ}
19 43 {w BX INC}
83 {is f immed}
fb 64 CMP
76 {JBE}
da f4 {HLT}
.........
Hello, world!
0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~


################################################################################
##                                                                            ##
##  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987                          ##
##                                                                            ##
##  0 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400     ##
##                                                                            ##
##  2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97    ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
##                                                                            ##
################################################################################





GS&lt;1&gt;
</span></code></pre>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-a1c7ea68-2d3c-4322-a5e2-5bc4e8fe4186">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('4b29d81e-ad3a-4b66-82dd-0caed848e0c5') ">
                        <span id="rev-arrow-4b29d81e-ad3a-4b66-82dd-0caed848e0c5" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('4b29d81e-ad3a-4b66-82dd-0caed848e0c5') ">
                        <span title="revision 6">6</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">do-over</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/4b29d81e-ad3a-4b66-82dd-0caed848e0c5/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/6" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-12-11 11:20:26Z" class="relativetime">Dec 11 '12 at 11:20</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev4b29d81e-ad3a-4b66-82dd-0caed848e0c5" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <span class="diff-delete">531 lines</span><del><span class="diff-add">531</span></del> <em><span class="diff-add">222</span></em> <span class="diff-add">lines</span>)</h1><p><em><span class="diff-delete">Latest version runs test program to completion!</span></em></p><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Total re-write from scratch using the concise table from the manual (</span><em><span class="diff-add">turned a new page!</span></em><span class="diff-add">). I'm starting to think that factoring-out the </span><em><span class="diff-add">store</span></em> <span class="diff-add">from the opcodes was a bad idea, but it helped keep the optab pretty. No screenshot this time. I added an instruction counter and a mod-trigger to dump the video memory, so it interleaves easily with the debug info.</span></p><pre><code>%!
<span class="diff-delete">%8086 Emulator
/debug true def
/trace false def
/bytedump { dup 16#100 add 16 3 string cvrs 1 2 getinterval ==only } def

%sign-extend byte or word to PS integer (32-bit)
/bext { dup 16#80 and 0 ne { not 16#ff and 1 add neg } if } def
/wext { dup 16#8000 and 0 ne { not 16#ffff and 1 add neg } if } def

/signb { 16#80 and 0 ne } def
/signw { 16#8000 and 0 ne } def

/negb { 16#FF xor 1 add } def
/negw { 16#FFFF xor 1 add } def

%extend byte to word
/byteword { dup signb { negb negw } if } def
/wordquad { dup signw { negw neg } if } def

%memory and register byte-strings
/mem 16#FFFF string def
/reg 20 string def
%register pointers
0 {AL AH CL CH DL DH BL BH}{reg 2 index 1 getinterval def 1 add}forall pop
0 {AX CX DX BX SP BP SI DI IP FL}{reg 2 index 2 getinterval def 2 add}forall pop
/CF 0 def
/AF 0 def
/OF 0 def
/SF 0 def
/ZF 0 def

/memb { 16#ffff mod mem exch 1 getinterval } def
/memw { 16#ffff mod mem exch 2 getinterval } def

%load byte or word from a "pointer" (substring)
/getb { 0 get } def
/getw { dup getb exch 1 get 8 bitshift add } def

%store byte or word through a "pointer"
/storeb { 16#ff and 0 exch put } def
/storew { 2 copy storeb -8 bitshift 16#ff and 1 exch put } def

%shift and mask a bitfield off the bottom of an integer
/shiftmask { 2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and } def

%load byte or word from mem[IP++]
/fetchb { IP getw memb getb
    %bytedump
    debug {bytedump} if
    IP dup getw 1 add storew } def
/fetchw { fetchb fetchb 8 bitshift add } def

%decoding tables
%REGT[W][REG] -&gt; pointer
/REGT[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]def
/R-MT[[{BX getw SI getw add} %R-MT[MOD][R-M] -&gt; {pointer}
    {BX getw DI getw add}
    {BP getw SI getw add}
    {BP getw DI getw add}
    {SI getw}
    {DI getw}
    {fetchw}
    {BX getw}]
[{BX getw SI getw fetchb add add}
    {BX getw DI getw fetchb add add}
    {BP getw SI getw fetchb add add}
    {BP getw DI getw fetchb add add}
    {SI getw fetchb add}
    {DI getw fetchb add}
    {BP getw fetchb add}
    {BX getw fetchb add}]
[{BX getw SI getw fetchw add add}
    {BX getw DI getw fetchw add add}
    {BP getw SI getw fetchw add add}
    {BP getw DI getw fetchw add add}
    {SI getw fetchw add}
    {DI getw fetchw add}
    {BP getw fetchw add}
    {BX getw fetchw add}]]def

/w-d{{W D}{exch def}forall} def %assign W and D
/r-m{ %fetch and parse the MOD-REG-R/M byte
    fetchb
    3 shiftmask /R-M exch def
    3 shiftmask /REG exch def
    /MOD exch def} def
/decreg { REGT W get REG get } def
/decr-m { MOD 3 eq { REGT W get R-M get }{
        R-MT MOD get R-M get exec
        {memb memw}W get exec
    } ifelse } def
/opands { %decode the operands -&gt; (REG) (R/M)
    decreg
    decr-m
} def
/dest { % (REG) (R/M) -&gt; (DEST) (REG) (R/M)
    D index % 1:REG 0:R-M
    3 1 roll } def

%fetch&amp;decode M-R-R/M byte, -&gt; DEST REG R/M
/byteop { r-m opands dest
    exch getb %bext
    exch getb %bext
} def
/wordop { r-m opands dest
    exch getw %wext
    exch getw %wext
} def
/doop {{byteop wordop}W get exec} def

/setCF { dup
    {7 15}W get shiftmask pop
    dup 1 and exch -1 bitshift 1 and % _8|16 _9|17
        %dup /CF exch def
        2 copy ne {1}{0} ifelse /CF exch def
    xor /OF exch def
} def

/setZF { dup 0 eq {/ZF 1 def}{/ZF 0 def} ifelse } def
/setSF { dup {-7 -15}W get bitshift 1 and /SF exch def } def
/setF { setZF setSF } def
/logF { setF /CF 0 def /OF 0 def } def %logical operators clear OF+CF

/nz1 { 0 ne{1}{0}ifelse } def %nonzero to 1
/arithF {
    /CF c {16#ff00 16#ffff0000}W get and nz1 def
    /OF c a xor c b xor and {16#80 16#8000}W get and nz1 def
    /AF a b xor c xor 16#10 and nz1 def
} def
/ADD {
    debug {()= pstack} if
    {b a}{exch def}forall
    /c a b add def
    c arithF setF
} def
/SUB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b sub def
    c arithF setF
} def
/SBB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b CF add sub def
    c arithF setF
} def

%OPCODEs
%/ADD { add setF } def
16#00{ 0 0 w-d doop ADD storeb } def %ADDB R/M,REG
16#01{ 0 1 w-d doop ADD storew } def %ADDW R/M,REG
16#02{ 1 0 w-d doop ADD storeb } def %ADDB REG,R/M
16#03{ 1 1 w-d doop ADD storew } def %ADDW REG,R/M
16#04{ 0 0 w-d AL dup getb fetchb ADD storeb } def %ADDB AL,immed8
16#05{ 0 1 w-d AX dup getw fetchw ADD storew } def %ADDW AX,immed16
%06 PUSH ES
%07 POP ES
/OR { or logF } def
16#08{ 0 0 w-d doop OR storeb } def %OR R/M,REG
16#09{ 0 1 w-d doop OR storew } def %OR R/M,REG
16#0A{ 1 0 w-d doop OR storeb } def %OR REG,R/M
16#0B{ 1 1 w-d doop OR storew } def %OR REG,R/M
16#0C{ 0 0 w-d AL dup getb fetchb OR storeb } def %OR AL,immed8
16#0D{ 0 1 w-d AX dup getw fetchw OR storew } def %OR AX,immed16
%0E PUSH CS
%0F (not used)

/ADC { CF add ADD } def
16#10{ 0 0 w-d doop ADC storeb } def %ADC R/M,REG
16#11{ 0 1 w-d doop ADC storew } def %ADC R/M,REG
16#12{ 1 0 w-d doop ADC storeb } def %ADC REG,R/M
16#13{ 1 1 w-d doop ADC storew } def %ADC REG,R/M
16#14{ 0 0 w-d AL dup getb fetchb ADC storeb } def %ADC AL,immed8
16#15{ 0 1 w-d AX dup getw fetchw ADC storew } def %ADC AX,immed16
%16 PUSH SS
%17 POP SS
%/SBB { D 1 eq{exch}if sub CF sub setF } def
16#18{ 0 0 w-d doop SBB storeb } def %SBB R/M,REG
16#19{ 0 1 w-d doop SBB storew } def %SBB R/M,REG
16#1A{ 1 0 w-d doop SBB storeb } def %SBB REG,R/M
16#1B{ 1 1 w-d doop SBB storew } def %SBB REG,R/M
16#1C{ 0 0 w-d AL dup getb fetchb SBB storeb } def %SBB AL,immed8
16#1D{ 0 1 w-d AX dup getw fetchw SBB storew } def %SBB AX,immed16
%1E PUSH DS
%1F POP DS

/AND { and logF } def
16#20{ 0 0 w-d doop AND storeb } def %AND R/M,REG
16#21{ 0 1 w-d doop AND storew } def %AND R/M,REG
16#22{ 1 0 w-d doop AND storeb } def %AND REG,R/M
16#23{ 1 1 w-d doop AND storew } def %AND REG,R/M
16#24{ 0 0 w-d AL dup getb fetchb AND storeb } def %AND AL,immed8
16#25{ 0 1 w-d AX dup getw fetchw AND storew } def %AND AX,immed16
%26 ES
%27 DAA
%/SUB { D{exch}repeat sub setF } def
16#28{ 0 0 w-d doop SUB storeb } def %SUB R/M,REG
16#29{ 0 1 w-d doop SUB storew } def %SUB R/M,REG
16#2A{ 1 0 w-d doop SUB storeb } def %SUB R/M,REG
16#2B{ 1 1 w-d doop SUB storew } def %SUB R/M,REG
16#2C{ 0 0 w-d AL dup getb fetchb SUB storeb } def %SUB AL,immed8
16#2D{ 0 1 w-d AX dup getw fetchw SUB storew } def %SUB AX,immed16
%2E CS:
%2F DAS

/XOR { xor logF } def
16#30{ 0 0 w-d doop xor storeb } def %XOR R/M,REG
16#31{ 0 1 w-d doop xor storew } def %XOR R/M,REG
16#32{ 1 0 w-d doop xor storeb } def %XOR REG,R/M
16#33{ 1 1 w-d doop xor storew } def %XOR REG,R/M
16#34{ 0 0 w-d AL dup getb fetchb xor storeb } def %XOR AL,immed8
16#35{ 0 1 w-d AX dup getw fetchw xor storew } def %XOR AX,immed16
%36 SS:
%37 AAA
/CMP {
    debug { regdump pstack()= } if
        SUB
        debug { dup = } if
        pop } def
16#38{ 0 0 w-d doop CMP pop } def %CMP R/M,REG
16#39{ 0 1 w-d doop CMP pop } def %CMP R/M,REG
16#3A{ 0 0 w-d doop CMP pop } def %CMP REG,R/M
16#3B{ 0 1 w-d doop CMP pop } def %CMP REG,R/M
16#3C{ 0 0 w-d AL dup getb fetchb CMP pop } def %CMP AL,immed8
16#3D{ 0 1 w-d AX dup getw fetchw CMP pop } def %CMP AX,immed16
%3E DS
%3F AAS

/INC { CF exch dup {{getb bext} {getw wext}}W get exec 1 ADD
    {storeb storew}W get exec /CF exch def } def
16#40{ 0 1 w-d AX INC } def
16#41{ 0 1 w-d CX INC } def
16#42{ 0 1 w-d DX INC } def
16#43{ 0 1 w-d BX INC } def
16#44{ 0 1 w-d SP INC } def
16#45{ 0 1 w-d BP INC } def
16#46{ 0 1 w-d SI INC } def
16#47{ 0 1 w-d DI INC } def
/DEC { CF exch dup {{getb bext} {getw wext}}W get exec 1 sub setF
    {storeb storew}W get exec /CF exch def } def
16#48{ 0 1 w-d AX DEC } def
16#49{ 0 1 w-d CX DEC } def
16#4A{ 0 1 w-d DX DEC } def
16#4B{ 0 1 w-d BX DEC } def
16#4C{ 0 1 w-d SP DEC } def
16#4D{ 0 1 w-d BP DEC } def
16#4E{ 0 1 w-d SI DEC } def
16#4F{ 0 1 w-d DI DEC } def

%/PUSH { SP DEC SP DEC getw mem SP getw 2 getinterval exch storew } def
/PUSH{ SP dup getw
    dup =
    2 sub storew
    getw SP getw memw exch storew
    %enter
    SP getw =
} def
16#50{ AX PUSH } def
16#51{ CX PUSH } def
16#52{ DX PUSH } def
16#53{ BX PUSH } def
16#54{ SP PUSH } def
16#55{ BP PUSH } def
16#56{ SI PUSH } def
16#57{ DI PUSH } def

%/POP { mem SP getw 2 getinterval getw storew SP INC SP INC } def
/POP { SP getw memw getw storew
    SP dup getw 2 add storew } def
16#58{ AX POP } def
16#59{ CX POP } def
16#5A{ DX POP } def
16#5B{ BX POP } def
16#5C{ SP POP } def
16#5D{ BP POP } def
16#5E{ SI POP } def
16#5F{ DI POP } def
%60-6F

/jrel { { bext IP getw add IP exch storew }{ pop } ifelse } def
%16#71 JNO short-label
16#72{ fetchb CF 1 eq jrel } def %JB/JNAE/JC short-label
16#73{ fetchb CF 0 eq jrel } def %JNB/JAE/JNC short-label
16#74{ fetchb ZF 1 eq jrel } def %JF/JZ short-label
16#75{ fetchb ZF 0 eq jrel } def %JNE/JNZ short-label
16#76{ fetchb CF ZF or 1 eq jrel } def %JBE/JNA short-label
16#77{ fetchb CF ZF or 0 eq jrel } def %JNBE/JA short-label
16#78{ fetchb SF 1 eq jrel } def %JS short-label
16#79{ fetchb SF 0 eq jrel } def %JNS short-label
%16#7A JP/JPE short-label
%16#7B JNP/JPO short-label
16#7C{ fetchb SF OF xor 1 eq jrel } def %JL/JNGE short-label
16#7D{ fetchb SF OF xor 0 eq jrel } def %JNL/JGE short-label
16#7E{ fetchb SF OF xor ZF or 1 eq jrel } def %JLE/JNG short-label
16#7F{ fetchb SF OF xor ZF or 0 eq jrel } def %JNLE/JG short-label

/CMPp{ CMP pop &lt;0000&gt; 0 } def
/OPEXT {ADD OR ADC SBB AND SUB XOR CMPp} cvlit def
16#80{ 0 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb bext fetchb bext
    OPEXT REG get exec storeb } def
16#81{ 0 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw wext fetchw wext
    OPEXT REG get exec storew } def

/UNU {pop} def %unused
/OPEX2 {ADD UNU ADC SBB UNU SUB UNU CMPp} cvlit def
16#82{ 1 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb %bext
        fetchb %bext
    OPEX2 REG get exec storeb } def
16#83{ 1 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw %wext
        fetchb byteword %bext
    OPEX2 REG get exec storew } def

%16#84 TEST
%16#85 TEST
/XCHG { 2 copy exch
    {getb getw}W get exec
    4 2 roll
    {getb getw}W get exec
    2{ {storeb storew}W get exec }repeat
} def
16#86{ 1 0 w-d r-m opands XCHG } def %XCHG REG8,R/M8
16#87{ 1 1 w-d r-m opands XCHG } def %XCHG REG16,R/M16
16#88{ 0 0 w-d r-m opands exch getb storeb } def %MOV R/M8,REG8
16#89{ 0 1 w-d r-m opands exch getw storew } def %MOV R/M16,REG16
16#8A{ 1 0 w-d r-m opands getb storeb } def %MOV REG8,R/M8
16#8B{ 1 1 w-d r-m opands getw storew } def %MOV REG16,R/M16
%16#8C MOV REG16,SEGREG
16#8D{ 0 1 w-d r-m REGT W get REG get load
    R-MT MOD get R-M get exec storew } def %LEA REG16,MEM16
%16#8E MOV SEGREG,REG16
/8FT { POP } cvlit def
16#8F{ 1 1 w-d r-m decr-m 8FT REG get exec } def %REG:0 = POP R/M16
16#90{ } def %NOP
16#91{ AX CX XCHG } def %XCHG AX,CX
16#92{ AX DX XCHG } def %XCHG AX,DX
16#93{ AX BX XCHG } def %XCHG AX,BX
16#94{ AX SP XCHG } def %XCHG AX,SP
16#95{ AX BP XCHG } def %XCHG AX,BP
16#96{ AX SI XCHG } def %XCHG AX,SI
16#97{ AX DI XCHG } def %XCHG AX,DI
16#98{ AX AL getb bext storew } def %CBW
16#99{ DX AX getw wext 16 shiftmask pop storew } def %CWD
16#9A{ fetchw fetchw &lt;0000&gt; PUSH pop IP getw PUSH IP exch storew
    %()=
} def %CALL FAR PROC
%16#9B %WAIT
/flagw {
    OF 11 bitshift
    SF 7 bitshift or
    ZF 6 bitshift or
    AF 4 bitshift or
    CF 0 bitshift or
} def
/wflag {
    dup  0 bitshift 1 and /CF exch def
    dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def
    dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def
    pop
} def
16#9C{ &lt;0000&gt; dup flagw storew PUSH } def %PUSHF
16#9D{ POP wflag } def %POPF
16#9E{ AH flagw storeb } def %SAHF
16#9F{ AH getb OF 11 bitshift or wflag } def %LAHF

16#A0{ AL mem fetchw get storeb } def %MOV AL,MEM8
16#A1{ AX mem fetchw 2 getinterval getw storew } def %MOV AX,MEM16
16#A2{ mem fetchw 1 getinterval AL getb storeb } def %MOV MEM8,AL
16#A3{ mem fetchw 2 getinterval AX getw storew } def %MOV MEM16,AX
%A4-AF MOVS CMPS TEST STOS LODS SCAS

16#B0{ AL fetchb storeb } def %MOV AL,immed8
16#B1{ CL fetchb storeb } def %MOV CL,immed8
16#B2{ DL fetchb storeb } def %MOV DL,immed8
16#B3{ BL fetchb storeb } def %MOV BL,immed8
16#B4{ AH fetchb storeb } def %MOV AH,immed8
16#B5{ CH fetchb storeb } def %MOV CH,immed8
16#B6{ DH fetchb storeb } def %MOV DH,immed8
16#B7{ BH fetchb storeb } def %MOV BH,immed8
16#B8{ AX fetchw storew } def %MOV AX,immed16
16#B9{ CX fetchw storew } def %MOV CX,immed16
16#BA{ DX fetchw storew } def %MOV DX,immed16
16#BB{ BX fetchw storew } def %MOV BX,immed16
16#BC{ SP fetchw storew } def %MOV SP,immed16
16#BD{ BP fetchw storew } def %MOV BP,immed16
16#BE{ SI fetchw storew } def %MOV SI,immed16
16#BF{ DI fetchw storew } def %MOV AX,immed16

%C0-C1 not used
16#C2{ IP POP SP fetchw SP getw add storew
    ()=
} def %RET immed16(intraseg)
16#C3{ IP POP
    ()=
    showvideo
    flushpage
    %enter
} def %RET (intraseg)
16#C4{ 1 0 w-d r-m decreg decr-m getw storew } def %LES
16#C5{ 1 1 w-d r-m decreg decr-m getw storew } def %LDS
16#C6{ 1 0 w-d r-m decr-m fetchb storeb } def %REG:0 = MOV MEM8,immed8
16#C7{ 1 1 w-d r-m decr-m fetchw storew } def %REG:0 = MOV MEM16,immed16
%C8-C9 not used
16#CA{ IP POP &lt;0000&gt; POP pop SP fetchw SP getw add storew
    ()=
} def %RET immed16(interseg)
16#CB{ IP POP &lt;0000&gt; POP pop
    ()=
} def %RET (interseg)
%CC INT 3
%CD INT immed8
%CE INTO
%CF IRET

16#E8{ fetchw IP PUSH IP getw add IP exch storew
    ()=
} def %CALL NEAR-PROC
16#E9{ fetchw IP getw add IP exch storew
    ()=
} def %JMP NEAR-LABEL
16#EA{ IP fetchw storew fetchw pop
    ()=
} def %JMP FAR-LABEL
16#EB{ fetchb bext IP getw add IP exch storew
    ()=
} def %JMP SHORT-LABEL

16#F4{ exit } def %HLT
16#F5{ /CF CF 1 xor def } def %CMC

/NOT { not } def
/NEG { neg } def
/F6T { TEST UNU NOT NEG MUL IMUL DIV IDIV } cvlit def
16#F6{ 1 0 w-d r-m decr-m dup getw F6T REG get exec storew } def

16#F8{ /CF 0 def } def %CLC
16#F9{ /CF 1 def } def %STC

/FET { INC DEC } cvlit def
16#FE{ 1 0 w-d r-m decr-m FET REG get exec } def
/FFT { INC DEC
    { IP PUSH IP exch getw storew } %CALL REG16/MEM15 (intra)
    { &lt;0000&gt; PUSH IP PUSH IP exch getw storew } %CALL MEM16 (intersegment)
    { IP exch getw storew } %JMP REG16/MEM15 (intra)
    { } %JMP MEM16 (intersegment)
    PUSH %PUSH MEM16
} cvlit def
16#FF{ 1 1 w-d r-m decr-m FFT REG get exec
    ()=
} def


/regdump {
    FL flagw storew
    0 2 reg length 2 sub {
        reg exch 2 getinterval
        (%stdout)(w) file
        exch
        writehexstring
        ( )print
    } for
    ()=
} def

%/= /== load def
%errordict/undefined{pop{}}put
%{

(cp437.ps)run
/CP437 14 selectfont

/showvideo {
    40 700 moveto
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval
        gsave show grestore
        0 -10 rmoveto
    } for
} def

/printvideo {
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval {
            dup 32 ge 1 index 126 le and {
                ( ) dup 0 4 3 roll put print
            }{
                ( )print
            }ifelse
        } forall
        (\n)print
</span><span class="diff-add">%a8086.ps Draught2:BREVITY
[/NULL&lt;0000&gt;/nul 0
/mem 16#ffff string %16-bit memory
/CF 0 /OF 0 /AF 0 /ZF 0 /SF 0
/regs 20 string &gt;&gt;begin %register byte storage
0{AL AH CL CH DL DH BL BH}{regs 2 index 1 getinterval def 1 add}forall pop
0{AX CX DX BX SP BP SI DI IP FL}{regs 2 index 2 getinterval def 2 add}forall pop

%getting and fetching
[/*b{0 get} %get byte from pointer
/*w{dup *b exch 1 get bbw} %get word from pointer
/*{{*b *w}W get exec} %get data(W) from pointer
/bbw{8 bitshift add} %lo-byte hi-byte -&gt; word
/shiftmask{2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and}
/fetchb{IP *w mem exch get bytedump   IP dup *w 1 add storew} % byte(IP++)
/fetchw{fetchb fetchb bbw} % word(IP),IP+=2

%storing and accessing
/storeb{16#ff and 0 exch put} % ptr val8 -&gt; -
/storew{2 copy storeb -8 bitshift 16#ff and 1 exch put} % ptr val16 -&gt; -
/stor{{storeb storew}W get exec} % ptr val(W) -&gt; -
/memptr{mem exch {1 2}W get getinterval} % addr -&gt; ptr(W)

%decoding the mod-reg-reg/mem byte
/mrm{fetchb 3 shiftmask /RM exch def 3 shiftmask /REG exch def /MOD exch def}
/REGTAB[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]
/decreg{REGTAB W get REG get} % REGTAB[W][REG]
%2 indexes,   with immed byte,   with immed word
/2*w{exch *w exch *w add}/fba{fetchb add}/fwa{fetchw add}
/RMTAB[[{BX SI 2*w}{BX DI 2*w}{BP SI 2*w}{BP DI 2*w}
    {SI *w}{DI *w}{fetchw}{BX *w}]
[{BX SI 2*w fba}{BX DI 2*w fba}{BP SI 2*w fba}{BP DI 2*w fba}
    {SI *w fba}{DI *w fba}{BP *w fba}{BX *w fba}]
[{BX SI 2*w fwa}{BX DI 2*w fwa}{BP SI 2*w fwa}{BP DI 2*w fwa}
    {SI *w fwa}{DI *w fwa}{BP *w fwa}{BX *w fwa}]]
/decrm{MOD 3 eq{REGTAB W get RM get} %MOD=3:register mode
    {RMTAB MOD get RM get exec memptr}ifelse} % RMTAB[MOD][RM] -&gt; addr -&gt; ptr

%setting and storing flags
/flagw{OF 11 bitshift SF 7 bitshift or ZF 6 bitshift or AF 4 bitshift CF or}
/wflag{dup 1 and /CF exch def dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def}
/nz1{0 ne{1}{0}ifelse}
/logflags{/CF 0 def /OF 0 def /AF 0 def %clear mathflags
    dup {16#80 16#8000}W get and nz1 /SF exch def
    dup {16#ff 16#ffff}W get and 0 eq{1}{0}ifelse /ZF exch def}
/mathflags{{z y x}{exch def}forall
    /CF z {16#ff00 16#ffff0000}W get and nz1 def
    /OF z x xor z y xor and {16#80 16#8000}W get and nz1 def
    /AF x y xor z xor 16#10 and nz1 def
    z} %leave the result on stack

%opcodes (each followed by 'stor')  %% { OPTAB fetchb get exec stor } loop
/ADD{2 copy add logflags mathflags}
/OR{or logflags}
/ADC{CF add ADD}
/SBB{D 1 xor {exch}repeat CF add 2 copy sub logflags mathflags}
/AND{and logflags}
/SUB{D 1 xor {exch}repeat 2 copy sub logflags mathflags}
/XOR{xor logflags}
/CMP{3 2 roll pop NULL 3 1 roll SUB} %dummy stor target
/INC{t CF exch dup * 1 ADD 3 2 roll /CF exch def}
/DEC{t CF exch dup * 1 SUB 3 2 roll /CF exch def}
/PUSH{SP dup *w 2 sub storew   *w SP *w memptr exch}
/POP{SP *w memptr *w   SP dup *w 2 add storew}

/jrel{w {CBW IP *w add IP exch}{NULL exch}ifelse}
/JO{fetchb OF 1 eq jrel }
/JNO{fetchb OF 0 eq jrel }
/JB{fetchb CF 1 eq jrel }
/JNB{fetchb CF 0 eq jrel }
/JZ{fetchb ZF 1 eq jrel }
/JNZ{fetchb ZF 0 eq jrel }
/JBE{fetchb CF ZF or 1 eq jrel }
/JNBE{fetchb CF ZF or 0 eq jrel }
/JS{fetchb SF 1 eq jrel }
/JNS{fetchb SF 0 eq jrel }
/JL{fetchb SF OF xor 1 eq jrel }
/JNL{fetchb SF OF xor 0 eq jrel }
/JLE{fetchb SF OF xor ZF or 1 eq jrel }
/JNLE{fetchb SF OF xor ZF or 0 eq jrel }

/bw{dup 16#80 and 0 ne{16#ff xor 1 add 16#ffff xor 1 add}if}
/IMMTAB{ADD OR ADC SBB AND SUB XOR CMP }cvlit
/immed{mrm
    {fetchb fetchw {fetchb bw /W 1 def}}W get exec
    decrm dup * 3 2 roll exch IMMTAB REG get exec }

%/TEST{ }
/XCHG{3 2 roll pop 2 copy exch * 4 2 roll * stor }
/AXCH{w dup AX XCHG }
/pMOV{D{exch}repeat pop }
/MOV{ } %8-D
/LEA{w mrm decreg RMTAB MOD get RM get exec }

/CBW{dup 16#80 and 0 ne {16#ff xor 1 add 16#ffff xor 1 add } if }
/CWD{dup 16#8000 and 0 ne {16#ffff xor 1 add neg } if }
/CALL{w xp /xp{}def fetchw IP PUSH storew IP dup *w 3 2 roll add dsp /dsp{}def }
%/WAIT{ }
/PUSHF{NULL dup flagw storew 2 copy PUSH }
/POPF{NULL dup POP *w wflag }
%/SAHF{ }
%/LAHF{ }

%/MOVS{ }
%/CMPS{ }
%/STOS{ }
%/LODS{ }
%/SCAS{ }
/RET{w IP POP storew SP dup * 3 2 roll add }
%/LES{ }
%/LDS{ }

/JMP{IP dup fetchw exch *w add }
/sJMP{IP dup fetchb exch *w add }

/HLT{stop}
/CMC{/CF CF 1 xor def NULL nul}
/CLC{/CF 0 def NULL nul}
/STC{/CF 1 def NULL nul}

/NOT{not logflags }
/NEG{neg logflags }
/GRP1TAB{TEST --- NOT NEG MUL IMUL DIV IDIV } cvlit
/Grp1{mrm decrm dup * GRP1TAB REG get exec }
/GRP2TAB{INC DEC {id CALL}{l id CALL}{id JMP}{l id JMP} PUSH --- } cvlit
/Grp2{mrm decrm GRP2TAB REG get exec }

%optab shortcuts
/2*{exch * exch *}
/rm{mrm decreg decrm D index 3 1 roll 2*} % fetch,decode mrm -&gt; dest *reg *r-m
/rmp{mrm decreg decrm D index 3 1 roll} % fetch,decode mrm -&gt; dest reg r-m
/ia{ {{AL dup *b fetchb}{AX dup *w fetchw}}W get exec } %immed to accumulator
/is{/W 2 def}
/b{/W 0 def} %select byte operation
/w{/W 1 def} %select word operation
/t{/D 1 def} %dest = reg
/f{/D 0 def} %dest = r/m
/xp{} /dsp{}
%/far{ /xp { &lt;0000&gt; PUSH storew } /dsp { fetchw pop } def }
/i{ {fetchb fetchw}W get exec }

/OPTAB{
{b f rm ADD}{w f rm ADD}{b t rm ADD}{w t rm ADD}{b ia ADD}{w ia ADD}{ES PUSH}{ES POP} %00-07
 {b f rm OR}{w f rm OR}{b t rm OR}{w t rm OR}{b ia OR}{w ia OR}{CS PUSH}{}            %08-0F
{b f rm ADC}{w f rm ADC}{b t rm ADC}{w t rm ADC}{b ia ADC}{w ia ADC}{SS PUSH}{SS POP} %10-17
 {b f rm SBB}{w f rm SBB}{b t rm SBB}{w t rm SBB}{b ia SBB}{w ia SBB}{DS PUSH}{DS POP}%18-1F
{b f rm AND}{w f rm AND}{b t rm AND}{w t rm AND}{b ia AND}{w ia AND}{ES SEG}{DAA}     %20-27
 {b f rm SUB}{w f rm SUB}{b t rm SUB}{w t rm SUB}{b ia SUB}{w ia SUB}{CS SEG}{DAS}    %28-2F
{b f rm XOR}{w f rm XOR}{b t rm XOR}{w t rm XOR}{b ia XOR}{w ia XOR}{SS SEG}{AAA}     %30-37
 {b f rm CMP}{w f rm CMP}{b t rm CMP}{w t rm CMP}{b ia CMP}{w ia CMP}{DS SEG}{AAS}    %38-3F
{w AX INC}{w CX INC}{w DX INC}{w BX INC}{w SP INC}{w BP INC}{w SI INC}{w DI INC}      %40-47
 {w AX DEC}{w CX DEC}{w DX DEC}{w BX DEC}{w SP DEC}{w BP DEC}{w SI DEC}{w DI DEC}     %48-4F
{AX PUSH}{CX PUSH}{DX PUSH}{BX PUSH}{SP PUSH}{BP PUSH}{SI PUSH}{DI PUSH}              %50-57
 {AX POP}{CX POP}{DX POP}{BX POP}{SP POP}{BP POP}{SI POP}{DI POP}                     %58-5F
{}{}{}{}{}{}{}{}  {}{}{}{}{}{}{}{}                                                    %60-6F
{JO}{JNO}{JB}{JNB}{JZ}{JNZ}{JBE}{JNBE} {JS}{JNS}{JP}{JNP}{JL}{JNL}{JLE}{JNLE}         %70-7F

{b f immed}{w f immed}{b f immed}{is f immed}{b TEST}{w TEST}{b rmp XCHG}{w rmp XCHG}   %80-87
 {b f rm pMOV}{w f rm pMOV}{b t rm pMOV}{w t rm pMOV}                                 %88-8B
   {sr f rm pMOV}{LEA}{sr t rm pMOV}{w mrm decrm POP}                                 %8C-8F
{AX AXCH}{CX AXCH}{DX AXCH}{BX AXCHG}{SP AXCH}{BP AXCH}{SI AXCH}{DI AXCH}             %90-97
 {CBW}{CWD}{far CALL}{WAIT}{PUSHF}{POPF}{SAHF}{LAHF}                                  %98-9F
{b AL m MOV}{w AX m MOV}{b m AL MOV}{b AX m MOV}{MOVS}{MOVS}{CMPS}{CMPS}              %A0-A7
 {b i a TEST}{w i a TEST}{STOS}{STOS}{LODS}{LODS}{SCAS}{SCAS}                         %A8-AF
{b AL i MOV}{b CL i MOV}{b DL i MOV}{b BL i MOV}                                      %B0-B3
 {b AH i MOV}{b CH i MOV}{b DH i MOV}{b BH i MOV}                                     %B4-B7
 {w AX i MOV}{w CX i MOV}{w DX i MOV}{w BX i MOV}                                     %B8-BB
 {w SP i MOV}{w BP i MOV}{w SI i MOV}{w DI i MOV}                                     %BC-BF
{}{}{fetchw RET}{0 RET}{LES}{LDS}{b i rm MOV}{w i rm MOV}                             %C0-B7
 {}{}{fetchw RET}{0 RET}{3 INT}{fetchb INT}{INTO}{IRET}                               %C8-CF
{b Shift}{w Shift}{b v Shift}{w v Shift}{AAM}{AAD}{}{XLAT}                            %D0-D7
 {0 ESC}{1 ESC}{2 ESC}{3 ESC}{4 ESC}{5 ESC}{6 ESC}{7 ESC}                             %D8-DF
{LOOPNZ}{LOOPZ}{LOOP}{JCXZ}{b IN}{w IN}{b OUT}{w OUT}                                 %E0-E7
 {CALL}{JMP}{far JMP}{sJMP}{v b IN}{v w IN}{v b OUT}{v w OUT}                         %E8-EF
{LOCK}{}{REP}{z REP}{HLT}{CMC}{b Grp1}{w Grp}                                         %F0-F7
 {CLC}{STC}{CLI}{STI}{CLD}{STD}{b Grp2}{w Grp2}                                       %F8-FF
}cvlit

/stdout(%stdout)(w)file
/bytedump{ &lt;00&gt; dup 0 3 index put stdout exch writehexstring ( )print }
/regdump{ REGTAB 1 get{ stdout exch writehexstring ( )print }forall
    stdout IP writehexstring ( )print
    {(NC )(CA )}CF get print
    {(NO )(OV )}OF get print
    {(NS )(SN )}SF get print
    {(NZ )(ZR )}ZF get print (\n)print }
/mainloop{{
    regdump
    OPTAB fetchb get
    dup ==
    exec
    pstack
    stor
    /ic ic 1 add def ictime
}loop}

/printvideo{
    0 1 24 {
        80 mul 16#8000 add mem exch 80 getinterval {
            dup 0 eq { pop 32 } if
            stdout exch write
        } forall (\n)print
</span>    } for
<span class="diff-delete">} def

/enter</span> <span class="diff-delete">{
</span>   <span class="diff-delete"> </span>(<span class="diff-delete">&gt;</span><span class="diff-add">\n</span>)print<span class="diff-delete"> flush
    {mark(%stdin)(r)file read}stopped cleartomark</span>
}<span class="diff-delete"> def

ARGUMENTS {</span>
<span class="diff-delete">    (r) file mem readstring pop pop

    IP</span><span class="diff-add">/ic</span> 0<span class="diff-delete"> storew</span>
<span class="diff-delete">    SP 16#100 storew
    </span><span class="diff-add">/ictime</span>{<span class="diff-delete">
    </span><span class="diff-add">ic</span> <span class="diff-add">10</span> <span class="diff-add">mod</span> <span class="diff-add">0</span> <span class="diff-delete">debug</span><span class="diff-add">eq</span> {<span class="diff-delete"> ()= regdump </span><span class="diff-add">onq</span>} if<span class="diff-add">}</span>
<span class="diff-delete">       </span><span class="diff-add">/timeq</span> <span class="diff-delete">fetchb</span><span class="diff-add">10</span>
<span class="diff-delete">        trace </span><span class="diff-add">/onq</span>{<span class="diff-delete"> bytedump </span><span class="diff-add">printvideo</span>}<span class="diff-delete"> if</span>
<span class="diff-delete">        load exec
       </span><span class="diff-add">&gt;&gt;begin</span> <span class="diff-delete">%showvideo</span><span class="diff-add">currentdict{</span>
    <span class="diff-add">dup</span> <span class="diff-add">type/arraytype</span> <span class="diff-add">eq</span> <span class="diff-add">1</span> <span class="diff-delete">%enter
</span><span class="diff-add">index</span> <span class="diff-add">xcheck</span> <span class="diff-add">and</span> <span class="diff-add">{bind</span> <span class="diff-add">def</span>}<span class="diff-delete"> loop

    debug</span>{<span class="diff-delete"> &lt;&gt;=</span><span class="diff-add">pop</span> <span class="diff-add">pop</span>}<span class="diff-delete">if
    showvideo
   </span><span class="diff-add">ifelse</span> <span class="diff-delete">printvideo
</span>}<span class="diff-delete"> </span>forall

<span class="diff-delete">%} stopped { countexecstack</span><span class="diff-add">SP</span> <span class="diff-delete">array</span><span class="diff-add">16#100</span> <span class="diff-delete">execstack</span><span class="diff-add">storew
(codegolf.8086)(r)file</span> <span class="diff-delete">==</span><span class="diff-add">mem</span> <span class="diff-delete">}</span><span class="diff-add">readstring</span> <span class="diff-delete">if
enter</span><span class="diff-add">pop</span>
<span class="diff-delete">showpage</span><span class="diff-add">pop[

mainloop

%eof</span>
</code></pre><p> And<span class="diff-add"> we're back to square 2 with</span> the<span class="diff-delete"> screenshot:</span><span class="diff-add"> output. It's crashing on one of the MOV permutations.</span></p><p><img class="diff-delete"src="http://i.stack.imgur.com/ZHNoB.png" alt="test program output"></p><pre><span class="diff-add">7e01 0000 0000 0080 fc0f 0000 0000 beff 7a01 CA NO NS NZ
5b {BX POP}
114
(\000\200)
-mark-
7e01 0000 0000 7200 fe0f 0000 0000 beff 7b01 CA NO NS NZ
c3 {0 RET}
4096
(\000\020)
-mark-
.........
Hello, world!
0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~























7e01 0000 0000 7200 0010 0000 0000 beff 9200 CA NO NS NZ
fe {b Grp2}
c0 127
(~)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9400 CA NO NS NZ
3c {b ia CMP}
7f 0
(\377\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9600 NC NO NS ZR
75 {JNZ}
f7 247
(\000\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9800 NC NO NS ZR
b0 {b AL i MOV}
23 35
(\177)
-mark-
2301 0000 0000 7200 0010 0000 0000 beff 9a00 NC NO NS ZR
c7 {w i rm MOV}
06 d3 01 Error: /rangecheck in --getinterval--
Operand stack:
   --nostringval--   54022   (#\001)   (\201\374\000\001t\001\364\274\000\020\260.\273\000\000K\203\373\377u\361\350Q\001Cu\353\350K\0011\311\t\313u\342r\340\350@\001\271\000\2009\331v\326\3506\001\001\313r\317\350/\001\001\333\203\321\000y\305r\303Q\203\341\001t\275\350\035\001Y\371\273\000\200\031\331u\261r\257\350\017\001\350\000\000[\201\373]\000u\242\201\374\000\020u\234\350\374\000\273r\000S\303\201\374\000\020u\216\350\356\000\220\220\220\353\001\364\350\370\000\270\305\001\350\312\000\350\357\000\2600\350\327\000\376\300\323\001\340\001u\n\261P\307\006\323\001\200\007\353\347\307\006\323\001\340\001\261\022\350\243\000\350\240...)   65584   2
Execution stack:
   %interp_exit   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   --nostringval--   false   1   %stopped_push   1905   1   3   %oparray_pop   1904   1   3   %oparray_pop   1888   1   3   %oparray_pop   1771   1   3   %oparray_pop   --nostringval--   %errorexec_pop   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   %loop_continue   --nostringval--   --nostringval--   --nostringval--
Dictionary stack:
   --dict:1152/1684(ro)(G)--   --dict:0/20(G)--   --dict:92/200(L)--   --dict:27/29(L)--   --dict:112/198(L)--
Current allocation mode is local
Current file position is 9187
GPL Ghostscript 8.62: Unrecoverable error, exit code 1

shell returned 1

Press ENTER or type command to continue
</span></pre>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <span class="diff-delete">531 lines</span>)</h1><p><em><span class="diff-delete">Latest version runs test program to completion!</span></em></p><div class="diff-skipped"><div></div></div><pre><code>%!
<span class="diff-delete">%8086 Emulator
/debug true def
/trace false def
/bytedump { dup 16#100 add 16 3 string cvrs 1 2 getinterval ==only } def

%sign-extend byte or word to PS integer (32-bit)
/bext { dup 16#80 and 0 ne { not 16#ff and 1 add neg } if } def
/wext { dup 16#8000 and 0 ne { not 16#ffff and 1 add neg } if } def

/signb { 16#80 and 0 ne } def
/signw { 16#8000 and 0 ne } def

/negb { 16#FF xor 1 add } def
/negw { 16#FFFF xor 1 add } def

%extend byte to word
/byteword { dup signb { negb negw } if } def
/wordquad { dup signw { negw neg } if } def

%memory and register byte-strings
/mem 16#FFFF string def
/reg 20 string def
%register pointers
0 {AL AH CL CH DL DH BL BH}{reg 2 index 1 getinterval def 1 add}forall pop
0 {AX CX DX BX SP BP SI DI IP FL}{reg 2 index 2 getinterval def 2 add}forall pop
/CF 0 def
/AF 0 def
/OF 0 def
/SF 0 def
/ZF 0 def

/memb { 16#ffff mod mem exch 1 getinterval } def
/memw { 16#ffff mod mem exch 2 getinterval } def

%load byte or word from a "pointer" (substring)
/getb { 0 get } def
/getw { dup getb exch 1 get 8 bitshift add } def

%store byte or word through a "pointer"
/storeb { 16#ff and 0 exch put } def
/storew { 2 copy storeb -8 bitshift 16#ff and 1 exch put } def

%shift and mask a bitfield off the bottom of an integer
/shiftmask { 2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and } def

%load byte or word from mem[IP++]
/fetchb { IP getw memb getb
    %bytedump
    debug {bytedump} if
    IP dup getw 1 add storew } def
/fetchw { fetchb fetchb 8 bitshift add } def

%decoding tables
%REGT[W][REG] -&gt; pointer
/REGT[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]def
/R-MT[[{BX getw SI getw add} %R-MT[MOD][R-M] -&gt; {pointer}
    {BX getw DI getw add}
    {BP getw SI getw add}
    {BP getw DI getw add}
    {SI getw}
    {DI getw}
    {fetchw}
    {BX getw}]
[{BX getw SI getw fetchb add add}
    {BX getw DI getw fetchb add add}
    {BP getw SI getw fetchb add add}
    {BP getw DI getw fetchb add add}
    {SI getw fetchb add}
    {DI getw fetchb add}
    {BP getw fetchb add}
    {BX getw fetchb add}]
[{BX getw SI getw fetchw add add}
    {BX getw DI getw fetchw add add}
    {BP getw SI getw fetchw add add}
    {BP getw DI getw fetchw add add}
    {SI getw fetchw add}
    {DI getw fetchw add}
    {BP getw fetchw add}
    {BX getw fetchw add}]]def

/w-d{{W D}{exch def}forall} def %assign W and D
/r-m{ %fetch and parse the MOD-REG-R/M byte
    fetchb
    3 shiftmask /R-M exch def
    3 shiftmask /REG exch def
    /MOD exch def} def
/decreg { REGT W get REG get } def
/decr-m { MOD 3 eq { REGT W get R-M get }{
        R-MT MOD get R-M get exec
        {memb memw}W get exec
    } ifelse } def
/opands { %decode the operands -&gt; (REG) (R/M)
    decreg
    decr-m
} def
/dest { % (REG) (R/M) -&gt; (DEST) (REG) (R/M)
    D index % 1:REG 0:R-M
    3 1 roll } def

%fetch&amp;decode M-R-R/M byte, -&gt; DEST REG R/M
/byteop { r-m opands dest
    exch getb %bext
    exch getb %bext
} def
/wordop { r-m opands dest
    exch getw %wext
    exch getw %wext
} def
/doop {{byteop wordop}W get exec} def

/setCF { dup
    {7 15}W get shiftmask pop
    dup 1 and exch -1 bitshift 1 and % _8|16 _9|17
        %dup /CF exch def
        2 copy ne {1}{0} ifelse /CF exch def
    xor /OF exch def
} def

/setZF { dup 0 eq {/ZF 1 def}{/ZF 0 def} ifelse } def
/setSF { dup {-7 -15}W get bitshift 1 and /SF exch def } def
/setF { setZF setSF } def
/logF { setF /CF 0 def /OF 0 def } def %logical operators clear OF+CF

/nz1 { 0 ne{1}{0}ifelse } def %nonzero to 1
/arithF {
    /CF c {16#ff00 16#ffff0000}W get and nz1 def
    /OF c a xor c b xor and {16#80 16#8000}W get and nz1 def
    /AF a b xor c xor 16#10 and nz1 def
} def
/ADD {
    debug {()= pstack} if
    {b a}{exch def}forall
    /c a b add def
    c arithF setF
} def
/SUB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b sub def
    c arithF setF
} def
/SBB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b CF add sub def
    c arithF setF
} def

%OPCODEs
%/ADD { add setF } def
16#00{ 0 0 w-d doop ADD storeb } def %ADDB R/M,REG
16#01{ 0 1 w-d doop ADD storew } def %ADDW R/M,REG
16#02{ 1 0 w-d doop ADD storeb } def %ADDB REG,R/M
16#03{ 1 1 w-d doop ADD storew } def %ADDW REG,R/M
16#04{ 0 0 w-d AL dup getb fetchb ADD storeb } def %ADDB AL,immed8
16#05{ 0 1 w-d AX dup getw fetchw ADD storew } def %ADDW AX,immed16
%06 PUSH ES
%07 POP ES
/OR { or logF } def
16#08{ 0 0 w-d doop OR storeb } def %OR R/M,REG
16#09{ 0 1 w-d doop OR storew } def %OR R/M,REG
16#0A{ 1 0 w-d doop OR storeb } def %OR REG,R/M
16#0B{ 1 1 w-d doop OR storew } def %OR REG,R/M
16#0C{ 0 0 w-d AL dup getb fetchb OR storeb } def %OR AL,immed8
16#0D{ 0 1 w-d AX dup getw fetchw OR storew } def %OR AX,immed16
%0E PUSH CS
%0F (not used)

/ADC { CF add ADD } def
16#10{ 0 0 w-d doop ADC storeb } def %ADC R/M,REG
16#11{ 0 1 w-d doop ADC storew } def %ADC R/M,REG
16#12{ 1 0 w-d doop ADC storeb } def %ADC REG,R/M
16#13{ 1 1 w-d doop ADC storew } def %ADC REG,R/M
16#14{ 0 0 w-d AL dup getb fetchb ADC storeb } def %ADC AL,immed8
16#15{ 0 1 w-d AX dup getw fetchw ADC storew } def %ADC AX,immed16
%16 PUSH SS
%17 POP SS
%/SBB { D 1 eq{exch}if sub CF sub setF } def
16#18{ 0 0 w-d doop SBB storeb } def %SBB R/M,REG
16#19{ 0 1 w-d doop SBB storew } def %SBB R/M,REG
16#1A{ 1 0 w-d doop SBB storeb } def %SBB REG,R/M
16#1B{ 1 1 w-d doop SBB storew } def %SBB REG,R/M
16#1C{ 0 0 w-d AL dup getb fetchb SBB storeb } def %SBB AL,immed8
16#1D{ 0 1 w-d AX dup getw fetchw SBB storew } def %SBB AX,immed16
%1E PUSH DS
%1F POP DS

/AND { and logF } def
16#20{ 0 0 w-d doop AND storeb } def %AND R/M,REG
16#21{ 0 1 w-d doop AND storew } def %AND R/M,REG
16#22{ 1 0 w-d doop AND storeb } def %AND REG,R/M
16#23{ 1 1 w-d doop AND storew } def %AND REG,R/M
16#24{ 0 0 w-d AL dup getb fetchb AND storeb } def %AND AL,immed8
16#25{ 0 1 w-d AX dup getw fetchw AND storew } def %AND AX,immed16
%26 ES
%27 DAA
%/SUB { D{exch}repeat sub setF } def
16#28{ 0 0 w-d doop SUB storeb } def %SUB R/M,REG
16#29{ 0 1 w-d doop SUB storew } def %SUB R/M,REG
16#2A{ 1 0 w-d doop SUB storeb } def %SUB R/M,REG
16#2B{ 1 1 w-d doop SUB storew } def %SUB R/M,REG
16#2C{ 0 0 w-d AL dup getb fetchb SUB storeb } def %SUB AL,immed8
16#2D{ 0 1 w-d AX dup getw fetchw SUB storew } def %SUB AX,immed16
%2E CS:
%2F DAS

/XOR { xor logF } def
16#30{ 0 0 w-d doop xor storeb } def %XOR R/M,REG
16#31{ 0 1 w-d doop xor storew } def %XOR R/M,REG
16#32{ 1 0 w-d doop xor storeb } def %XOR REG,R/M
16#33{ 1 1 w-d doop xor storew } def %XOR REG,R/M
16#34{ 0 0 w-d AL dup getb fetchb xor storeb } def %XOR AL,immed8
16#35{ 0 1 w-d AX dup getw fetchw xor storew } def %XOR AX,immed16
%36 SS:
%37 AAA
/CMP {
    debug { regdump pstack()= } if
        SUB
        debug { dup = } if
        pop } def
16#38{ 0 0 w-d doop CMP pop } def %CMP R/M,REG
16#39{ 0 1 w-d doop CMP pop } def %CMP R/M,REG
16#3A{ 0 0 w-d doop CMP pop } def %CMP REG,R/M
16#3B{ 0 1 w-d doop CMP pop } def %CMP REG,R/M
16#3C{ 0 0 w-d AL dup getb fetchb CMP pop } def %CMP AL,immed8
16#3D{ 0 1 w-d AX dup getw fetchw CMP pop } def %CMP AX,immed16
%3E DS
%3F AAS

/INC { CF exch dup {{getb bext} {getw wext}}W get exec 1 ADD
    {storeb storew}W get exec /CF exch def } def
16#40{ 0 1 w-d AX INC } def
16#41{ 0 1 w-d CX INC } def
16#42{ 0 1 w-d DX INC } def
16#43{ 0 1 w-d BX INC } def
16#44{ 0 1 w-d SP INC } def
16#45{ 0 1 w-d BP INC } def
16#46{ 0 1 w-d SI INC } def
16#47{ 0 1 w-d DI INC } def
/DEC { CF exch dup {{getb bext} {getw wext}}W get exec 1 sub setF
    {storeb storew}W get exec /CF exch def } def
16#48{ 0 1 w-d AX DEC } def
16#49{ 0 1 w-d CX DEC } def
16#4A{ 0 1 w-d DX DEC } def
16#4B{ 0 1 w-d BX DEC } def
16#4C{ 0 1 w-d SP DEC } def
16#4D{ 0 1 w-d BP DEC } def
16#4E{ 0 1 w-d SI DEC } def
16#4F{ 0 1 w-d DI DEC } def

%/PUSH { SP DEC SP DEC getw mem SP getw 2 getinterval exch storew } def
/PUSH{ SP dup getw
    dup =
    2 sub storew
    getw SP getw memw exch storew
    %enter
    SP getw =
} def
16#50{ AX PUSH } def
16#51{ CX PUSH } def
16#52{ DX PUSH } def
16#53{ BX PUSH } def
16#54{ SP PUSH } def
16#55{ BP PUSH } def
16#56{ SI PUSH } def
16#57{ DI PUSH } def

%/POP { mem SP getw 2 getinterval getw storew SP INC SP INC } def
/POP { SP getw memw getw storew
    SP dup getw 2 add storew } def
16#58{ AX POP } def
16#59{ CX POP } def
16#5A{ DX POP } def
16#5B{ BX POP } def
16#5C{ SP POP } def
16#5D{ BP POP } def
16#5E{ SI POP } def
16#5F{ DI POP } def
%60-6F

/jrel { { bext IP getw add IP exch storew }{ pop } ifelse } def
%16#71 JNO short-label
16#72{ fetchb CF 1 eq jrel } def %JB/JNAE/JC short-label
16#73{ fetchb CF 0 eq jrel } def %JNB/JAE/JNC short-label
16#74{ fetchb ZF 1 eq jrel } def %JF/JZ short-label
16#75{ fetchb ZF 0 eq jrel } def %JNE/JNZ short-label
16#76{ fetchb CF ZF or 1 eq jrel } def %JBE/JNA short-label
16#77{ fetchb CF ZF or 0 eq jrel } def %JNBE/JA short-label
16#78{ fetchb SF 1 eq jrel } def %JS short-label
16#79{ fetchb SF 0 eq jrel } def %JNS short-label
%16#7A JP/JPE short-label
%16#7B JNP/JPO short-label
16#7C{ fetchb SF OF xor 1 eq jrel } def %JL/JNGE short-label
16#7D{ fetchb SF OF xor 0 eq jrel } def %JNL/JGE short-label
16#7E{ fetchb SF OF xor ZF or 1 eq jrel } def %JLE/JNG short-label
16#7F{ fetchb SF OF xor ZF or 0 eq jrel } def %JNLE/JG short-label

/CMPp{ CMP pop &lt;0000&gt; 0 } def
/OPEXT {ADD OR ADC SBB AND SUB XOR CMPp} cvlit def
16#80{ 0 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb bext fetchb bext
    OPEXT REG get exec storeb } def
16#81{ 0 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw wext fetchw wext
    OPEXT REG get exec storew } def

/UNU {pop} def %unused
/OPEX2 {ADD UNU ADC SBB UNU SUB UNU CMPp} cvlit def
16#82{ 1 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb %bext
        fetchb %bext
    OPEX2 REG get exec storeb } def
16#83{ 1 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw %wext
        fetchb byteword %bext
    OPEX2 REG get exec storew } def

%16#84 TEST
%16#85 TEST
/XCHG { 2 copy exch
    {getb getw}W get exec
    4 2 roll
    {getb getw}W get exec
    2{ {storeb storew}W get exec }repeat
} def
16#86{ 1 0 w-d r-m opands XCHG } def %XCHG REG8,R/M8
16#87{ 1 1 w-d r-m opands XCHG } def %XCHG REG16,R/M16
16#88{ 0 0 w-d r-m opands exch getb storeb } def %MOV R/M8,REG8
16#89{ 0 1 w-d r-m opands exch getw storew } def %MOV R/M16,REG16
16#8A{ 1 0 w-d r-m opands getb storeb } def %MOV REG8,R/M8
16#8B{ 1 1 w-d r-m opands getw storew } def %MOV REG16,R/M16
%16#8C MOV REG16,SEGREG
16#8D{ 0 1 w-d r-m REGT W get REG get load
    R-MT MOD get R-M get exec storew } def %LEA REG16,MEM16
%16#8E MOV SEGREG,REG16
/8FT { POP } cvlit def
16#8F{ 1 1 w-d r-m decr-m 8FT REG get exec } def %REG:0 = POP R/M16
16#90{ } def %NOP
16#91{ AX CX XCHG } def %XCHG AX,CX
16#92{ AX DX XCHG } def %XCHG AX,DX
16#93{ AX BX XCHG } def %XCHG AX,BX
16#94{ AX SP XCHG } def %XCHG AX,SP
16#95{ AX BP XCHG } def %XCHG AX,BP
16#96{ AX SI XCHG } def %XCHG AX,SI
16#97{ AX DI XCHG } def %XCHG AX,DI
16#98{ AX AL getb bext storew } def %CBW
16#99{ DX AX getw wext 16 shiftmask pop storew } def %CWD
16#9A{ fetchw fetchw &lt;0000&gt; PUSH pop IP getw PUSH IP exch storew
    %()=
} def %CALL FAR PROC
%16#9B %WAIT
/flagw {
    OF 11 bitshift
    SF 7 bitshift or
    ZF 6 bitshift or
    AF 4 bitshift or
    CF 0 bitshift or
} def
/wflag {
    dup  0 bitshift 1 and /CF exch def
    dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def
    dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def
    pop
} def
16#9C{ &lt;0000&gt; dup flagw storew PUSH } def %PUSHF
16#9D{ POP wflag } def %POPF
16#9E{ AH flagw storeb } def %SAHF
16#9F{ AH getb OF 11 bitshift or wflag } def %LAHF

16#A0{ AL mem fetchw get storeb } def %MOV AL,MEM8
16#A1{ AX mem fetchw 2 getinterval getw storew } def %MOV AX,MEM16
16#A2{ mem fetchw 1 getinterval AL getb storeb } def %MOV MEM8,AL
16#A3{ mem fetchw 2 getinterval AX getw storew } def %MOV MEM16,AX
%A4-AF MOVS CMPS TEST STOS LODS SCAS

16#B0{ AL fetchb storeb } def %MOV AL,immed8
16#B1{ CL fetchb storeb } def %MOV CL,immed8
16#B2{ DL fetchb storeb } def %MOV DL,immed8
16#B3{ BL fetchb storeb } def %MOV BL,immed8
16#B4{ AH fetchb storeb } def %MOV AH,immed8
16#B5{ CH fetchb storeb } def %MOV CH,immed8
16#B6{ DH fetchb storeb } def %MOV DH,immed8
16#B7{ BH fetchb storeb } def %MOV BH,immed8
16#B8{ AX fetchw storew } def %MOV AX,immed16
16#B9{ CX fetchw storew } def %MOV CX,immed16
16#BA{ DX fetchw storew } def %MOV DX,immed16
16#BB{ BX fetchw storew } def %MOV BX,immed16
16#BC{ SP fetchw storew } def %MOV SP,immed16
16#BD{ BP fetchw storew } def %MOV BP,immed16
16#BE{ SI fetchw storew } def %MOV SI,immed16
16#BF{ DI fetchw storew } def %MOV AX,immed16

%C0-C1 not used
16#C2{ IP POP SP fetchw SP getw add storew
    ()=
} def %RET immed16(intraseg)
16#C3{ IP POP
    ()=
    showvideo
    flushpage
    %enter
} def %RET (intraseg)
16#C4{ 1 0 w-d r-m decreg decr-m getw storew } def %LES
16#C5{ 1 1 w-d r-m decreg decr-m getw storew } def %LDS
16#C6{ 1 0 w-d r-m decr-m fetchb storeb } def %REG:0 = MOV MEM8,immed8
16#C7{ 1 1 w-d r-m decr-m fetchw storew } def %REG:0 = MOV MEM16,immed16
%C8-C9 not used
16#CA{ IP POP &lt;0000&gt; POP pop SP fetchw SP getw add storew
    ()=
} def %RET immed16(interseg)
16#CB{ IP POP &lt;0000&gt; POP pop
    ()=
} def %RET (interseg)
%CC INT 3
%CD INT immed8
%CE INTO
%CF IRET

16#E8{ fetchw IP PUSH IP getw add IP exch storew
    ()=
} def %CALL NEAR-PROC
16#E9{ fetchw IP getw add IP exch storew
    ()=
} def %JMP NEAR-LABEL
16#EA{ IP fetchw storew fetchw pop
    ()=
} def %JMP FAR-LABEL
16#EB{ fetchb bext IP getw add IP exch storew
    ()=
} def %JMP SHORT-LABEL

16#F4{ exit } def %HLT
16#F5{ /CF CF 1 xor def } def %CMC

/NOT { not } def
/NEG { neg } def
/F6T { TEST UNU NOT NEG MUL IMUL DIV IDIV } cvlit def
16#F6{ 1 0 w-d r-m decr-m dup getw F6T REG get exec storew } def

16#F8{ /CF 0 def } def %CLC
16#F9{ /CF 1 def } def %STC

/FET { INC DEC } cvlit def
16#FE{ 1 0 w-d r-m decr-m FET REG get exec } def
/FFT { INC DEC
    { IP PUSH IP exch getw storew } %CALL REG16/MEM15 (intra)
    { &lt;0000&gt; PUSH IP PUSH IP exch getw storew } %CALL MEM16 (intersegment)
    { IP exch getw storew } %JMP REG16/MEM15 (intra)
    { } %JMP MEM16 (intersegment)
    PUSH %PUSH MEM16
} cvlit def
16#FF{ 1 1 w-d r-m decr-m FFT REG get exec
    ()=
} def


/regdump {
    FL flagw storew
    0 2 reg length 2 sub {
        reg exch 2 getinterval
        (%stdout)(w) file
        exch
        writehexstring
        ( )print
    } for
    ()=
} def

%/= /== load def
%errordict/undefined{pop{}}put
%{

(cp437.ps)run
/CP437 14 selectfont

/showvideo {
    40 700 moveto
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval
        gsave show grestore
        0 -10 rmoveto
    } for
} def

/printvideo {
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval {
            dup 32 ge 1 index 126 le and {
                ( ) dup 0 4 3 roll put print
            }{
                ( )print
            }ifelse
        } forall
        (\n)print
</span>    } for
<span class="diff-delete">} def

/enter</span> <span class="diff-delete">{
</span>   <span class="diff-delete"> </span>(<span class="diff-delete">&gt;</span>)print<span class="diff-delete"> flush
    {mark(%stdin)(r)file read}stopped cleartomark</span>
}<span class="diff-delete"> def

ARGUMENTS {</span>
<span class="diff-delete">    (r) file mem readstring pop pop

    IP</span> 0<span class="diff-delete"> storew</span>
<span class="diff-delete">    SP 16#100 storew
    </span>{<span class="diff-delete">
    </span>    <span class="diff-delete">debug</span> {<span class="diff-delete"> ()= regdump </span>} if
<span class="diff-delete">       </span> <span class="diff-delete">fetchb</span>
<span class="diff-delete">        trace </span>{<span class="diff-delete"> bytedump </span>}<span class="diff-delete"> if</span>
<span class="diff-delete">        load exec
       </span> <span class="diff-delete">%showvideo</span>
        <span class="diff-delete">%enter
</span>    }<span class="diff-delete"> loop

    debug</span>{<span class="diff-delete"> &lt;&gt;=</span> }<span class="diff-delete">if
    showvideo
   </span> <span class="diff-delete">printvideo
</span>}<span class="diff-delete"> </span>forall

<span class="diff-delete">%} stopped { countexecstack</span> <span class="diff-delete">array</span> <span class="diff-delete">execstack</span> <span class="diff-delete">==</span> <span class="diff-delete">}</span> <span class="diff-delete">if
enter</span>
<span class="diff-delete">showpage</span>
</code></pre><p> And the<span class="diff-delete"> screenshot:</span></p><p><img class="diff-delete"src="http://i.stack.imgur.com/ZHNoB.png" alt="test program output"></p>
            </div>
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del>517</del> <del><span class="diff-add">531</span></del> <em><span class="diff-add">222</span></em> <span class="diff-add">lines</span>)</h1><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Total re-write from scratch using the concise table from the manual (</span><em><span class="diff-add">turned a new page!</span></em><span class="diff-add">). I'm starting to think that factoring-out the </span><em><span class="diff-add">store</span></em> <span class="diff-add">from the opcodes was a bad idea, but it helped keep the optab pretty. No screenshot this time. I added an instruction counter and a mod-trigger to dump the video memory, so it interleaves easily with the debug info.</span></p><pre><code>%!
<span class="diff-add">%a8086.ps Draught2:BREVITY
[/NULL&lt;0000&gt;/nul 0
/mem 16#ffff string %16-bit memory
/CF 0 /OF 0 /AF 0 /ZF 0 /SF 0
/regs 20 string &gt;&gt;begin %register byte storage
0{AL AH CL CH DL DH BL BH}{regs 2 index 1 getinterval def 1 add}forall pop
0{AX CX DX BX SP BP SI DI IP FL}{regs 2 index 2 getinterval def 2 add}forall pop

%getting and fetching
[/*b{0 get} %get byte from pointer
/*w{dup *b exch 1 get bbw} %get word from pointer
/*{{*b *w}W get exec} %get data(W) from pointer
/bbw{8 bitshift add} %lo-byte hi-byte -&gt; word
/shiftmask{2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and}
/fetchb{IP *w mem exch get bytedump   IP dup *w 1 add storew} % byte(IP++)
/fetchw{fetchb fetchb bbw} % word(IP),IP+=2

%storing and accessing
/storeb{16#ff and 0 exch put} % ptr val8 -&gt; -
/storew{2 copy storeb -8 bitshift 16#ff and 1 exch put} % ptr val16 -&gt; -
/stor{{storeb storew}W get exec} % ptr val(W) -&gt; -
/memptr{mem exch {1 2}W get getinterval} % addr -&gt; ptr(W)

%decoding the mod-reg-reg/mem byte
/mrm{fetchb 3 shiftmask /RM exch def 3 shiftmask /REG exch def /MOD exch def}
/REGTAB[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]
/decreg{REGTAB W get REG get} % REGTAB[W][REG]
%2 indexes,   with immed byte,   with immed word
/2*w{exch *w exch *w add}/fba{fetchb add}/fwa{fetchw add}
/RMTAB[[{BX SI 2*w}{BX DI 2*w}{BP SI 2*w}{BP DI 2*w}
    {SI *w}{DI *w}{fetchw}{BX *w}]
[{BX SI 2*w fba}{BX DI 2*w fba}{BP SI 2*w fba}{BP DI 2*w fba}
    {SI *w fba}{DI *w fba}{BP *w fba}{BX *w fba}]
[{BX SI 2*w fwa}{BX DI 2*w fwa}{BP SI 2*w fwa}{BP DI 2*w fwa}
    {SI *w fwa}{DI *w fwa}{BP *w fwa}{BX *w fwa}]]
/decrm{MOD 3 eq{REGTAB W get RM get} %MOD=3:register mode
    {RMTAB MOD get RM get exec memptr}ifelse} % RMTAB[MOD][RM] -&gt; addr -&gt; ptr

%setting and storing flags
/flagw{OF 11 bitshift SF 7 bitshift or ZF 6 bitshift or AF 4 bitshift CF or}
/wflag{dup 1 and /CF exch def dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def}
/nz1{0 ne{1}{0}ifelse}
/logflags{/CF 0 def /OF 0 def /AF 0 def %clear mathflags
    dup {16#80 16#8000}W get and nz1 /SF exch def
    dup {16#ff 16#ffff}W get and 0 eq{1}{0}ifelse /ZF exch def}
/mathflags{{z y x}{exch def}forall
    /CF z {16#ff00 16#ffff0000}W get and nz1 def
    /OF z x xor z y xor and {16#80 16#8000}W get and nz1 def
    /AF x y xor z xor 16#10 and nz1 def
    z} %leave the result on stack

%opcodes (each followed by 'stor')  %% { OPTAB fetchb get exec stor } loop
/ADD{2 copy add logflags mathflags}
/OR{or logflags}
/ADC{CF add ADD}
/SBB{D 1 xor {exch}repeat CF add 2 copy sub logflags mathflags}
/AND{and logflags}
/SUB{D 1 xor {exch}repeat 2 copy sub logflags mathflags}
/XOR{xor logflags}
/CMP{3 2 roll pop NULL 3 1 roll SUB} %dummy stor target
/INC{t CF exch dup * 1 ADD 3 2 roll /CF exch def}
/DEC{t CF exch dup * 1 SUB 3 2 roll /CF exch def}
/PUSH{SP dup *w 2 sub storew   *w SP *w memptr exch}
/POP{SP *w memptr *w   SP dup *w 2 add storew}

/jrel{w {CBW IP *w add IP exch}{NULL exch}ifelse}
/JO{fetchb OF 1 eq jrel }
/JNO{fetchb OF 0 eq jrel }
/JB{fetchb CF 1 eq jrel }
/JNB{fetchb CF 0 eq jrel }
/JZ{fetchb ZF 1 eq jrel }
/JNZ{fetchb ZF 0 eq jrel }
/JBE{fetchb CF ZF or 1 eq jrel }
/JNBE{fetchb CF ZF or 0 eq jrel }
/JS{fetchb SF 1 eq jrel }
/JNS{fetchb SF 0 eq jrel }
/JL{fetchb SF OF xor 1 eq jrel }
/JNL{fetchb SF OF xor 0 eq jrel }
/JLE{fetchb SF OF xor ZF or 1 eq jrel }
/JNLE{fetchb SF OF xor ZF or 0 eq jrel }

/bw{dup 16#80 and 0 ne{16#ff xor 1 add 16#ffff xor 1 add}if}
/IMMTAB{ADD OR ADC SBB AND SUB XOR CMP }cvlit
/immed{mrm
    {fetchb fetchw {fetchb bw /W 1 def}}W get exec
    decrm dup * 3 2 roll exch IMMTAB REG get exec }

%/TEST{ }
/XCHG{3 2 roll pop 2 copy exch * 4 2 roll * stor }
/AXCH{w dup AX XCHG }
/pMOV{D{exch}repeat pop }
/MOV{ } %8-D
/LEA{w mrm decreg RMTAB MOD get RM get exec }

/CBW{dup 16#80 and 0 ne {16#ff xor 1 add 16#ffff xor 1 add } if }
/CWD{dup 16#8000 and 0 ne {16#ffff xor 1 add neg } if }
/CALL{w xp /xp{}def fetchw IP PUSH storew IP dup *w 3 2 roll add dsp /dsp{}def }
%/WAIT{ }
/PUSHF{NULL dup flagw storew 2 copy PUSH }
/POPF{NULL dup POP *w wflag }
%/SAHF{ }
%/LAHF{ }

%/MOVS{ }
%/CMPS{ }
%/STOS{ }
%/LODS{ }
%/SCAS{ }
/RET{w IP POP storew SP dup * 3 2 roll add }
%/LES{ }
%/LDS{ }

/JMP{IP dup fetchw exch *w add }
/sJMP{IP dup fetchb exch *w add }

/HLT{stop}
/CMC{/CF CF 1 xor def NULL nul}
/CLC{/CF 0 def NULL nul}
/STC{/CF 1 def NULL nul}

/NOT{not logflags }
/NEG{neg logflags }
/GRP1TAB{TEST --- NOT NEG MUL IMUL DIV IDIV } cvlit
/Grp1{mrm decrm dup * GRP1TAB REG get exec }
/GRP2TAB{INC DEC {id CALL}{l id CALL}{id JMP}{l id JMP} PUSH --- } cvlit
/Grp2{mrm decrm GRP2TAB REG get exec }

%optab shortcuts
/2*{exch * exch *}
/rm{mrm decreg decrm D index 3 1 roll 2*} % fetch,decode mrm -&gt; dest *reg *r-m
/rmp{mrm decreg decrm D index 3 1 roll} % fetch,decode mrm -&gt; dest reg r-m
/ia{ {{AL dup *b fetchb}{AX dup *w fetchw}}W get exec } %immed to accumulator
/is{/W 2 def}
/b{/W 0 def} %select byte operation
/w{/W 1 def} %select word operation
/t{/D 1 def} %dest = reg
/f{/D 0 def} %dest = r/m
/xp{} /dsp{}
%/far{ /xp { &lt;0000&gt; PUSH storew } /dsp { fetchw pop } def }
/i{ {fetchb fetchw}W get exec }

/OPTAB{
{b f rm ADD}{w f rm ADD}{b t rm ADD}{w t rm ADD}{b ia ADD}{w ia ADD}{ES PUSH}{ES POP} %00-07
 {b f rm OR}{w f rm OR}{b t rm OR}{w t rm OR}{b ia OR}{w ia OR}{CS PUSH}{}            %08-0F
{b f rm ADC}{w f rm ADC}{b t rm ADC}{w t rm ADC}{b ia ADC}{w ia ADC}{SS PUSH}{SS POP} %10-17
 {b f rm SBB}{w f rm SBB}{b t rm SBB}{w t rm SBB}{b ia SBB}{w ia SBB}{DS PUSH}{DS POP}%18-1F
{b f rm AND}{w f rm AND}{b t rm AND}{w t rm AND}{b ia AND}{w ia AND}{ES SEG}{DAA}     %20-27
 {b f rm SUB}{w f rm SUB}{b t rm SUB}{w t rm SUB}{b ia SUB}{w ia SUB}{CS SEG}{DAS}    %28-2F
{b f rm XOR}{w f rm XOR}{b t rm XOR}{w t rm XOR}{b ia XOR}{w ia XOR}{SS SEG}{AAA}     %30-37
 {b f rm CMP}{w f rm CMP}{b t rm CMP}{w t rm CMP}{b ia CMP}{w ia CMP}{DS SEG}{AAS}    %38-3F
{w AX INC}{w CX INC}{w DX INC}{w BX INC}{w SP INC}{w BP INC}{w SI INC}{w DI INC}      %40-47
 {w AX DEC}{w CX DEC}{w DX DEC}{w BX DEC}{w SP DEC}{w BP DEC}{w SI DEC}{w DI DEC}     %48-4F
{AX PUSH}{CX PUSH}{DX PUSH}{BX PUSH}{SP PUSH}{BP PUSH}{SI PUSH}{DI PUSH}              %50-57
 {AX POP}{CX POP}{DX POP}{BX POP}{SP POP}{BP POP}{SI POP}{DI POP}                     %58-5F
{}{}{}{}{}{}{}{}  {}{}{}{}{}{}{}{}                                                    %60-6F
{JO}{JNO}{JB}{JNB}{JZ}{JNZ}{JBE}{JNBE} {JS}{JNS}{JP}{JNP}{JL}{JNL}{JLE}{JNLE}         %70-7F

{b f immed}{w f immed}{b f immed}{is f immed}{b TEST}{w TEST}{b rmp XCHG}{w rmp XCHG}   %80-87
 {b f rm pMOV}{w f rm pMOV}{b t rm pMOV}{w t rm pMOV}                                 %88-8B
   {sr f rm pMOV}{LEA}{sr t rm pMOV}{w mrm decrm POP}                                 %8C-8F
{AX AXCH}{CX AXCH}{DX AXCH}{BX AXCHG}{SP AXCH}{BP AXCH}{SI AXCH}{DI AXCH}             %90-97
 {CBW}{CWD}{far CALL}{WAIT}{PUSHF}{POPF}{SAHF}{LAHF}                                  %98-9F
{b AL m MOV}{w AX m MOV}{b m AL MOV}{b AX m MOV}{MOVS}{MOVS}{CMPS}{CMPS}              %A0-A7
 {b i a TEST}{w i a TEST}{STOS}{STOS}{LODS}{LODS}{SCAS}{SCAS}                         %A8-AF
{b AL i MOV}{b CL i MOV}{b DL i MOV}{b BL i MOV}                                      %B0-B3
 {b AH i MOV}{b CH i MOV}{b DH i MOV}{b BH i MOV}                                     %B4-B7
 {w AX i MOV}{w CX i MOV}{w DX i MOV}{w BX i MOV}                                     %B8-BB
 {w SP i MOV}{w BP i MOV}{w SI i MOV}{w DI i MOV}                                     %BC-BF
{}{}{fetchw RET}{0 RET}{LES}{LDS}{b i rm MOV}{w i rm MOV}                             %C0-B7
 {}{}{fetchw RET}{0 RET}{3 INT}{fetchb INT}{INTO}{IRET}                               %C8-CF
{b Shift}{w Shift}{b v Shift}{w v Shift}{AAM}{AAD}{}{XLAT}                            %D0-D7
 {0 ESC}{1 ESC}{2 ESC}{3 ESC}{4 ESC}{5 ESC}{6 ESC}{7 ESC}                             %D8-DF
{LOOPNZ}{LOOPZ}{LOOP}{JCXZ}{b IN}{w IN}{b OUT}{w OUT}                                 %E0-E7
 {CALL}{JMP}{far JMP}{sJMP}{v b IN}{v w IN}{v b OUT}{v w OUT}                         %E8-EF
{LOCK}{}{REP}{z REP}{HLT}{CMC}{b Grp1}{w Grp}                                         %F0-F7
 {CLC}{STC}{CLI}{STI}{CLD}{STD}{b Grp2}{w Grp2}                                       %F8-FF
}cvlit

/stdout(%stdout)(w)file
/bytedump{ &lt;00&gt; dup 0 3 index put stdout exch writehexstring ( )print }
/regdump{ REGTAB 1 get{ stdout exch writehexstring ( )print }forall
    stdout IP writehexstring ( )print
    {(NC )(CA )}CF get print
    {(NO )(OV )}OF get print
    {(NS )(SN )}SF get print
    {(NZ )(ZR )}ZF get print (\n)print }
/mainloop{{
    regdump
    OPTAB fetchb get
    dup ==
    exec
    pstack
    stor
    /ic ic 1 add def ictime
}loop}

/printvideo{
    0 1 24 {
        80 mul 16#8000 add mem exch 80 getinterval {
            dup 0 eq { pop 32 } if
            stdout exch write
        } forall (\n)print
</span>    } for
    (<span class="diff-add">\n</span>)print
}
<span class="diff-add">/ic</span> 0
<span class="diff-add">/ictime</span>{<span class="diff-add">ic</span> <span class="diff-add">10</span> <span class="diff-add">mod</span> <span class="diff-add">0</span> <span class="diff-add">eq</span> {<span class="diff-add">onq</span>} if<span class="diff-add">}</span>
<span class="diff-add">/timeq</span> <span class="diff-add">10</span>
<span class="diff-add">/onq</span>{<span class="diff-add">printvideo</span>}
<span class="diff-add">&gt;&gt;begin</span> <span class="diff-add">currentdict{</span>
    <span class="diff-add">dup</span> <span class="diff-add">type/arraytype</span> <span class="diff-add">eq</span> <span class="diff-add">1</span> <span class="diff-add">index</span> <span class="diff-add">xcheck</span> <span class="diff-add">and</span> <span class="diff-add">{bind</span> <span class="diff-add">def</span>}{<span class="diff-add">pop</span> <span class="diff-add">pop</span>}<span class="diff-add">ifelse</span> }forall

<span class="diff-add">SP</span> <span class="diff-add">16#100</span> <span class="diff-add">storew
(codegolf.8086)(r)file</span> <span class="diff-add">mem</span> <span class="diff-add">readstring</span> <span class="diff-add">pop</span>
<span class="diff-add">pop[

mainloop

%eof</span>
</code></pre><p> And<span class="diff-add"> we're back to square 2 with</span> the<span class="diff-add"> output. It's crashing on one of the MOV permutations.</span></p><pre><span class="diff-add">7e01 0000 0000 0080 fc0f 0000 0000 beff 7a01 CA NO NS NZ
5b {BX POP}
114
(\000\200)
-mark-
7e01 0000 0000 7200 fe0f 0000 0000 beff 7b01 CA NO NS NZ
c3 {0 RET}
4096
(\000\020)
-mark-
.........
Hello, world!
0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~























7e01 0000 0000 7200 0010 0000 0000 beff 9200 CA NO NS NZ
fe {b Grp2}
c0 127
(~)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9400 CA NO NS NZ
3c {b ia CMP}
7f 0
(\377\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9600 NC NO NS ZR
75 {JNZ}
f7 247
(\000\000)
-mark-
7f01 0000 0000 7200 0010 0000 0000 beff 9800 NC NO NS ZR
b0 {b AL i MOV}
23 35
(\177)
-mark-
2301 0000 0000 7200 0010 0000 0000 beff 9a00 NC NO NS ZR
c7 {w i rm MOV}
06 d3 01 Error: /rangecheck in --getinterval--
Operand stack:
   --nostringval--   54022   (#\001)   (\201\374\000\001t\001\364\274\000\020\260.\273\000\000K\203\373\377u\361\350Q\001Cu\353\350K\0011\311\t\313u\342r\340\350@\001\271\000\2009\331v\326\3506\001\001\313r\317\350/\001\001\333\203\321\000y\305r\303Q\203\341\001t\275\350\035\001Y\371\273\000\200\031\331u\261r\257\350\017\001\350\000\000[\201\373]\000u\242\201\374\000\020u\234\350\374\000\273r\000S\303\201\374\000\020u\216\350\356\000\220\220\220\353\001\364\350\370\000\270\305\001\350\312\000\350\357\000\2600\350\327\000\376\300\323\001\340\001u\n\261P\307\006\323\001\200\007\353\347\307\006\323\001\340\001\261\022\350\243\000\350\240...)   65584   2
Execution stack:
   %interp_exit   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   --nostringval--   false   1   %stopped_push   1905   1   3   %oparray_pop   1904   1   3   %oparray_pop   1888   1   3   %oparray_pop   1771   1   3   %oparray_pop   --nostringval--   %errorexec_pop   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   %loop_continue   --nostringval--   --nostringval--   --nostringval--
Dictionary stack:
   --dict:1152/1684(ro)(G)--   --dict:0/20(G)--   --dict:92/200(L)--   --dict:27/29(L)--   --dict:112/198(L)--
Current allocation mode is local
Current file position is 9187
GPL Ghostscript 8.62: Unrecoverable error, exit code 1

shell returned 1

Press ENTER or type command to continue
</span></pre>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-4b29d81e-ad3a-4b66-82dd-0caed848e0c5">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('db5399cc-561c-4a19-a193-fd2c3a19b304') ">
                        <span id="rev-arrow-db5399cc-561c-4a19-a193-fd2c3a19b304" class="expander-arrow-show" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('db5399cc-561c-4a19-a193-fd2c3a19b304') ">
                        <span title="revision 5">5</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">finishes the test program!</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/db5399cc-561c-4a19-a193-fd2c3a19b304/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/5" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-12-07 06:57:25Z" class="relativetime">Dec 7 '12 at 6:57</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="revdb5399cc-561c-4a19-a193-fd2c3a19b304" class="revcell5" style="display: block">


<div class="diff-choices">
    <a href="#" class="action inline-html-diff selected" title="Show the rendered output with additions and removals inline">inline</a>
    <a href="#" class="action sidebyside-html-diff" title="Show the rendered output diffs side-by-side">side-by-side</a>
    <a href="#" class="action sidebyside-markdown-diff" title="Show the markdown source diffs side-by-side">side-by-side markdown</a>
    <br class="cbt" />
</div>

<div class="diffs">

        <div class="post-text inline-diff condensed">
            <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <span class="diff-delete">517</span><del><span class="diff-add">517</span></del> <span class="diff-add">531</span> lines)</h1><p><span class="diff-delete"> Still a work-in-progress, but I</span><em><span class="diff-add">Latest version runs test program to completion!</span></em></p><p><del><span class="diff-add">Still a work-in-progress, but</span></del> <span class="diff-add">I</span> wanted to show some code in an effort to encourage others to <em>show some code</em>.</p><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Runs the test to completion. The final few bugs were: XCHG doing 2{read store}repeat which of course copies rather than exchanges, AND not setting flags, (FE) INC trying to get a word from a byte pointer.</span></p><pre><code>%!
%8086 Emulator
/debug true def
/trace false def
/bytedump { dup 16#100 add 16 3 string cvrs 1 2 getinterval ==only } def

%sign-extend byte or word to PS integer (32-bit)
/bext { dup 16#80 and 0 ne { not 16#ff and 1 add neg } if } def
/wext { dup 16#8000 and 0 ne { not 16#ffff and 1 add neg } if } def

/signb { 16#80 and 0 ne } def
/signw { 16#8000 and 0 ne } def

/negb { 16#FF xor 1 add } def
/negw { 16#FFFF xor 1 add } def

%extend byte to word
/byteword { dup signb { negb negw } if } def
/wordquad { dup signw { negw neg } if } def

%memory and register byte-strings
/mem 16#FFFF string def
/reg 20 string def
%register pointers
0 {AL AH CL CH DL DH BL BH}{reg 2 index 1 getinterval def 1 add}forall pop
0 {AX CX DX BX SP BP SI DI IP FL}{reg 2 index 2 getinterval def 2 add}forall pop
/CF 0 def
/AF 0 def
/OF 0 def
/SF 0 def
/ZF 0 def

/memb { 16#ffff mod mem exch 1 getinterval } def
/memw { 16#ffff mod mem exch 2 getinterval } def

%load byte or word from a "pointer" (substring)
/getb { 0 get } def
/getw { dup getb exch 1 get 8 bitshift add } def

%store byte or word through a "pointer"
/storeb { 16#ff and 0 exch put } def
/storew { 2 copy storeb -8 bitshift 16#ff and 1 exch put } def

%shift and mask a bitfield off the bottom of an integer
/shiftmask { 2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and } def

%load byte or word from mem[IP++]
/fetchb { IP getw memb getb
    %bytedump
    debug {bytedump} if
    IP dup getw 1 add storew } def
/fetchw { fetchb fetchb 8 bitshift add } def

%decoding tables
%REGT[W][REG] -&gt; pointer
/REGT[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]def
/R-MT[[{BX getw SI getw add} %R-MT[MOD][R-M] -&gt; {pointer}
    {BX getw DI getw add}
    {BP getw SI getw add}
    {BP getw DI getw add}
    {SI getw}
    {DI getw}
    {fetchw}
    {BX getw}]
[{BX getw SI getw fetchb add add}
    {BX getw DI getw fetchb add add}
    {BP getw SI getw fetchb add add}
    {BP getw DI getw fetchb add add}
    {SI getw fetchb add}
    {DI getw fetchb add}
    {BP getw fetchb add}
    {BX getw fetchb add}]
[{BX getw SI getw fetchw add add}
    {BX getw DI getw fetchw add add}
    {BP getw SI getw fetchw add add}
    {BP getw DI getw fetchw add add}
    {SI getw fetchw add}
    {DI getw fetchw add}
    {BP getw fetchw add}
    {BX getw fetchw add}]]def

/w-d{{W D}{exch def}forall} def %assign W and D
/r-m{ %fetch and parse the MOD-REG-R/M byte
    fetchb
    3 shiftmask /R-M exch def
    3 shiftmask /REG exch def
    /MOD exch def} def
/decreg { REGT W get REG get } def
/decr-m { MOD 3 eq { REGT W get R-M get }{
        R-MT MOD get R-M get exec
        {memb memw}W get exec
    } ifelse } def
/opands { %decode the operands -&gt; (REG) (R/M)
    decreg
    decr-m
} def
/dest { % (REG) (R/M) -&gt; (DEST) (REG) (R/M)
    D index % 1:REG 0:R-M
    3 1 roll } def

%fetch&amp;decode M-R-R/M byte, -&gt; DEST REG R/M
/byteop { r-m opands dest
    exch getb %bext
    exch getb %bext
} def
/wordop { r-m opands dest
    exch getw %wext
    exch getw %wext
} def
/doop {{byteop wordop}W get exec} def

/setCF { dup
    {7 15}W get shiftmask pop
    dup 1 and exch -1 bitshift 1 and % _8|16 _9|17
        %dup /CF exch def
        2 copy ne {1}{0} ifelse /CF exch def
    xor /OF exch def
} def

/setZF { dup 0 eq {/ZF 1 def}{/ZF 0 def} ifelse } def
/setSF { dup {-7 -15}W get bitshift 1 and /SF exch def } def
/setF { setZF setSF } def
/logF { setF /CF 0 def /OF 0 def } def %logical operators clear OF+CF

/nz1 { 0 ne{1}{0}ifelse } def %nonzero to 1
/arithF {
    /CF c {16#ff00 16#ffff0000}W get and nz1 def
    /OF c a xor c b xor and {16#80 16#8000}W get and nz1 def
    /AF a b xor c xor 16#10 and nz1 def
} def
/ADD {
    debug {()= pstack} if
    {b a}{exch def}forall
    /c a b add def
    c arithF setF
} def
/SUB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b sub def
    c arithF setF
} def
/SBB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b CF add sub def
    c arithF setF
} def

%OPCODEs
%/ADD { add setF } def
16#00{ 0 0 w-d doop ADD storeb } def %ADDB R/M,REG
16#01{ 0 1 w-d doop ADD storew } def %ADDW R/M,REG
16#02{ 1 0 w-d doop ADD storeb } def %ADDB REG,R/M
16#03{ 1 1 w-d doop ADD storew } def %ADDW REG,R/M
16#04{ 0 0 w-d AL dup getb fetchb ADD storeb } def %ADDB AL,immed8
16#05{ 0 1 w-d AX dup getw fetchw ADD storew } def %ADDW AX,immed16
%06 PUSH ES
%07 POP ES
/OR { or logF } def
16#08{ 0 0 w-d doop OR storeb } def %OR R/M,REG
16#09{ 0 1 w-d doop OR storew } def %OR R/M,REG
16#0A{ 1 0 w-d doop OR storeb } def %OR REG,R/M
16#0B{ 1 1 w-d doop OR storew } def %OR REG,R/M
16#0C{ 0 0 w-d AL dup getb fetchb OR storeb } def %OR AL,immed8
16#0D{ 0 1 w-d AX dup getw fetchw OR storew } def %OR AX,immed16
%0E PUSH CS
%0F (not used)

/ADC { CF add ADD } def
16#10{ 0 0 w-d doop ADC storeb } def %ADC R/M,REG
16#11{ 0 1 w-d doop ADC storew } def %ADC R/M,REG
16#12{ 1 0 w-d doop ADC storeb } def %ADC REG,R/M
16#13{ 1 1 w-d doop ADC storew } def %ADC REG,R/M
16#14{ 0 0 w-d AL dup getb fetchb ADC storeb } def %ADC AL,immed8
16#15{ 0 1 w-d AX dup getw fetchw ADC storew } def %ADC AX,immed16
%16 PUSH SS
%17 POP SS
%/SBB { D 1 eq{exch}if sub CF sub setF } def
16#18{ 0 0 w-d doop SBB storeb } def %SBB R/M,REG
16#19{ 0 1 w-d doop SBB storew } def %SBB R/M,REG
16#1A{ 1 0 w-d doop SBB storeb } def %SBB REG,R/M
16#1B{ 1 1 w-d doop SBB storew } def %SBB REG,R/M
16#1C{ 0 0 w-d AL dup getb fetchb SBB storeb } def %SBB AL,immed8
16#1D{ 0 1 w-d AX dup getw fetchw SBB storew } def %SBB AX,immed16
%1E PUSH DS
%1F POP DS

/AND { and logF } def
16#20{ 0 0 w-d doop <span class="diff-delete">and</span><span class="diff-add">AND</span> storeb } def %AND R/M,REG
16#21{ 0 1 w-d doop <span class="diff-delete">and</span><span class="diff-add">AND</span> storew } def %AND R/M,REG
16#22{ 1 0 w-d doop <span class="diff-delete">and</span><span class="diff-add">AND</span> storeb } def %AND REG,R/M
16#23{ 1 1 w-d doop <span class="diff-delete">and</span><span class="diff-add">AND</span> storew } def %AND REG,R/M
16#24{ 0 0 w-d AL dup getb fetchb <span class="diff-delete">and</span><span class="diff-add">AND</span> storeb } def %AND AL,immed8
16#25{ 0 1 w-d AX dup getw fetchw <span class="diff-delete">and</span><span class="diff-add">AND</span> storew } def %AND AX,immed16
%26 ES
%27 DAA
%/SUB { D{exch}repeat sub setF } def
16#28{ 0 0 w-d doop SUB storeb } def %SUB R/M,REG
16#29{ 0 1 w-d doop SUB storew } def %SUB R/M,REG
16#2A{ 1 0 w-d doop SUB storeb } def %SUB R/M,REG
16#2B{ 1 1 w-d doop SUB storew } def %SUB R/M,REG
16#2C{ 0 0 w-d AL dup getb fetchb SUB storeb } def %SUB AL,immed8
16#2D{ 0 1 w-d AX dup getw fetchw SUB storew } def %SUB AX,immed16
%2E CS:
%2F DAS

/XOR { xor logF } def
16#30{ 0 0 w-d doop xor storeb } def %XOR R/M,REG
16#31{ 0 1 w-d doop xor storew } def %XOR R/M,REG
16#32{ 1 0 w-d doop xor storeb } def %XOR REG,R/M
16#33{ 1 1 w-d doop xor storew } def %XOR REG,R/M
16#34{ 0 0 w-d AL dup getb fetchb xor storeb } def %XOR AL,immed8
16#35{ 0 1 w-d AX dup getw fetchw xor storew } def %XOR AX,immed16
%36 SS:
%37 AAA
/CMP {
    debug { regdump pstack()= } if
        SUB
        debug { dup = } if
        pop } def
16#38{ 0 0 w-d doop CMP pop } def %CMP R/M,REG
16#39{ 0 1 w-d doop CMP pop } def %CMP R/M,REG
16#3A{ 0 0 w-d doop CMP pop } def %CMP REG,R/M
16#3B{ 0 1 w-d doop CMP pop } def %CMP REG,R/M
16#3C{ 0 0 w-d AL dup getb fetchb CMP pop } def %CMP AL,immed8
16#3D{ 0 1 w-d AX dup getw fetchw CMP pop } def %CMP AX,immed16
%3E DS
%3F AAS

/INC { CF exch dup <span class="diff-add">{{getb bext} {</span>getw wext<span class="diff-add">}}W</span> <span class="diff-add">get exec </span>1 ADD<span class="diff-add">
  </span> <span class="diff-add"> {storeb </span>storew<span class="diff-add">}W get</span> <span class="diff-add">exec </span>/CF exch def } def
16#40{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>AX INC } def
16#41{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>CX INC } def
16#42{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>DX INC } def
16#43{ <span class="diff-add">0 1 w-d </span>BX INC } def
16#44{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>SP INC } def
16#45{<span class="diff-add"> 0 1 w-d</span> BP INC } def
16#46{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>SI INC } def
16#47{<span class="diff-add"> 0 1 w-d</span> DI INC } def
/DEC { CF exch dup <span class="diff-add">{{getb bext} {</span>getw wext<span class="diff-add">}}W</span> <span class="diff-add">get exec </span>1 sub setF<span class="diff-add">
  </span> <span class="diff-add"> {storeb </span>storew<span class="diff-add">}W get</span> <span class="diff-add">exec </span>/CF exch def } def
16#48{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>AX DEC } def
16#49{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>CX DEC } def
16#4A{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>DX DEC } def
16#4B{ <span class="diff-add">0 1 w-d </span>BX DEC } def
16#4C{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>SP DEC } def
16#4D{<span class="diff-add"> 0 1 w-d</span> BP DEC } def
16#4E{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>SI DEC } def
16#4F{<span class="diff-add"> 0 1 w-d</span> DI DEC } def

%/PUSH { SP DEC SP DEC getw mem SP getw 2 getinterval exch storew } def
/PUSH{ SP dup getw
    dup =
    2 sub storew
    getw SP getw memw exch storew
    %enter
    SP getw =
} def
16#50{ AX PUSH } def
16#51{ CX PUSH } def
16#52{ DX PUSH } def
16#53{ BX PUSH } def
16#54{ SP PUSH } def
16#55{ BP PUSH } def
16#56{ SI PUSH } def
16#57{ DI PUSH } def

%/POP { mem SP getw 2 getinterval getw storew SP INC SP INC } def
/POP { SP getw memw getw storew
    SP dup getw 2 add storew } def
16#58{ AX POP } def
16#59{ CX POP } def
16#5A{ DX POP } def
16#5B{ BX POP } def
16#5C{ SP POP } def
16#5D{ BP POP } def
16#5E{ SI POP } def
16#5F{ DI POP } def
%60-6F

/jrel { { bext IP getw add IP exch storew }{ pop } ifelse } def
%16#71 JNO short-label
16#72{ fetchb CF 1 eq jrel } def %JB/JNAE/JC short-label
16#73{ fetchb CF 0 eq jrel } def %JNB/JAE/JNC short-label
16#74{ fetchb ZF 1 eq jrel } def %JF/JZ short-label
16#75{ fetchb ZF 0 eq jrel } def %JNE/JNZ short-label
16#76{ fetchb CF ZF or 1 eq jrel } def %JBE/JNA short-label
16#77{ fetchb CF ZF or 0 eq jrel } def %JNBE/JA short-label
16#78{ fetchb SF 1 eq jrel } def %JS short-label
16#79{ fetchb SF 0 eq jrel } def %JNS short-label
%16#7A JP/JPE short-label
%16#7B JNP/JPO short-label
16#7C{ fetchb SF OF xor 1 eq jrel } def %JL/JNGE short-label
16#7D{ fetchb SF OF xor 0 eq jrel } def %JNL/JGE short-label
16#7E{ fetchb SF OF xor ZF or 1 eq jrel } def %JLE/JNG short-label
16#7F{ fetchb SF OF xor ZF or 0 eq jrel } def %JNLE/JG short-label

/CMPp{ CMP pop &lt;0000&gt; 0 } def
/OPEXT {ADD OR ADC SBB AND SUB XOR CMPp} cvlit def
16#80{ 0 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb bext fetchb bext
    OPEXT REG get exec storeb } def
16#81{ 0 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw wext fetchw wext
    OPEXT REG get exec storew } def

/UNU {pop} def %unused
/OPEX2 {ADD UNU ADC SBB UNU SUB UNU CMPp} cvlit def
16#82{ 1 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb %bext
        fetchb %bext
    OPEX2 REG get exec storeb } def
16#83{ 1 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw %wext
        fetchb byteword %bext
    OPEX2 REG get exec storew } def

%16#84 TEST
%16#85 TEST
/XCHG { 2 copy exch
    {getb getw}W get exec
    4 2 roll
    {getb getw}W get exec
    2{ {storeb storew}W get exec }repeat
} def
16#86{ 1 0 w-d r-m opands XCHG } def %XCHG REG8,R/M8
16#87{ 1 1 w-d r-m opands XCHG } def %XCHG REG16,R/M16
16#88{ 0 0 w-d r-m opands exch getb storeb } def %MOV R/M8,REG8
16#89{ 0 1 w-d r-m opands exch getw storew } def %MOV R/M16,REG16
16#8A{ 1 0 w-d r-m opands getb storeb } def %MOV REG8,R/M8
16#8B{ 1 1 w-d r-m opands getw storew } def %MOV REG16,R/M16
%16#8C MOV REG16,SEGREG
16#8D{ 0 1 w-d r-m REGT W get REG get load
    R-MT MOD get R-M get exec storew } def %LEA REG16,MEM16
%16#8E MOV SEGREG,REG16
/8FT { POP } cvlit def
16#8F{ 1 1 w-d r-m decr-m 8FT REG get exec } def %REG:0 = POP R/M16
16#90{ } def %NOP
16#91{ AX CX XCHG } def %XCHG AX,CX
16#92{ AX DX XCHG } def %XCHG AX,DX
16#93{ AX BX XCHG } def %XCHG AX,BX
16#94{ AX SP XCHG } def %XCHG AX,SP
16#95{ AX BP XCHG } def %XCHG AX,BP
16#96{ AX SI XCHG } def %XCHG AX,SI
16#97{ AX DI XCHG } def %XCHG AX,DI
16#98{ AX AL getb bext storew } def %CBW
16#99{ DX AX getw wext 16 shiftmask pop storew } def %CWD
16#9A{ fetchw fetchw &lt;0000&gt; PUSH pop IP getw PUSH IP exch storew
    %()=
} def %CALL FAR PROC
%16#9B %WAIT
/flagw {
    OF 11 bitshift
    SF 7 bitshift or
    ZF 6 bitshift or
    AF 4 bitshift or
    CF 0 bitshift or
} def
/wflag {
    dup  0 bitshift 1 and /CF exch def
    dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def
    dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def
    pop
} def
16#9C{ &lt;0000&gt; dup flagw storew PUSH } def %PUSHF
16#9D{ POP wflag } def %POPF
16#9E{ AH flagw storeb } def %SAHF
16#9F{ AH getb OF 11 bitshift or wflag } def %LAHF

16#A0{ AL mem fetchw get storeb } def %MOV AL,MEM8
16#A1{ AX mem fetchw 2 getinterval getw storew } def %MOV AX,MEM16
16#A2{ mem fetchw 1 getinterval AL getb storeb } def %MOV MEM8,AL
16#A3{ mem fetchw 2 getinterval AX getw storew } def %MOV MEM16,AX
%A4-AF MOVS CMPS TEST STOS LODS SCAS

16#B0{ AL fetchb storeb } def %MOV AL,immed8
16#B1{ CL fetchb storeb } def %MOV CL,immed8
16#B2{ DL fetchb storeb } def %MOV DL,immed8
16#B3{ BL fetchb storeb } def %MOV BL,immed8
16#B4{ AH fetchb storeb } def %MOV AH,immed8
16#B5{ CH fetchb storeb } def %MOV CH,immed8
16#B6{ DH fetchb storeb } def %MOV DH,immed8
16#B7{ BH fetchb storeb } def %MOV BH,immed8
16#B8{ AX fetchw storew } def %MOV AX,immed16
16#B9{ CX fetchw storew } def %MOV CX,immed16
16#BA{ DX fetchw storew } def %MOV DX,immed16
16#BB{ BX fetchw storew } def %MOV BX,immed16
16#BC{ SP fetchw storew } def %MOV SP,immed16
16#BD{ BP fetchw storew } def %MOV BP,immed16
16#BE{ SI fetchw storew } def %MOV SI,immed16
16#BF{ DI fetchw storew } def %MOV AX,immed16

%C0-C1 not used
16#C2{ IP POP SP fetchw SP getw add storew
    ()=
} def %RET immed16(intraseg)
16#C3{ IP POP
    ()=
<span class="diff-add">    showvideo
</span>    flushpage
<span class="diff-add">    %enter
</span>} def %RET (intraseg)
16#C4{ 1 0 w-d r-m decreg decr-m getw storew } def %LES
16#C5{ 1 1 w-d r-m decreg decr-m getw storew } def %LDS
16#C6{ 1 0 w-d r-m decr-m fetchb storeb } def %REG:0 = MOV MEM8,immed8
16#C7{ 1 1 w-d r-m decr-m fetchw storew } def %REG:0 = MOV MEM16,immed16
%C8-C9 not used
16#CA{ IP POP &lt;0000&gt; POP pop SP fetchw SP getw add storew
    ()=
} def %RET immed16(interseg)
16#CB{ IP POP &lt;0000&gt; POP pop
    ()=
} def %RET (interseg)
%CC INT 3
%CD INT immed8
%CE INTO
%CF IRET

16#E8{ fetchw IP PUSH IP getw add IP exch storew
    ()=
} def %CALL NEAR-PROC
16#E9{ fetchw IP getw add IP exch storew
    ()=
} def %JMP NEAR-LABEL
16#EA{ IP fetchw storew fetchw pop
    ()=
} def %JMP FAR-LABEL
16#EB{ fetchb bext IP getw add IP exch storew
    ()=
} def %JMP SHORT-LABEL

16#F4{ exit } def %HLT
16#F5{ /CF CF 1 xor def } def %CMC

/NOT { not } def
/NEG { neg } def
/F6T { TEST UNU NOT NEG MUL IMUL DIV IDIV } cvlit def
16#F6{ 1 0 w-d r-m decr-m dup getw F6T REG get exec storew } def

16#F8{ /CF 0 def } def %CLC
16#F9{ /CF 1 def } def %STC

/FET { INC DEC } cvlit def
16#FE{ 1 0 w-d r-m decr-m FET REG get exec } def
/FFT { INC DEC
    { IP PUSH IP exch getw storew } %CALL REG16/MEM15 (intra)
    { &lt;0000&gt; PUSH IP PUSH IP exch getw storew } %CALL MEM16 (intersegment)
    { IP exch getw storew } %JMP REG16/MEM15 (intra)
    { } %JMP MEM16 (intersegment)
    PUSH %PUSH MEM16
} cvlit def
16#FF{ 1 1 w-d r-m decr-m FFT REG get exec
    ()=
} def


/regdump {
    FL flagw storew
    0 2 reg length 2 sub {
        reg exch 2 getinterval
        (%stdout)(w) file
        exch
        writehexstring
        ( )print
    } for
    ()=
} def

%/= /== load def
%errordict/undefined{pop{}}put
%{

(cp437.ps)run
/CP437 <span class="diff-delete">12</span><span class="diff-add">14</span> selectfont

/showvideo {
    40 700 moveto
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval
        gsave show grestore
        0 -10 rmoveto
    } for
} def

/printvideo {
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval <span class="diff-delete">=</span><span class="diff-add">{
            dup 32 ge 1 index 126 le and {
                ( ) dup 0 4 3 roll put print
            }{
                ( )print
            }ifelse
        } forall
        (\n)print</span>
    } for
} def

/enter {
    (&gt;)print flush
    {mark(%stdin)(r)file read}stopped cleartomark
} def

ARGUMENTS {
    (r) file mem readstring pop pop

    IP 0 storew
    SP 16#100 storew
    {
        debug { ()= regdump } if
        fetchb
        trace { bytedump } if
        load exec
        <span class="diff-delete">showvideo</span><span class="diff-add">%showvideo</span>
        %enter
    } loop

    debug{ &lt;&gt;= }if
<span class="diff-add">    showvideo
</span>    printvideo
} forall

%} stopped { countexecstack array execstack == } if
<span class="diff-add">enter
showpage
</span></code></pre><p><span class="diff-delete"> I now join the ranks of</span><span class="diff-add"> And</span> the screenshot<span class="diff-delete"> posts.</span><span class="diff-add">:</span></p><p><img class="diff-delete"src="http://i.stack.imgur.com/QEtEt.png" alt="screenshot with hello world! and mysterious caret"><img class="diff-add"src="http://i.stack.imgur.com/ZHNoB.png" alt="test program output"></p>
        </div>
        <div class="sidebyside-diff dno condensed">
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <span class="diff-delete">517</span> lines)</h1><p><span class="diff-delete"> Still a work-in-progress, but I</span> wanted to show some code in an effort to encourage others to <em>show some code</em>.</p><div class="diff-skipped"><div></div></div><pre><code>%!
%8086 Emulator
/debug true def
/trace false def
/bytedump { dup 16#100 add 16 3 string cvrs 1 2 getinterval ==only } def

%sign-extend byte or word to PS integer (32-bit)
/bext { dup 16#80 and 0 ne { not 16#ff and 1 add neg } if } def
/wext { dup 16#8000 and 0 ne { not 16#ffff and 1 add neg } if } def

/signb { 16#80 and 0 ne } def
/signw { 16#8000 and 0 ne } def

/negb { 16#FF xor 1 add } def
/negw { 16#FFFF xor 1 add } def

%extend byte to word
/byteword { dup signb { negb negw } if } def
/wordquad { dup signw { negw neg } if } def

%memory and register byte-strings
/mem 16#FFFF string def
/reg 20 string def
%register pointers
0 {AL AH CL CH DL DH BL BH}{reg 2 index 1 getinterval def 1 add}forall pop
0 {AX CX DX BX SP BP SI DI IP FL}{reg 2 index 2 getinterval def 2 add}forall pop
/CF 0 def
/AF 0 def
/OF 0 def
/SF 0 def
/ZF 0 def

/memb { 16#ffff mod mem exch 1 getinterval } def
/memw { 16#ffff mod mem exch 2 getinterval } def

%load byte or word from a "pointer" (substring)
/getb { 0 get } def
/getw { dup getb exch 1 get 8 bitshift add } def

%store byte or word through a "pointer"
/storeb { 16#ff and 0 exch put } def
/storew { 2 copy storeb -8 bitshift 16#ff and 1 exch put } def

%shift and mask a bitfield off the bottom of an integer
/shiftmask { 2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and } def

%load byte or word from mem[IP++]
/fetchb { IP getw memb getb
    %bytedump
    debug {bytedump} if
    IP dup getw 1 add storew } def
/fetchw { fetchb fetchb 8 bitshift add } def

%decoding tables
%REGT[W][REG] -&gt; pointer
/REGT[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]def
/R-MT[[{BX getw SI getw add} %R-MT[MOD][R-M] -&gt; {pointer}
    {BX getw DI getw add}
    {BP getw SI getw add}
    {BP getw DI getw add}
    {SI getw}
    {DI getw}
    {fetchw}
    {BX getw}]
[{BX getw SI getw fetchb add add}
    {BX getw DI getw fetchb add add}
    {BP getw SI getw fetchb add add}
    {BP getw DI getw fetchb add add}
    {SI getw fetchb add}
    {DI getw fetchb add}
    {BP getw fetchb add}
    {BX getw fetchb add}]
[{BX getw SI getw fetchw add add}
    {BX getw DI getw fetchw add add}
    {BP getw SI getw fetchw add add}
    {BP getw DI getw fetchw add add}
    {SI getw fetchw add}
    {DI getw fetchw add}
    {BP getw fetchw add}
    {BX getw fetchw add}]]def

/w-d{{W D}{exch def}forall} def %assign W and D
/r-m{ %fetch and parse the MOD-REG-R/M byte
    fetchb
    3 shiftmask /R-M exch def
    3 shiftmask /REG exch def
    /MOD exch def} def
/decreg { REGT W get REG get } def
/decr-m { MOD 3 eq { REGT W get R-M get }{
        R-MT MOD get R-M get exec
        {memb memw}W get exec
    } ifelse } def
/opands { %decode the operands -&gt; (REG) (R/M)
    decreg
    decr-m
} def
/dest { % (REG) (R/M) -&gt; (DEST) (REG) (R/M)
    D index % 1:REG 0:R-M
    3 1 roll } def

%fetch&amp;decode M-R-R/M byte, -&gt; DEST REG R/M
/byteop { r-m opands dest
    exch getb %bext
    exch getb %bext
} def
/wordop { r-m opands dest
    exch getw %wext
    exch getw %wext
} def
/doop {{byteop wordop}W get exec} def

/setCF { dup
    {7 15}W get shiftmask pop
    dup 1 and exch -1 bitshift 1 and % _8|16 _9|17
        %dup /CF exch def
        2 copy ne {1}{0} ifelse /CF exch def
    xor /OF exch def
} def

/setZF { dup 0 eq {/ZF 1 def}{/ZF 0 def} ifelse } def
/setSF { dup {-7 -15}W get bitshift 1 and /SF exch def } def
/setF { setZF setSF } def
/logF { setF /CF 0 def /OF 0 def } def %logical operators clear OF+CF

/nz1 { 0 ne{1}{0}ifelse } def %nonzero to 1
/arithF {
    /CF c {16#ff00 16#ffff0000}W get and nz1 def
    /OF c a xor c b xor and {16#80 16#8000}W get and nz1 def
    /AF a b xor c xor 16#10 and nz1 def
} def
/ADD {
    debug {()= pstack} if
    {b a}{exch def}forall
    /c a b add def
    c arithF setF
} def
/SUB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b sub def
    c arithF setF
} def
/SBB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b CF add sub def
    c arithF setF
} def

%OPCODEs
%/ADD { add setF } def
16#00{ 0 0 w-d doop ADD storeb } def %ADDB R/M,REG
16#01{ 0 1 w-d doop ADD storew } def %ADDW R/M,REG
16#02{ 1 0 w-d doop ADD storeb } def %ADDB REG,R/M
16#03{ 1 1 w-d doop ADD storew } def %ADDW REG,R/M
16#04{ 0 0 w-d AL dup getb fetchb ADD storeb } def %ADDB AL,immed8
16#05{ 0 1 w-d AX dup getw fetchw ADD storew } def %ADDW AX,immed16
%06 PUSH ES
%07 POP ES
/OR { or logF } def
16#08{ 0 0 w-d doop OR storeb } def %OR R/M,REG
16#09{ 0 1 w-d doop OR storew } def %OR R/M,REG
16#0A{ 1 0 w-d doop OR storeb } def %OR REG,R/M
16#0B{ 1 1 w-d doop OR storew } def %OR REG,R/M
16#0C{ 0 0 w-d AL dup getb fetchb OR storeb } def %OR AL,immed8
16#0D{ 0 1 w-d AX dup getw fetchw OR storew } def %OR AX,immed16
%0E PUSH CS
%0F (not used)

/ADC { CF add ADD } def
16#10{ 0 0 w-d doop ADC storeb } def %ADC R/M,REG
16#11{ 0 1 w-d doop ADC storew } def %ADC R/M,REG
16#12{ 1 0 w-d doop ADC storeb } def %ADC REG,R/M
16#13{ 1 1 w-d doop ADC storew } def %ADC REG,R/M
16#14{ 0 0 w-d AL dup getb fetchb ADC storeb } def %ADC AL,immed8
16#15{ 0 1 w-d AX dup getw fetchw ADC storew } def %ADC AX,immed16
%16 PUSH SS
%17 POP SS
%/SBB { D 1 eq{exch}if sub CF sub setF } def
16#18{ 0 0 w-d doop SBB storeb } def %SBB R/M,REG
16#19{ 0 1 w-d doop SBB storew } def %SBB R/M,REG
16#1A{ 1 0 w-d doop SBB storeb } def %SBB REG,R/M
16#1B{ 1 1 w-d doop SBB storew } def %SBB REG,R/M
16#1C{ 0 0 w-d AL dup getb fetchb SBB storeb } def %SBB AL,immed8
16#1D{ 0 1 w-d AX dup getw fetchw SBB storew } def %SBB AX,immed16
%1E PUSH DS
%1F POP DS

/AND { and logF } def
16#20{ 0 0 w-d doop <span class="diff-delete">and</span> storeb } def %AND R/M,REG
16#21{ 0 1 w-d doop <span class="diff-delete">and</span> storew } def %AND R/M,REG
16#22{ 1 0 w-d doop <span class="diff-delete">and</span> storeb } def %AND REG,R/M
16#23{ 1 1 w-d doop <span class="diff-delete">and</span> storew } def %AND REG,R/M
16#24{ 0 0 w-d AL dup getb fetchb <span class="diff-delete">and</span> storeb } def %AND AL,immed8
16#25{ 0 1 w-d AX dup getw fetchw <span class="diff-delete">and</span> storew } def %AND AX,immed16
%26 ES
%27 DAA
%/SUB { D{exch}repeat sub setF } def
16#28{ 0 0 w-d doop SUB storeb } def %SUB R/M,REG
16#29{ 0 1 w-d doop SUB storew } def %SUB R/M,REG
16#2A{ 1 0 w-d doop SUB storeb } def %SUB R/M,REG
16#2B{ 1 1 w-d doop SUB storew } def %SUB R/M,REG
16#2C{ 0 0 w-d AL dup getb fetchb SUB storeb } def %SUB AL,immed8
16#2D{ 0 1 w-d AX dup getw fetchw SUB storew } def %SUB AX,immed16
%2E CS:
%2F DAS

/XOR { xor logF } def
16#30{ 0 0 w-d doop xor storeb } def %XOR R/M,REG
16#31{ 0 1 w-d doop xor storew } def %XOR R/M,REG
16#32{ 1 0 w-d doop xor storeb } def %XOR REG,R/M
16#33{ 1 1 w-d doop xor storew } def %XOR REG,R/M
16#34{ 0 0 w-d AL dup getb fetchb xor storeb } def %XOR AL,immed8
16#35{ 0 1 w-d AX dup getw fetchw xor storew } def %XOR AX,immed16
%36 SS:
%37 AAA
/CMP {
    debug { regdump pstack()= } if
        SUB
        debug { dup = } if
        pop } def
16#38{ 0 0 w-d doop CMP pop } def %CMP R/M,REG
16#39{ 0 1 w-d doop CMP pop } def %CMP R/M,REG
16#3A{ 0 0 w-d doop CMP pop } def %CMP REG,R/M
16#3B{ 0 1 w-d doop CMP pop } def %CMP REG,R/M
16#3C{ 0 0 w-d AL dup getb fetchb CMP pop } def %CMP AL,immed8
16#3D{ 0 1 w-d AX dup getw fetchw CMP pop } def %CMP AX,immed16
%3E DS
%3F AAS

/INC { CF exch dup getw wext 1 ADD storew /CF exch def } def
16#40{ AX INC } def
16#41{ CX INC } def
16#42{ DX INC } def
16#43{ BX INC } def
16#44{ SP INC } def
16#45{ BP INC } def
16#46{ SI INC } def
16#47{ DI INC } def
/DEC { CF exch dup getw wext 1 sub setF storew /CF exch def } def
16#48{ AX DEC } def
16#49{ CX DEC } def
16#4A{ DX DEC } def
16#4B{ BX DEC } def
16#4C{ SP DEC } def
16#4D{ BP DEC } def
16#4E{ SI DEC } def
16#4F{ DI DEC } def

%/PUSH { SP DEC SP DEC getw mem SP getw 2 getinterval exch storew } def
/PUSH{ SP dup getw
    dup =
    2 sub storew
    getw SP getw memw exch storew
    %enter
    SP getw =
} def
16#50{ AX PUSH } def
16#51{ CX PUSH } def
16#52{ DX PUSH } def
16#53{ BX PUSH } def
16#54{ SP PUSH } def
16#55{ BP PUSH } def
16#56{ SI PUSH } def
16#57{ DI PUSH } def

%/POP { mem SP getw 2 getinterval getw storew SP INC SP INC } def
/POP { SP getw memw getw storew
    SP dup getw 2 add storew } def
16#58{ AX POP } def
16#59{ CX POP } def
16#5A{ DX POP } def
16#5B{ BX POP } def
16#5C{ SP POP } def
16#5D{ BP POP } def
16#5E{ SI POP } def
16#5F{ DI POP } def
%60-6F

/jrel { { bext IP getw add IP exch storew }{ pop } ifelse } def
%16#71 JNO short-label
16#72{ fetchb CF 1 eq jrel } def %JB/JNAE/JC short-label
16#73{ fetchb CF 0 eq jrel } def %JNB/JAE/JNC short-label
16#74{ fetchb ZF 1 eq jrel } def %JF/JZ short-label
16#75{ fetchb ZF 0 eq jrel } def %JNE/JNZ short-label
16#76{ fetchb CF ZF or 1 eq jrel } def %JBE/JNA short-label
16#77{ fetchb CF ZF or 0 eq jrel } def %JNBE/JA short-label
16#78{ fetchb SF 1 eq jrel } def %JS short-label
16#79{ fetchb SF 0 eq jrel } def %JNS short-label
%16#7A JP/JPE short-label
%16#7B JNP/JPO short-label
16#7C{ fetchb SF OF xor 1 eq jrel } def %JL/JNGE short-label
16#7D{ fetchb SF OF xor 0 eq jrel } def %JNL/JGE short-label
16#7E{ fetchb SF OF xor ZF or 1 eq jrel } def %JLE/JNG short-label
16#7F{ fetchb SF OF xor ZF or 0 eq jrel } def %JNLE/JG short-label

/CMPp{ CMP pop &lt;0000&gt; 0 } def
/OPEXT {ADD OR ADC SBB AND SUB XOR CMPp} cvlit def
16#80{ 0 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb bext fetchb bext
    OPEXT REG get exec storeb } def
16#81{ 0 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw wext fetchw wext
    OPEXT REG get exec storew } def

/UNU {pop} def %unused
/OPEX2 {ADD UNU ADC SBB UNU SUB UNU CMPp} cvlit def
16#82{ 1 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb %bext
        fetchb %bext
    OPEX2 REG get exec storeb } def
16#83{ 1 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw %wext
        fetchb byteword %bext
    OPEX2 REG get exec storew } def

%16#84 TEST
%16#85 TEST
/XCHG { 2 copy exch
    {getb getw}W get exec
    4 2 roll
    {getb getw}W get exec
    2{ {storeb storew}W get exec }repeat
} def
16#86{ 1 0 w-d r-m opands XCHG } def %XCHG REG8,R/M8
16#87{ 1 1 w-d r-m opands XCHG } def %XCHG REG16,R/M16
16#88{ 0 0 w-d r-m opands exch getb storeb } def %MOV R/M8,REG8
16#89{ 0 1 w-d r-m opands exch getw storew } def %MOV R/M16,REG16
16#8A{ 1 0 w-d r-m opands getb storeb } def %MOV REG8,R/M8
16#8B{ 1 1 w-d r-m opands getw storew } def %MOV REG16,R/M16
%16#8C MOV REG16,SEGREG
16#8D{ 0 1 w-d r-m REGT W get REG get load
    R-MT MOD get R-M get exec storew } def %LEA REG16,MEM16
%16#8E MOV SEGREG,REG16
/8FT { POP } cvlit def
16#8F{ 1 1 w-d r-m decr-m 8FT REG get exec } def %REG:0 = POP R/M16
16#90{ } def %NOP
16#91{ AX CX XCHG } def %XCHG AX,CX
16#92{ AX DX XCHG } def %XCHG AX,DX
16#93{ AX BX XCHG } def %XCHG AX,BX
16#94{ AX SP XCHG } def %XCHG AX,SP
16#95{ AX BP XCHG } def %XCHG AX,BP
16#96{ AX SI XCHG } def %XCHG AX,SI
16#97{ AX DI XCHG } def %XCHG AX,DI
16#98{ AX AL getb bext storew } def %CBW
16#99{ DX AX getw wext 16 shiftmask pop storew } def %CWD
16#9A{ fetchw fetchw &lt;0000&gt; PUSH pop IP getw PUSH IP exch storew
    %()=
} def %CALL FAR PROC
%16#9B %WAIT
/flagw {
    OF 11 bitshift
    SF 7 bitshift or
    ZF 6 bitshift or
    AF 4 bitshift or
    CF 0 bitshift or
} def
/wflag {
    dup  0 bitshift 1 and /CF exch def
    dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def
    dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def
    pop
} def
16#9C{ &lt;0000&gt; dup flagw storew PUSH } def %PUSHF
16#9D{ POP wflag } def %POPF
16#9E{ AH flagw storeb } def %SAHF
16#9F{ AH getb OF 11 bitshift or wflag } def %LAHF

16#A0{ AL mem fetchw get storeb } def %MOV AL,MEM8
16#A1{ AX mem fetchw 2 getinterval getw storew } def %MOV AX,MEM16
16#A2{ mem fetchw 1 getinterval AL getb storeb } def %MOV MEM8,AL
16#A3{ mem fetchw 2 getinterval AX getw storew } def %MOV MEM16,AX
%A4-AF MOVS CMPS TEST STOS LODS SCAS

16#B0{ AL fetchb storeb } def %MOV AL,immed8
16#B1{ CL fetchb storeb } def %MOV CL,immed8
16#B2{ DL fetchb storeb } def %MOV DL,immed8
16#B3{ BL fetchb storeb } def %MOV BL,immed8
16#B4{ AH fetchb storeb } def %MOV AH,immed8
16#B5{ CH fetchb storeb } def %MOV CH,immed8
16#B6{ DH fetchb storeb } def %MOV DH,immed8
16#B7{ BH fetchb storeb } def %MOV BH,immed8
16#B8{ AX fetchw storew } def %MOV AX,immed16
16#B9{ CX fetchw storew } def %MOV CX,immed16
16#BA{ DX fetchw storew } def %MOV DX,immed16
16#BB{ BX fetchw storew } def %MOV BX,immed16
16#BC{ SP fetchw storew } def %MOV SP,immed16
16#BD{ BP fetchw storew } def %MOV BP,immed16
16#BE{ SI fetchw storew } def %MOV SI,immed16
16#BF{ DI fetchw storew } def %MOV AX,immed16

%C0-C1 not used
16#C2{ IP POP SP fetchw SP getw add storew
    ()=
} def %RET immed16(intraseg)
16#C3{ IP POP
    ()=
    flushpage
} def %RET (intraseg)
16#C4{ 1 0 w-d r-m decreg decr-m getw storew } def %LES
16#C5{ 1 1 w-d r-m decreg decr-m getw storew } def %LDS
16#C6{ 1 0 w-d r-m decr-m fetchb storeb } def %REG:0 = MOV MEM8,immed8
16#C7{ 1 1 w-d r-m decr-m fetchw storew } def %REG:0 = MOV MEM16,immed16
%C8-C9 not used
16#CA{ IP POP &lt;0000&gt; POP pop SP fetchw SP getw add storew
    ()=
} def %RET immed16(interseg)
16#CB{ IP POP &lt;0000&gt; POP pop
    ()=
} def %RET (interseg)
%CC INT 3
%CD INT immed8
%CE INTO
%CF IRET

16#E8{ fetchw IP PUSH IP getw add IP exch storew
    ()=
} def %CALL NEAR-PROC
16#E9{ fetchw IP getw add IP exch storew
    ()=
} def %JMP NEAR-LABEL
16#EA{ IP fetchw storew fetchw pop
    ()=
} def %JMP FAR-LABEL
16#EB{ fetchb bext IP getw add IP exch storew
    ()=
} def %JMP SHORT-LABEL

16#F4{ exit } def %HLT
16#F5{ /CF CF 1 xor def } def %CMC

/NOT { not } def
/NEG { neg } def
/F6T { TEST UNU NOT NEG MUL IMUL DIV IDIV } cvlit def
16#F6{ 1 0 w-d r-m decr-m dup getw F6T REG get exec storew } def

16#F8{ /CF 0 def } def %CLC
16#F9{ /CF 1 def } def %STC

/FET { INC DEC } cvlit def
16#FE{ 1 0 w-d r-m decr-m FET REG get exec } def
/FFT { INC DEC
    { IP PUSH IP exch getw storew } %CALL REG16/MEM15 (intra)
    { &lt;0000&gt; PUSH IP PUSH IP exch getw storew } %CALL MEM16 (intersegment)
    { IP exch getw storew } %JMP REG16/MEM15 (intra)
    { } %JMP MEM16 (intersegment)
    PUSH %PUSH MEM16
} cvlit def
16#FF{ 1 1 w-d r-m decr-m FFT REG get exec
    ()=
} def


/regdump {
    FL flagw storew
    0 2 reg length 2 sub {
        reg exch 2 getinterval
        (%stdout)(w) file
        exch
        writehexstring
        ( )print
    } for
    ()=
} def

%/= /== load def
%errordict/undefined{pop{}}put
%{

(cp437.ps)run
/CP437 <span class="diff-delete">12</span> selectfont

/showvideo {
    40 700 moveto
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval
        gsave show grestore
        0 -10 rmoveto
    } for
} def

/printvideo {
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval <span class="diff-delete">=</span>
    } for
} def

/enter {
    (&gt;)print flush
    {mark(%stdin)(r)file read}stopped cleartomark
} def

ARGUMENTS {
    (r) file mem readstring pop pop

    IP 0 storew
    SP 16#100 storew
    {
        debug { ()= regdump } if
        fetchb
        trace { bytedump } if
        load exec
        <span class="diff-delete">showvideo</span>
        %enter
    } loop

    debug{ &lt;&gt;= }if
    printvideo
} forall

%} stopped { countexecstack array execstack == } if
</code></pre><p><span class="diff-delete"> I now join the ranks of</span> the screenshot<span class="diff-delete"> posts.</span></p><p><img class="diff-delete"src="http://i.stack.imgur.com/QEtEt.png" alt="screenshot with hello world! and mysterious caret"></p>
            </div>
            <div class="post-text">
                <h1>Postscript (<del>130</del> <del>200</del> <del>367</del> <del><span class="diff-add">517</span></del> <span class="diff-add">531</span> lines)</h1><p><em><span class="diff-add">Latest version runs test program to completion!</span></em></p><p><del><span class="diff-add">Still a work-in-progress, but</span></del> <span class="diff-add">I</span> wanted to show some code in an effort to encourage others to <em>show some code</em>.</p><div class="diff-skipped"><div></div></div><p><em><span class="diff-add">edit:</span></em> <span class="diff-add">Runs the test to completion. The final few bugs were: XCHG doing 2{read store}repeat which of course copies rather than exchanges, AND not setting flags, (FE) INC trying to get a word from a byte pointer.</span></p><pre><code>%!
%8086 Emulator
/debug true def
/trace false def
/bytedump { dup 16#100 add 16 3 string cvrs 1 2 getinterval ==only } def

%sign-extend byte or word to PS integer (32-bit)
/bext { dup 16#80 and 0 ne { not 16#ff and 1 add neg } if } def
/wext { dup 16#8000 and 0 ne { not 16#ffff and 1 add neg } if } def

/signb { 16#80 and 0 ne } def
/signw { 16#8000 and 0 ne } def

/negb { 16#FF xor 1 add } def
/negw { 16#FFFF xor 1 add } def

%extend byte to word
/byteword { dup signb { negb negw } if } def
/wordquad { dup signw { negw neg } if } def

%memory and register byte-strings
/mem 16#FFFF string def
/reg 20 string def
%register pointers
0 {AL AH CL CH DL DH BL BH}{reg 2 index 1 getinterval def 1 add}forall pop
0 {AX CX DX BX SP BP SI DI IP FL}{reg 2 index 2 getinterval def 2 add}forall pop
/CF 0 def
/AF 0 def
/OF 0 def
/SF 0 def
/ZF 0 def

/memb { 16#ffff mod mem exch 1 getinterval } def
/memw { 16#ffff mod mem exch 2 getinterval } def

%load byte or word from a "pointer" (substring)
/getb { 0 get } def
/getw { dup getb exch 1 get 8 bitshift add } def

%store byte or word through a "pointer"
/storeb { 16#ff and 0 exch put } def
/storew { 2 copy storeb -8 bitshift 16#ff and 1 exch put } def

%shift and mask a bitfield off the bottom of an integer
/shiftmask { 2 copy neg bitshift 3 1 roll 1 exch bitshift 1 sub and } def

%load byte or word from mem[IP++]
/fetchb { IP getw memb getb
    %bytedump
    debug {bytedump} if
    IP dup getw 1 add storew } def
/fetchw { fetchb fetchb 8 bitshift add } def

%decoding tables
%REGT[W][REG] -&gt; pointer
/REGT[[AL CL DL BL AH CH DH BH][AX CX DX BX SP BP SI DI]]def
/R-MT[[{BX getw SI getw add} %R-MT[MOD][R-M] -&gt; {pointer}
    {BX getw DI getw add}
    {BP getw SI getw add}
    {BP getw DI getw add}
    {SI getw}
    {DI getw}
    {fetchw}
    {BX getw}]
[{BX getw SI getw fetchb add add}
    {BX getw DI getw fetchb add add}
    {BP getw SI getw fetchb add add}
    {BP getw DI getw fetchb add add}
    {SI getw fetchb add}
    {DI getw fetchb add}
    {BP getw fetchb add}
    {BX getw fetchb add}]
[{BX getw SI getw fetchw add add}
    {BX getw DI getw fetchw add add}
    {BP getw SI getw fetchw add add}
    {BP getw DI getw fetchw add add}
    {SI getw fetchw add}
    {DI getw fetchw add}
    {BP getw fetchw add}
    {BX getw fetchw add}]]def

/w-d{{W D}{exch def}forall} def %assign W and D
/r-m{ %fetch and parse the MOD-REG-R/M byte
    fetchb
    3 shiftmask /R-M exch def
    3 shiftmask /REG exch def
    /MOD exch def} def
/decreg { REGT W get REG get } def
/decr-m { MOD 3 eq { REGT W get R-M get }{
        R-MT MOD get R-M get exec
        {memb memw}W get exec
    } ifelse } def
/opands { %decode the operands -&gt; (REG) (R/M)
    decreg
    decr-m
} def
/dest { % (REG) (R/M) -&gt; (DEST) (REG) (R/M)
    D index % 1:REG 0:R-M
    3 1 roll } def

%fetch&amp;decode M-R-R/M byte, -&gt; DEST REG R/M
/byteop { r-m opands dest
    exch getb %bext
    exch getb %bext
} def
/wordop { r-m opands dest
    exch getw %wext
    exch getw %wext
} def
/doop {{byteop wordop}W get exec} def

/setCF { dup
    {7 15}W get shiftmask pop
    dup 1 and exch -1 bitshift 1 and % _8|16 _9|17
        %dup /CF exch def
        2 copy ne {1}{0} ifelse /CF exch def
    xor /OF exch def
} def

/setZF { dup 0 eq {/ZF 1 def}{/ZF 0 def} ifelse } def
/setSF { dup {-7 -15}W get bitshift 1 and /SF exch def } def
/setF { setZF setSF } def
/logF { setF /CF 0 def /OF 0 def } def %logical operators clear OF+CF

/nz1 { 0 ne{1}{0}ifelse } def %nonzero to 1
/arithF {
    /CF c {16#ff00 16#ffff0000}W get and nz1 def
    /OF c a xor c b xor and {16#80 16#8000}W get and nz1 def
    /AF a b xor c xor 16#10 and nz1 def
} def
/ADD {
    debug {()= pstack} if
    {b a}{exch def}forall
    /c a b add def
    c arithF setF
} def
/SUB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b sub def
    c arithF setF
} def
/SBB {
    D 1 xor {exch}repeat
    {b a}{exch def}forall
    /c a b CF add sub def
    c arithF setF
} def

%OPCODEs
%/ADD { add setF } def
16#00{ 0 0 w-d doop ADD storeb } def %ADDB R/M,REG
16#01{ 0 1 w-d doop ADD storew } def %ADDW R/M,REG
16#02{ 1 0 w-d doop ADD storeb } def %ADDB REG,R/M
16#03{ 1 1 w-d doop ADD storew } def %ADDW REG,R/M
16#04{ 0 0 w-d AL dup getb fetchb ADD storeb } def %ADDB AL,immed8
16#05{ 0 1 w-d AX dup getw fetchw ADD storew } def %ADDW AX,immed16
%06 PUSH ES
%07 POP ES
/OR { or logF } def
16#08{ 0 0 w-d doop OR storeb } def %OR R/M,REG
16#09{ 0 1 w-d doop OR storew } def %OR R/M,REG
16#0A{ 1 0 w-d doop OR storeb } def %OR REG,R/M
16#0B{ 1 1 w-d doop OR storew } def %OR REG,R/M
16#0C{ 0 0 w-d AL dup getb fetchb OR storeb } def %OR AL,immed8
16#0D{ 0 1 w-d AX dup getw fetchw OR storew } def %OR AX,immed16
%0E PUSH CS
%0F (not used)

/ADC { CF add ADD } def
16#10{ 0 0 w-d doop ADC storeb } def %ADC R/M,REG
16#11{ 0 1 w-d doop ADC storew } def %ADC R/M,REG
16#12{ 1 0 w-d doop ADC storeb } def %ADC REG,R/M
16#13{ 1 1 w-d doop ADC storew } def %ADC REG,R/M
16#14{ 0 0 w-d AL dup getb fetchb ADC storeb } def %ADC AL,immed8
16#15{ 0 1 w-d AX dup getw fetchw ADC storew } def %ADC AX,immed16
%16 PUSH SS
%17 POP SS
%/SBB { D 1 eq{exch}if sub CF sub setF } def
16#18{ 0 0 w-d doop SBB storeb } def %SBB R/M,REG
16#19{ 0 1 w-d doop SBB storew } def %SBB R/M,REG
16#1A{ 1 0 w-d doop SBB storeb } def %SBB REG,R/M
16#1B{ 1 1 w-d doop SBB storew } def %SBB REG,R/M
16#1C{ 0 0 w-d AL dup getb fetchb SBB storeb } def %SBB AL,immed8
16#1D{ 0 1 w-d AX dup getw fetchw SBB storew } def %SBB AX,immed16
%1E PUSH DS
%1F POP DS

/AND { and logF } def
16#20{ 0 0 w-d doop <span class="diff-add">AND</span> storeb } def %AND R/M,REG
16#21{ 0 1 w-d doop <span class="diff-add">AND</span> storew } def %AND R/M,REG
16#22{ 1 0 w-d doop <span class="diff-add">AND</span> storeb } def %AND REG,R/M
16#23{ 1 1 w-d doop <span class="diff-add">AND</span> storew } def %AND REG,R/M
16#24{ 0 0 w-d AL dup getb fetchb <span class="diff-add">AND</span> storeb } def %AND AL,immed8
16#25{ 0 1 w-d AX dup getw fetchw <span class="diff-add">AND</span> storew } def %AND AX,immed16
%26 ES
%27 DAA
%/SUB { D{exch}repeat sub setF } def
16#28{ 0 0 w-d doop SUB storeb } def %SUB R/M,REG
16#29{ 0 1 w-d doop SUB storew } def %SUB R/M,REG
16#2A{ 1 0 w-d doop SUB storeb } def %SUB R/M,REG
16#2B{ 1 1 w-d doop SUB storew } def %SUB R/M,REG
16#2C{ 0 0 w-d AL dup getb fetchb SUB storeb } def %SUB AL,immed8
16#2D{ 0 1 w-d AX dup getw fetchw SUB storew } def %SUB AX,immed16
%2E CS:
%2F DAS

/XOR { xor logF } def
16#30{ 0 0 w-d doop xor storeb } def %XOR R/M,REG
16#31{ 0 1 w-d doop xor storew } def %XOR R/M,REG
16#32{ 1 0 w-d doop xor storeb } def %XOR REG,R/M
16#33{ 1 1 w-d doop xor storew } def %XOR REG,R/M
16#34{ 0 0 w-d AL dup getb fetchb xor storeb } def %XOR AL,immed8
16#35{ 0 1 w-d AX dup getw fetchw xor storew } def %XOR AX,immed16
%36 SS:
%37 AAA
/CMP {
    debug { regdump pstack()= } if
        SUB
        debug { dup = } if
        pop } def
16#38{ 0 0 w-d doop CMP pop } def %CMP R/M,REG
16#39{ 0 1 w-d doop CMP pop } def %CMP R/M,REG
16#3A{ 0 0 w-d doop CMP pop } def %CMP REG,R/M
16#3B{ 0 1 w-d doop CMP pop } def %CMP REG,R/M
16#3C{ 0 0 w-d AL dup getb fetchb CMP pop } def %CMP AL,immed8
16#3D{ 0 1 w-d AX dup getw fetchw CMP pop } def %CMP AX,immed16
%3E DS
%3F AAS

/INC { CF exch dup <span class="diff-add">{{getb bext} {</span>getw wext<span class="diff-add">}}W</span> <span class="diff-add">get exec </span>1 ADD<span class="diff-add">
  </span> <span class="diff-add"> {storeb </span>storew<span class="diff-add">}W get</span> <span class="diff-add">exec </span>/CF exch def } def
16#40{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>AX INC } def
16#41{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>CX INC } def
16#42{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>DX INC } def
16#43{ <span class="diff-add">0 1 w-d </span>BX INC } def
16#44{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>SP INC } def
16#45{<span class="diff-add"> 0 1 w-d</span> BP INC } def
16#46{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>SI INC } def
16#47{<span class="diff-add"> 0 1 w-d</span> DI INC } def
/DEC { CF exch dup <span class="diff-add">{{getb bext} {</span>getw wext<span class="diff-add">}}W</span> <span class="diff-add">get exec </span>1 sub setF<span class="diff-add">
  </span> <span class="diff-add"> {storeb </span>storew<span class="diff-add">}W get</span> <span class="diff-add">exec </span>/CF exch def } def
16#48{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>AX DEC } def
16#49{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>CX DEC } def
16#4A{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>DX DEC } def
16#4B{ <span class="diff-add">0 1 w-d </span>BX DEC } def
16#4C{<span class="diff-add"> 0 1</span> <span class="diff-add">w-d </span>SP DEC } def
16#4D{<span class="diff-add"> 0 1 w-d</span> BP DEC } def
16#4E{<span class="diff-add"> 0</span> <span class="diff-add">1 w-d </span>SI DEC } def
16#4F{<span class="diff-add"> 0 1 w-d</span> DI DEC } def

%/PUSH { SP DEC SP DEC getw mem SP getw 2 getinterval exch storew } def
/PUSH{ SP dup getw
    dup =
    2 sub storew
    getw SP getw memw exch storew
    %enter
    SP getw =
} def
16#50{ AX PUSH } def
16#51{ CX PUSH } def
16#52{ DX PUSH } def
16#53{ BX PUSH } def
16#54{ SP PUSH } def
16#55{ BP PUSH } def
16#56{ SI PUSH } def
16#57{ DI PUSH } def

%/POP { mem SP getw 2 getinterval getw storew SP INC SP INC } def
/POP { SP getw memw getw storew
    SP dup getw 2 add storew } def
16#58{ AX POP } def
16#59{ CX POP } def
16#5A{ DX POP } def
16#5B{ BX POP } def
16#5C{ SP POP } def
16#5D{ BP POP } def
16#5E{ SI POP } def
16#5F{ DI POP } def
%60-6F

/jrel { { bext IP getw add IP exch storew }{ pop } ifelse } def
%16#71 JNO short-label
16#72{ fetchb CF 1 eq jrel } def %JB/JNAE/JC short-label
16#73{ fetchb CF 0 eq jrel } def %JNB/JAE/JNC short-label
16#74{ fetchb ZF 1 eq jrel } def %JF/JZ short-label
16#75{ fetchb ZF 0 eq jrel } def %JNE/JNZ short-label
16#76{ fetchb CF ZF or 1 eq jrel } def %JBE/JNA short-label
16#77{ fetchb CF ZF or 0 eq jrel } def %JNBE/JA short-label
16#78{ fetchb SF 1 eq jrel } def %JS short-label
16#79{ fetchb SF 0 eq jrel } def %JNS short-label
%16#7A JP/JPE short-label
%16#7B JNP/JPO short-label
16#7C{ fetchb SF OF xor 1 eq jrel } def %JL/JNGE short-label
16#7D{ fetchb SF OF xor 0 eq jrel } def %JNL/JGE short-label
16#7E{ fetchb SF OF xor ZF or 1 eq jrel } def %JLE/JNG short-label
16#7F{ fetchb SF OF xor ZF or 0 eq jrel } def %JNLE/JG short-label

/CMPp{ CMP pop &lt;0000&gt; 0 } def
/OPEXT {ADD OR ADC SBB AND SUB XOR CMPp} cvlit def
16#80{ 0 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb bext fetchb bext
    OPEXT REG get exec storeb } def
16#81{ 0 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw wext fetchw wext
    OPEXT REG get exec storew } def

/UNU {pop} def %unused
/OPEX2 {ADD UNU ADC SBB UNU SUB UNU CMPp} cvlit def
16#82{ 1 0 w-d r-m
    debug { REG =only } if
    decr-m dup getb %bext
        fetchb %bext
    OPEX2 REG get exec storeb } def
16#83{ 1 1 w-d r-m
    debug { REG =only } if
    decr-m dup getw %wext
        fetchb byteword %bext
    OPEX2 REG get exec storew } def

%16#84 TEST
%16#85 TEST
/XCHG { 2 copy exch
    {getb getw}W get exec
    4 2 roll
    {getb getw}W get exec
    2{ {storeb storew}W get exec }repeat
} def
16#86{ 1 0 w-d r-m opands XCHG } def %XCHG REG8,R/M8
16#87{ 1 1 w-d r-m opands XCHG } def %XCHG REG16,R/M16
16#88{ 0 0 w-d r-m opands exch getb storeb } def %MOV R/M8,REG8
16#89{ 0 1 w-d r-m opands exch getw storew } def %MOV R/M16,REG16
16#8A{ 1 0 w-d r-m opands getb storeb } def %MOV REG8,R/M8
16#8B{ 1 1 w-d r-m opands getw storew } def %MOV REG16,R/M16
%16#8C MOV REG16,SEGREG
16#8D{ 0 1 w-d r-m REGT W get REG get load
    R-MT MOD get R-M get exec storew } def %LEA REG16,MEM16
%16#8E MOV SEGREG,REG16
/8FT { POP } cvlit def
16#8F{ 1 1 w-d r-m decr-m 8FT REG get exec } def %REG:0 = POP R/M16
16#90{ } def %NOP
16#91{ AX CX XCHG } def %XCHG AX,CX
16#92{ AX DX XCHG } def %XCHG AX,DX
16#93{ AX BX XCHG } def %XCHG AX,BX
16#94{ AX SP XCHG } def %XCHG AX,SP
16#95{ AX BP XCHG } def %XCHG AX,BP
16#96{ AX SI XCHG } def %XCHG AX,SI
16#97{ AX DI XCHG } def %XCHG AX,DI
16#98{ AX AL getb bext storew } def %CBW
16#99{ DX AX getw wext 16 shiftmask pop storew } def %CWD
16#9A{ fetchw fetchw &lt;0000&gt; PUSH pop IP getw PUSH IP exch storew
    %()=
} def %CALL FAR PROC
%16#9B %WAIT
/flagw {
    OF 11 bitshift
    SF 7 bitshift or
    ZF 6 bitshift or
    AF 4 bitshift or
    CF 0 bitshift or
} def
/wflag {
    dup  0 bitshift 1 and /CF exch def
    dup -4 bitshift 1 and /AF exch def
    dup -6 bitshift 1 and /ZF exch def
    dup -7 bitshift 1 and /SF exch def
    dup -11 bitshift 1 and /OF exch def
    pop
} def
16#9C{ &lt;0000&gt; dup flagw storew PUSH } def %PUSHF
16#9D{ POP wflag } def %POPF
16#9E{ AH flagw storeb } def %SAHF
16#9F{ AH getb OF 11 bitshift or wflag } def %LAHF

16#A0{ AL mem fetchw get storeb } def %MOV AL,MEM8
16#A1{ AX mem fetchw 2 getinterval getw storew } def %MOV AX,MEM16
16#A2{ mem fetchw 1 getinterval AL getb storeb } def %MOV MEM8,AL
16#A3{ mem fetchw 2 getinterval AX getw storew } def %MOV MEM16,AX
%A4-AF MOVS CMPS TEST STOS LODS SCAS

16#B0{ AL fetchb storeb } def %MOV AL,immed8
16#B1{ CL fetchb storeb } def %MOV CL,immed8
16#B2{ DL fetchb storeb } def %MOV DL,immed8
16#B3{ BL fetchb storeb } def %MOV BL,immed8
16#B4{ AH fetchb storeb } def %MOV AH,immed8
16#B5{ CH fetchb storeb } def %MOV CH,immed8
16#B6{ DH fetchb storeb } def %MOV DH,immed8
16#B7{ BH fetchb storeb } def %MOV BH,immed8
16#B8{ AX fetchw storew } def %MOV AX,immed16
16#B9{ CX fetchw storew } def %MOV CX,immed16
16#BA{ DX fetchw storew } def %MOV DX,immed16
16#BB{ BX fetchw storew } def %MOV BX,immed16
16#BC{ SP fetchw storew } def %MOV SP,immed16
16#BD{ BP fetchw storew } def %MOV BP,immed16
16#BE{ SI fetchw storew } def %MOV SI,immed16
16#BF{ DI fetchw storew } def %MOV AX,immed16

%C0-C1 not used
16#C2{ IP POP SP fetchw SP getw add storew
    ()=
} def %RET immed16(intraseg)
16#C3{ IP POP
    ()=
<span class="diff-add">    showvideo
</span>    flushpage
<span class="diff-add">    %enter
</span>} def %RET (intraseg)
16#C4{ 1 0 w-d r-m decreg decr-m getw storew } def %LES
16#C5{ 1 1 w-d r-m decreg decr-m getw storew } def %LDS
16#C6{ 1 0 w-d r-m decr-m fetchb storeb } def %REG:0 = MOV MEM8,immed8
16#C7{ 1 1 w-d r-m decr-m fetchw storew } def %REG:0 = MOV MEM16,immed16
%C8-C9 not used
16#CA{ IP POP &lt;0000&gt; POP pop SP fetchw SP getw add storew
    ()=
} def %RET immed16(interseg)
16#CB{ IP POP &lt;0000&gt; POP pop
    ()=
} def %RET (interseg)
%CC INT 3
%CD INT immed8
%CE INTO
%CF IRET

16#E8{ fetchw IP PUSH IP getw add IP exch storew
    ()=
} def %CALL NEAR-PROC
16#E9{ fetchw IP getw add IP exch storew
    ()=
} def %JMP NEAR-LABEL
16#EA{ IP fetchw storew fetchw pop
    ()=
} def %JMP FAR-LABEL
16#EB{ fetchb bext IP getw add IP exch storew
    ()=
} def %JMP SHORT-LABEL

16#F4{ exit } def %HLT
16#F5{ /CF CF 1 xor def } def %CMC

/NOT { not } def
/NEG { neg } def
/F6T { TEST UNU NOT NEG MUL IMUL DIV IDIV } cvlit def
16#F6{ 1 0 w-d r-m decr-m dup getw F6T REG get exec storew } def

16#F8{ /CF 0 def } def %CLC
16#F9{ /CF 1 def } def %STC

/FET { INC DEC } cvlit def
16#FE{ 1 0 w-d r-m decr-m FET REG get exec } def
/FFT { INC DEC
    { IP PUSH IP exch getw storew } %CALL REG16/MEM15 (intra)
    { &lt;0000&gt; PUSH IP PUSH IP exch getw storew } %CALL MEM16 (intersegment)
    { IP exch getw storew } %JMP REG16/MEM15 (intra)
    { } %JMP MEM16 (intersegment)
    PUSH %PUSH MEM16
} cvlit def
16#FF{ 1 1 w-d r-m decr-m FFT REG get exec
    ()=
} def


/regdump {
    FL flagw storew
    0 2 reg length 2 sub {
        reg exch 2 getinterval
        (%stdout)(w) file
        exch
        writehexstring
        ( )print
    } for
    ()=
} def

%/= /== load def
%errordict/undefined{pop{}}put
%{

(cp437.ps)run
/CP437 <span class="diff-add">14</span> selectfont

/showvideo {
    40 700 moveto
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval
        gsave show grestore
        0 -10 rmoveto
    } for
} def

/printvideo {
    16#8000 80 80 25 mul 16#8000 add {
        mem exch 80 getinterval <span class="diff-add">{
            dup 32 ge 1 index 126 le and {
                ( ) dup 0 4 3 roll put print
            }{
                ( )print
            }ifelse
        } forall
        (\n)print</span>
    } for
} def

/enter {
    (&gt;)print flush
    {mark(%stdin)(r)file read}stopped cleartomark
} def

ARGUMENTS {
    (r) file mem readstring pop pop

    IP 0 storew
    SP 16#100 storew
    {
        debug { ()= regdump } if
        fetchb
        trace { bytedump } if
        load exec
        <span class="diff-add">%showvideo</span>
        %enter
    } loop

    debug{ &lt;&gt;= }if
<span class="diff-add">    showvideo
</span>    printvideo
} forall

%} stopped { countexecstack array execstack == } if
<span class="diff-add">enter
showpage
</span></code></pre><p><span class="diff-add"> And</span> the screenshot<span class="diff-add">:</span></p><p><img class="diff-add"src="http://i.stack.imgur.com/ZHNoB.png" alt="test program output"></p>
            </div>
        </div>

</div>
                        </div>
                    </td>
                </tr>
                <tr id="spacer-db5399cc-561c-4a19-a193-fd2c3a19b304">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('b39407ba-2f8f-40f3-8877-7f31b04f4efc') ">
                        <span id="rev-arrow-b39407ba-2f8f-40f3-8877-7f31b04f4efc" class="expander-arrow-hide" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('b39407ba-2f8f-40f3-8877-7f31b04f4efc') ">
                        <span title="revision 4">4</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">some bugs fixed. many remain.</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/b39407ba-2f8f-40f3-8877-7f31b04f4efc/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/4" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-12-06 07:03:53Z" class="relativetime">Dec 6 '12 at 7:03</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="revb39407ba-2f8f-40f3-8877-7f31b04f4efc" class="revcell5" style="display: none">
                        </div>
                    </td>
                </tr>
                <tr id="spacer-b39407ba-2f8f-40f3-8877-7f31b04f4efc">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('1e76f1c4-37f4-4902-9dca-d0b91a48e604') ">
                        <span id="rev-arrow-1e76f1c4-37f4-4902-9dca-d0b91a48e604" class="expander-arrow-hide" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('1e76f1c4-37f4-4902-9dca-d0b91a48e604') ">
                        <span title="revision 3">3</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">It runs (a little).</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/1e76f1c4-37f4-4902-9dca-d0b91a48e604/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/3" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-11-30 07:24:44Z" class="relativetime">Nov 30 '12 at 7:24</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev1e76f1c4-37f4-4902-9dca-d0b91a48e604" class="revcell5" style="display: none">
                        </div>
                    </td>
                </tr>
                <tr id="spacer-1e76f1c4-37f4-4902-9dca-d0b91a48e604">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('079960a6-a5ad-43ee-a86a-f046ad7d6838') ">
                        <span id="rev-arrow-079960a6-a5ad-43ee-a86a-f046ad7d6838" class="expander-arrow-hide" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('079960a6-a5ad-43ee-a86a-f046ad7d6838') ">
                        <span title="revision 2">2</span>
                    </td>
                    <td class="revcell3 vm">
                        <span class="revision-comment">added 2576 characters in body</span>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/079960a6-a5ad-43ee-a86a-f046ad7d6838/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/2" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        edited <span title="2012-11-26 14:13:27Z" class="relativetime">Nov 26 '12 at 14:13</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev079960a6-a5ad-43ee-a86a-f046ad7d6838" class="revcell5" style="display: none">
                        </div>
                    </td>
                </tr>
                <tr id="spacer-079960a6-a5ad-43ee-a86a-f046ad7d6838">
                    <td colspan="4" height="10px"></td>
                </tr>
                <tr class="owner-revision">
                    <td class="revcell1 vm" onclick="StackExchange.revisions.toggle('0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8') ">
                        <span id="rev-arrow-0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8" class="expander-arrow-hide" title="show/hide this revision&#39;s text"></span>
                    </td>
                    <td class="revcell2 vm" onclick="StackExchange.revisions.toggle('0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8') ">
                        <span title="revision 1">1</span>
                    </td>
                    <td class="revcell3 vm">
                        <br>
                        <div class="post-menu" style="padding-top: 10px;">
                            <a href="/revisions/0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8/view-source" title="view raw text of this revision" target="_blank">source</a><span class="lsep">|</span><a class="single-revision" href="/revisions/9065/1" title="link to this formatted revision">link</a>
                        </div>
                    </td>
                    <td class="revcell4">

<div class="user-info user-hover">
    <div class="user-action-time">
        answered <span title="2012-11-24 09:57:17Z" class="relativetime">Nov 24 '12 at 9:57</span>
    </div>
    <div class="user-gravatar32">
        <a href="/users/2381/luser-droog"><div><img src="https://www.gravatar.com/avatar/db1bf62fae51d5bafb8f1db7fb677176?s=32&d=identicon&r=PG" alt="" width="32" height="32"></div></a>
    </div>
    <div class="user-details">
        <a href="/users/2381/luser-droog">luser droog</a><br>
        <span class="reputation-score" title="reputation score " dir="ltr">1,224</span><span title="1 gold badge"><span class="badge1"></span><span class="badgecount">1</span></span><span title="9 silver badges"><span class="badge2"></span><span class="badgecount">9</span></span><span title="26 bronze badges"><span class="badge3"></span><span class="badgecount">26</span></span>
    </div>
</div>
                    </td>
                </tr>
                <tr>
                    <td colspan="4">
                        <div id="rev0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8" class="revcell5" style="display: none">
                        </div>
                    </td>
                </tr>
                <tr id="spacer-0ac00a1e-049f-4ecb-9b3f-62cb3a1a87b8">
                    <td colspan="4" height="10px"></td>
                </tr>

        </table>

            <div class="pager fl">
        





    </div>


    </div>
</div>

<script type="text/javascript">
    StackExchange.using("revisions", function () { StackExchange.revisions.init(9065) });
</script>

<div style="display:none" id="prettify-lang"></div>
        </div>
    </div>
    <div id="footer" class="categories">
        <div class="footerwrap">
            <div id="footer-menu">
                <div class="top-footer-links">
                        <a href="/about">about</a>
                    <a href="/help">help</a>
                        <a href="/help/badges">badges</a>
                    <a href="http://blog.stackexchange.com?blb=1">blog</a>
                        <a href="http://chat.stackexchange.com">chat</a>
                    <a href="http://data.stackexchange.com">data</a>
                    <a href="http://stackexchange.com/legal">legal</a>
                    <a href="http://stackexchange.com/legal/privacy-policy">privacy policy</a>
                    <a href="http://stackexchange.com/about/hiring">jobs</a>
                    <a href="http://stackexchange.com/about/contact">advertising info</a>

                    <a onclick='StackExchange.switchMobile("on", "/posts/9065/revisions")'>mobile</a>
                    <b><a href="/contact">contact us</a></b>
                        <b><a href="http://meta.codegolf.stackexchange.com">feedback</a></b>
                    
                </div>
                <div id="footer-sites">
                    <table>
    <tr>
            <th colspan=3>
                Technology
            </th>
            <th >
                Life / Arts
            </th>
            <th >
                Culture / Recreation
            </th>
            <th >
                Science
            </th>
            <th >
                Other
            </th>
    </tr>
    <tr>
            <td>
                <ol>
                        <li><a href="http://stackoverflow.com" title="professional and enthusiast programmers">Stack Overflow</a></li>
                        <li><a href="http://serverfault.com" title="professional system and network administrators">Server Fault</a></li>
                        <li><a href="http://superuser.com" title="computer enthusiasts and power users">Super User</a></li>
                        <li><a href="http://webapps.stackexchange.com" title="power users of web applications">Web Applications</a></li>
                        <li><a href="http://askubuntu.com" title="Ubuntu users and developers">Ask Ubuntu</a></li>
                        <li><a href="http://webmasters.stackexchange.com" title="pro webmasters">Webmasters</a></li>
                        <li><a href="http://gamedev.stackexchange.com" title="professional and independent game developers">Game Development</a></li>
                        <li><a href="http://tex.stackexchange.com" title="users of TeX, LaTeX, ConTeXt, and related typesetting systems">TeX - LaTeX</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://programmers.stackexchange.com" title="professional programmers interested in conceptual questions about software development">Programmers</a></li>
                        <li><a href="http://unix.stackexchange.com" title="users of Linux, FreeBSD and other Un*x-like operating systems.">Unix &amp; Linux</a></li>
                        <li><a href="http://apple.stackexchange.com" title="power users of Apple hardware and software">Ask Different (Apple)</a></li>
                        <li><a href="http://wordpress.stackexchange.com" title="WordPress developers and administrators">WordPress Answers</a></li>
                        <li><a href="http://gis.stackexchange.com" title="cartographers, geographers and GIS professionals">Geographic Information Systems</a></li>
                        <li><a href="http://electronics.stackexchange.com" title="electronics and electrical engineering professionals, students, and enthusiasts">Electrical Engineering</a></li>
                        <li><a href="http://android.stackexchange.com" title="enthusiasts and power users of the Android operating system">Android Enthusiasts</a></li>
                        <li><a href="http://security.stackexchange.com" title="Information security professionals">Information Security</a></li>
                            </ol></td><td><ol>
                        <li><a href="http://dba.stackexchange.com" title="database professionals who wish to improve their database skills and learn from others in the community">Database Administrators</a></li>
                        <li><a href="http://drupal.stackexchange.com" title="Drupal developers and administrators">Drupal Answers</a></li>
                        <li><a href="http://sharepoint.stackexchange.com" title="SharePoint enthusiasts">SharePoint</a></li>
                        <li><a href="http://ux.stackexchange.com" title="user experience researchers and experts">User Experience</a></li>
                        <li><a href="http://mathematica.stackexchange.com" title="users of Mathematica">Mathematica</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#technology" class="more">
                                more (14)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://photo.stackexchange.com" title="professional, enthusiast and amateur photographers">Photography</a></li>
                        <li><a href="http://scifi.stackexchange.com" title="science fiction and fantasy enthusiasts">Science Fiction &amp; Fantasy</a></li>
                        <li><a href="http://cooking.stackexchange.com" title="professional and amateur chefs">Seasoned Advice (cooking)</a></li>
                        <li><a href="http://diy.stackexchange.com" title="contractors and serious DIYers">Home Improvement</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#lifearts" class="more">
                                more (13)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://english.stackexchange.com" title="linguists, etymologists, and serious English language enthusiasts">English Language &amp; Usage</a></li>
                        <li><a href="http://skeptics.stackexchange.com" title="scientific skepticism">Skeptics</a></li>
                        <li><a href="http://judaism.stackexchange.com" title="those who base their lives on Jewish law and tradition and anyone interested in learning more">Mi Yodeya (Judaism)</a></li>
                        <li><a href="http://travel.stackexchange.com" title="road warriors and seasoned travelers">Travel</a></li>
                        <li><a href="http://christianity.stackexchange.com" title="committed Christians, experts in Christianity and those interested in learning more">Christianity</a></li>
                        <li><a href="http://gaming.stackexchange.com" title="passionate videogamers on all platforms">Arqade (gaming)</a></li>
                        <li><a href="http://bicycles.stackexchange.com" title="people who build and repair bicycles, people who train cycling, or commute on bicycles">Bicycles</a></li>
                        <li><a href="http://rpg.stackexchange.com" title="gamemasters and players of tabletop, paper-and-pencil role-playing games">Role-playing Games</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#culturerecreation" class="more">
                                more (21)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://math.stackexchange.com" title="people studying math at any level and professionals in related fields">Mathematics</a></li>
                        <li><a href="http://stats.stackexchange.com" title="statisticians, data analysts, data miners and data visualization experts">Cross Validated (stats)</a></li>
                        <li><a href="http://cstheory.stackexchange.com" title="theoretical computer scientists and researchers in related fields">Theoretical Computer Science</a></li>
                        <li><a href="http://physics.stackexchange.com" title="active researchers, academics and students of physics">Physics</a></li>
                        <li><a href="http://mathoverflow.net" title="professional mathematicians">MathOverflow</a></li>
                    
                        <li>
                            <a href="http://stackexchange.com/sites#science" class="more">
                                more (7)
                            </a>
                        </li>
                </ol>
            </td>
            <td>
                <ol>
                        <li><a href="http://stackapps.com" title="apps, scripts, and development with the Stack Exchange API">Stack Apps</a></li>
                        <li><a href="http://meta.stackoverflow.com" title="meta-discussion of the Stack Exchange family of Q&amp;A websites">Meta Stack Overflow</a></li>
                        <li><a href="http://area51.stackexchange.com" title="proposing new sites in the Stack Exchange network">Area 51</a></li>
                        <li><a href="http://careers.stackoverflow.com">Stack Overflow Careers</a></li>
                    
                </ol>
            </td>
    </tr>
</table>
                </div>
            </div>

            <div id="copyright">
                site design / logo &#169; 2013 stack exchange inc; user contributions licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license">cc-wiki</a> 
 with <a href="http://blog.stackoverflow.com/2009/06/attribution-required/" rel="license">attribution required</a>
            </div>
            <div id="footer-flair">
                <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="cc-wiki-link"></a>
            </div>
            <div id="svnrev">
                rev 2013.11.26.1178
            </div>
            
        </div>
    </div>
    <noscript>
        <div id="noscript-warning">Programming Puzzles &amp; Code Golf Stack Exchange works best with JavaScript enabled<img src="http://pixel.quantserve.com/pixel/p-c1rF4kxgLUzNc.gif" alt="" class="dno"></div>
    </noscript>

    <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-5620270-24']);
        _gaq.push(['_setDomainName','.stackexchange.com']);
_gaq.push(['_trackPageview']);
    var _qevents = _qevents || [];
    var _comscore = _comscore || [];
    (function () {
        var ssl='https:'==document.location.protocol,
            s=document.getElementsByTagName('script')[0],
            ga=document.createElement('script');
        ga.type='text/javascript';
        ga.async=true;
        ga.src=(ssl?'https://ssl':'http://www')+'.google-analytics.com/ga.js';
        s.parentNode.insertBefore(ga,s);
        var sc=document.createElement('script');
        sc.type='text/javascript';
        sc.async=true;
        sc.src=(ssl?'https://secure':'http://edge')+'.quantserve.com/quant.js';
        s.parentNode.insertBefore(sc, s);
        
        var s = document.createElement("script"), el = document.getElementsByTagName("script")[0]; s.async = true;
        s.src = (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js";
        el.parentNode.insertBefore(s, el);
        
    })();
    _comscore.push({ c1: "2", c2: "17440561" });
    _qevents.push({ qacct: "p-c1rF4kxgLUzNc" });
    </script>            
</body>
</html>